---
tags:
  - 데이터베이스
  - cs
parent: "[[쿼리 최적화]]"
related:
  - "[[B-Tree 인덱스를 통한 데이터 읽기 방식의 종류]]"
created: 2025-07-04
---

# 0. 학습 목적
- 옵티마이저가 `GROUP BY` 를 어떻게 처리하는지 이해한다.
- 인덱스를 활용한 처리 방법 (타이트 인덱스 스캔, 루스 인덱스 스캔) 과 임시 테이블 활용 방법을 이해하고, 해당 계획을 선택하는 이유를 이해한다. 

# 1. 옵티마이저의 `GROUP BY` 처리
옵티마이저가 그루핑에 대한 실행계획을 짤 때, 인덱스를 활용한 계획가 아닌 계획으로 나뉜다. 
인덱스를 활용한 게획은 다시 정렬된 인덱스 값들을 순차적으로 읽어서 그루핑 하기만 하면 되냐 (타이트 인덱스 스캔), 아니면 인덱스마다 그루핑 대상인지 아닌지 확인해서 유효한 인덱스만 그루핑 해야하냐 (루스 인덱스 스캔) 으로 나뉘게 된다.

# 2. 타이트 인덱스 스캔 (tight index scan) 
타이트 인덱스 스캔은 인덱스를 순차적으로 읽어서 그룹화하는 방식이다. 집계함수를 쓰지 않는 한, 정렬된 데이터를 읽어서 구분 짓기만 하면 되므로, 임시 테이블은 따로 필요 없다. 

## (1) 조건
1. 그루핑 대상 컬럼이 첫 번째 드라이빙 테이블의 컬럼만을 대상으로 한다.
2. 그루핑 대상 컬럼의 순서와 요소를 그대로 지킨 인덱스가 첫 번째 드라이빙 테이블에 존재한다.
3. 쿼리문 자체가 정렬된 인덱스 값들을 순차적으로 읽고 그루핑만하면 된다. (매 요소마다 유효성 검사 x) 

## (2) 활용 그루핑 과정

### A. 단순 그루핑문인 경우 
```sql
select emp_no
from salaries
GROUP BY emp_no;
```
`salaries`에 `emp_no`로 인덱스가 생성되어 있을 경우, 해당 쿼리문은 타이트 인덱스를 실행한다. 

### B. Group By + join 쿼리문인 경우
위의 규칙을 전부 지킨다면, 
1. 첫 번째 드라이빙 테이블을 타이트 인덱스 스캔으로 선 그루핑
2. 그루핑 결과를 드리븐 테이블과 조인 

### C. Group By + 집계 함수 쿼리문인 경우
집게 함수 처리를 위해 임시 테이블이 사용 될 수 있다. 

## (3) 실행 계획 상 표시
Extra에 어떠한 표시도 뜨지 않는다. 

# 3. 루스 인덱스 스캔 (loose index scan)
타이트 인덱스 스캔과 반대로, 매 인덱스 리프노드마다 유효성 검사를 한다. 검사 후 쓸모가 없는 리프노드는 다음 작업에서 생략한다. 해당 방법 또한 임시 테이블이 필요 없다.

## (1) 조건
1. 단일 테이블 대상 그루핑에만 사용할 수 있다. 
   (그루핑 조건 컬럼이 서로 다른 테이블들을 가리키면 안됨)
2. 프리픽스 인덱스(prefix index)는 루스 인덱스 스캔으로 활용할 수 없다. 

## (2) 활용 그루핑 과정 
```sql
select emp_no
from salaries
where from_date='1985-03-01'
group by emp_no;
```

0. 가정: 샐러리 테이블은 `(emp_no, from_date)` 로 인덱싱이 되어 있는 상황 
1.  그룹 키에 해당하는 emp_no의 첫 번째 유니크 값을 읽는다.
2. 이후 from_date = '1985-03-01' 인 값들만 메모리에 적재한다.
3. emp_no의 두 번째 유니크 값을 읽는다.
4. 3번에서 더 이상 읽을 다음 유니크 값이 없다면, 쿼리문을 종료한다.

이 그루핑 과정은 
```sql
select emp_no
from salaries
where emp_no = '100001' AND from_date='1985-03-01'
```
라는 쿼리문의 앞에 emp_no의 필터링 조건 대상을 모든 emp_no의 유니크 컬럼 값으로 바꿔가며 하는 것과 동일하다.  이 측면에서, `인덱스 스킵 스캔`과 작동원리가 같다.

## (3) 실행 계획 상 표시
Extra 부분에 **`Using index for group-by`**  라고 표시 된다.

## (4) 특징 
- 루스 인덱스 스캔은 그룹 키의 **카디널리티가 낮을수록 성능이 좋다.**

#### why?
카디널리티가 높을수록, 그루핑할 컬럼의 값에 유니크한 값이 많다는 것을 의미한다. 
이는 다음 그룹 키 유니크 값을 찾기 위한 트리 탐색 횟수를 늘리기 때문에 루스 인덱스 스캔의 비용을 증가 시킨다. 
반면 카디널리티가 낮으면, 그룹 키 탐색 횟수가 줄기에 훨씬 빨라진다.

예시) 특정 컬럼이 10만 개인데, 카디널리티가 10이라면, 총 10번의 그룹키 탐색만 하면된다. 반면 10만 개의 컬럼에 카디널리티가 10만 개라면 10만번의 그룹키 탐색이 필요하다.

# 4. 임시 테이블 활용 그루핑 

## (1) 조건
그루핑의 대상 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 상관없이, **인덱스 활용이 불가능한 경우**, 무조건 임시 테이블 활용 그루핑이 이루어진다.

## (2) 과정
```sql
   select e.last_name, avg(s.salary)
   from employees e, salaries s
   where s.emp_no = e.emp_no
   group by e.last_name;
```

실행 계획이 임시 테이블 활용 그루핑이라면 다음 과정을 실행한다.
1. 그루핑 컬럼 값들을 유니크 인덱스로 가진 임시 테이블 생성 
2. 해당 임시 테이블에 조인 결과를 인덱스 중복 없도록 insert, update
3. update 시 집계 함수 연산 같이 적용 

## (3) MySQL에서 그루핑 시 자동 정렬이 되는가? 
**5.7 버전까지는 Yes, 8.0 버전 이후로는 No**

5.7버전까지는 그루핑 되는 컬럼 값을 기준으로 묵시적인 정렬도 함께 진행되었으나, 8.0버전 이후로는 그런 과정이 사라졌다.

# 5. 핵심 요약
- 옵티마이저가 `GROUP BY` 실행 계획을 짜는 방식은 크게 2가지 세부적으로 3가지가 있다. 먼저 인덱스를 활용한 그루핑과 임시 테이블을 활용한 그루핑으로 크게 나눌 수 있고, 인덱스 활용한 정렬은 타이트 인덱스 스캔과 루스 인덱스 스캔으로 다시 나뉜다.
- `타이트 인덱스 스캔`은 인덱스 B+tree의 루프 노드에 대한 유효성 검사 없이 순차적으로 읽어서 그루핑 하는 것이다.
- `루스 인덱스 스캔`은 인덱스 리프 노드에 대해 하나하나 유효성 검사를 하고, 쓸모 없는 리프노드는 다음 작업 대상에서 뺀다. 루스 인덱스 스캔은 인덱스 컬럼 값의 카디널리티가 낮을수록 성능이 높다.
- `임시 테이블을 활용한 그루핑`은 그룹키들을 유니크 인덱스로 가지는 임시테이블을 생성하여 조인 결과 혹은 데이터 리드 결과들을 중복없이 저장 및 그룹 함수 결과를 update한다. 

---

# Metadata

### A. 모르는 단어 정리 
- `프리픽스 인덱스(prefix index)`
  : 컬럼 값 중 앞의 일부분 만을 컬럼 키로 하여 생성한 인덱스
  
- `그룹 키`
  : GROUP BY 절에서 데이터를 그룹화하는 기준이 되는 컬럼 또는 표현식
  
- `카디널리티 (Cardinality)`
  : 하나의 컬럼에서 유니크한 컬럼 값의 개수 
  
- `그룹 키 탐색`
  : 다음 유니크 값과 가장 가까운 공통 조상 노드를 찾은 후, 다음 유니크 값을 찾는 노드를 타고 가는 과정

###  B. 참고 문서

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
