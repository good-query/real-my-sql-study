---
tags:
  - 데이터베이스
  - cs
parent: "[[조인 (Join) 이란]]"
related:
  - "[[고급 최적화]]"
  - "[[MRR (Multi-Range-Read)]]"
created: 2025-07-16
---

# 0. 학습 목적
- BKA 조인의 작동 원리를 이해한다. 
- BNL 조인과의 차이점을 이해한다. 

# 1. BKA (Batch-Key-Access) 조인이란? 
조인 버퍼와 MRR 인터페이스를 활용하여, Nested Loop Join에서 문제가 되던 너무 많은 랜덤 I/O 접근을 한 번의 순차 I/O로 전환하여 최적화하는 조인전략을 말한다.

# 2. BKA 조인의 과정 
1. 드라이빙 테이블 스캔 후 조인 버퍼 적재
2. Key Build (조인버퍼 각 행의 (조인 컬럼, 조인 버퍼 속 위치 offset) 튜플을 추출해 랜덤 버퍼에 적재) 
3. MRR 인터페이스 호출 (드리븐 테이블의 조인 컬럼으로 이루어진 보조 인덱스 활용하여 PK 값 추출 및 정렬) 
4. MRR 인터페이스가 드리븐 본 테이블 (클러스터링 테이블)을 3번에서 정렬한 PK 값 순으로 순차 접근 
5. 조인 버퍼 행 + 드리븐 행 조합하여 최종 결과 로우 생성 

이제 하나씩 자세히 알아보자. 먼저 설명을 위해 예시 드라이빙 테이블과 드리븐 테이블을 다음과 같이 설정 하겠다.
```sql
-- 드라이빙 테이블
CREATE TABLE 학생 (
	학번 int PRIMARY KEY,
	이름 varchar(10),
	주소 varchar(30)
) engine = 'innodb'

-- 드리븐 테이블
CREATE TABLE 비상연락망 (
	id   int PRIMARY KEY,
	학번 int FK,
	관계 varchar(10)
	연락처 varchar(12),
	foregin key 학번 reference 학생(학번);
)
```

다음의 조인 쿼리문을 BKA 조인으로 처리한다고 해보자.
```sql
-- 학번 1부터 100번의 학생 별 비상연락망을 모두 반환해주세요.
SELECT 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
FROM 학생
JOIN 비상 연락망
ON 학생.학번 = 비상연락망.학번
WHERE 학생.학번 IN (1,100)

```

### (1) 드라이빙 테이블 스캔 후 조인 버퍼에 적재
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716163128.png)

1. InnoDB의 `cursor`가 조건에 만족하는 행을 차례로 읽는다.
2. 각 행에서 "쿼리에 필요한 컬럼"만 뽑아서 조인 버퍼에 채운다. 
   (NULL 값은 추가 바이트 미할당, VARCHAR은 필요한 최소 길이만 버퍼에 적재) 
3. 조인 버퍼가 가득차거나 필요한 행을 다 읽었다면, Key build 단계로 넘어간다. 

### (2) Key Build (랜덤 버퍼 적재 과정) 
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716164909.png)
1. key bulider 함수가 조인 버퍼의 행들을 읽어서 다음과 같은 형식으로 랜덤 버퍼에 저장한다.
   `(조인 키 컬럼 값, 해당 키의 조인 버퍼 상 위치 - offset 혹은 pointer)`
2. 랜덤 버퍼가 다 차거나, 필요한 모든 조인 키 컬럼을 저장했다면 MRR 인터페이스를 호출한다. 

### (3) MRR의 PK값 추출 및 정렬
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716171845.png)

1. 드리븐 테이블 안의  조인 컬럼으로 이루어진 보조 인덱스를 확인한다. 
2. 해당 보조 인덱스로 (조인 컬럼, 조인 버퍼 위치) 쌍을 (드리븐의 PK, 조인 버퍼 위치)쌍으로 변환하여 임시 저장 buffer에 저장한다.
3. 임시 저장 buffer의 내용물들을 PK 기준으로 오름차순 정렬한다. 

(임시 저장 Buffer는 MRR 인터페이스 내부에 있다.) 

> [!warning] 주의점
> 위에서 나오듯이 랜덤 버퍼 내용을 PK 기준으로 변환하고 정렬할 수 있는 보조 인덱스가 따로 필요하다.

### (4) MRR 인터페이스가 드리븐 테이블 순차 접근 후 본 데이터 가져오기
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716172643.png)

MRR 인터페이스가 자신 내부 임시 공간 buffer에 저장된 PK 순서대로 순차 리드를 해서 데이터를 가져온다. 

### (5) Association Reference 매커니즘으로 드리븐 테이블과 조인 버퍼 매칭 
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716172959.png)

`Association Refrence` 매커니즘에 따라 드리븐 테이블에서 유효한 레코드를 찾을 때마다 그것과 연관된 조인 버퍼를 찾아서 바로바로 매칭 후 결과 테이블 만든다. 

전체 과정
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716173803.png)

# 3. BKA 조인의 유불리
## (1) 유리한 상황
- 대용량 데이터 조인 시
- 메모리 적재된 데이터가 적어서, 디스크 I/O 작업이 많이 들 때

## (2) 불리한 상황
- 소규모 데이터 조인 시 ( Nested Loop Join으로 랜덤 접근 매번 하는 비용 > 버퍼 3개 쓰고 정렬하는 비용) 

# 4. 핵심 요약
- BKA 조인이란, 조인버퍼와 MRR 인터페이스를 활용해서 Nested Loop 조인에서 드리븐 테이블로의 여러 번의 랜덤 접근을 한 번에 순차 접근으로 변환해서 읽기를 최적화 하는 전략
- BKA의 과정은 다음과 같다.
	1. 드라이빙 테이블에서 유효한 행 읽어서 쿼리에 필요한 컬럼들만 조인 버퍼에 적재
	2. key builder 함수를 통해 조인 버퍼 내용물을 (조인 컬럼 키, 조인 버퍼 상 위치) 쌍으로 랜덤 버퍼에 적재 
	3. MRR 인터페이스가 랜덤 버퍼를 확인 및 조인 컬럼으로 이루어진 드리븐 테이블의 보조 인덱스를 통해 (조인 컬럼 키, 조인 버퍼 상 위치) -> (드리븐 PK, 조인 버퍼 상 위치) 로 만들고 PK 기준 오름차순 정렬
	4. 드리븐 테이블을 PK 순으로 순차 read
	5. 유효한 행 나올 때마다 그것과 연관된 조인 버퍼와 매칭 후 결과 레코드 만들기

- BKA 방식은 대용량 데이터 조인, 디스크 기반 워크로드에서는 탁월한 성능을 보이나, 소규모 read에서는 오히려 NL 조인이 더 빠를 수 있다.

---

# 부록

### A. 모르는 단어 정리
- `조인 버퍼`
  : 드라이빙 테이블의 행들을 임시로 저장하는 메모리 공간
- `MRR 인터페이스`
  : Random I/O를 Sequence I/O로 변환하는 스토리지 엔진 API
- `배치 처리`
  : 한 번에 모아서 처리하는 방식
- `InnoDB cursor`
  : InnoDB 스토리지 엔진 내부에서 B-Tree를 탐색하거나 특정 위치에 멈춰서 다음 레코드를 읽어 오기 위해 만들어진 구조체
  ( `DECLARE … CURSOR` 로 만드는 프로시저용 커서와 아예 다른 것임. )

###  B. 참고 문서

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
