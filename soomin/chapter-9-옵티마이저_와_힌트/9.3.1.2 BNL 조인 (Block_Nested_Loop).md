---
tags:
  - 데이터베이스
  - cs
parent: "[[조인 (Join) 이란]]"
related:
  - "[[NL 조인 (Nested_Loop)]]"
created: 2025-07-16
---

# 0. 학습 목적
- BNL 조인의 동작 과정에 대해 이해한다.
- BNL 조인이 왜 해시 조인이나 머지 소트 조인에 의해 밀려났는지 이해한다.
- BNL 조인과 BKA 조인의 차이점에 대해 이해한다.

# 1. BNL 조인이란? 
조인 버퍼를 활용하여 드리븐 테이블 스캔 횟수를 줄이는 조인 방식.
드라이빙 테이블의 유효한 레코드 하나 당, 드리븐 테이블 전체를 스캔해야 하는 NL 조인의 잦은 스캔 횟수를 줄이고자 나온 방식이다.

# 2. BNL 조인의 동작 과정
1. 드라이빙 테이블에서 유효한 레코드를 발견하면, '조인에 필요한 컬럼만' 조인 버퍼에 저장
2. 조인 버퍼가 가득차거나, 드라이빙 테이블 읽기가 끝나면 다음 과정을 진행
	- 드리븐 테이블의 레코드를 순회하며 유효한 레코드를 만났을 경우, 조인 버퍼를 전체 순회한다.
	- 현재의 드리븐 레코드와 매칭되는 조인 버퍼 속 튜플을 발견한 경우, 둘을 매칭하여 결과 레코드로 내보낸다.
3. 드라이빙 테이블을 전체 다 읽을 때까지 1번과 2번 과정을 반복한다.

> [!info] 비고
> 드라이빙 테이블이나 드리븐 테이블 조회 시, 인덱스를 활용하는 게 성능 상 이득일 경우 인덱스를 활용한다. (ex- 드라이빙 테이블의 Where나 ON에 필터링 조건이 있는 경우, 드리븐 테이블에도 필터링 조건이 있는 경우)

이제 과정 하나하나 자세히 알아보자. 
이를 위해 다음과 같은 테이블, 쿼리 예시를 들겠다.
```sql
-- 드라이빙 테이블
CREATE TABLE 학생 (
	학번 int PRIMARY KEY,
	이름 varchar(10),
	주소 varchar(30)
) engine = 'innodb'

-- 드리븐 테이블
CREATE TABLE 비상연락망 (
	id   int PRIMARY KEY,
	학번 int FK,
	관계 varchar(10)
	연락처 varchar(12),
)
```

다음의 조인 쿼리문을 BNL 조인으로 처리한다고 해보자.
```sql
-- 학번 1부터 100번의 학생 별 비상연락망을 모두 반환해주세요.
SELECT 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
FROM 학생
JOIN 비상 연락망
ON 학생.학번 = 비상연락망.학번
WHERE 학생.학번 IN (1,100)
```

### (1) 드라이빙 테이블에서 유효한 레코드들을 조인 버퍼에 올리기
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250717131646.png)

1. 유효한 레코드를 찾으면 '쿼리에 필요한 컬럼들'만 뽑아서 조인 버퍼에 저장한다. 

> [!info] '쿼리에 필요한 컬럼들' 이란?
> 쿼리 결과 출력에 필요한 컬럼
> 조인에 쓰이는 조인 컬럼 
> 후속 조인 단계에서 필요로 하는 컬럼
> 
> 즉 `select * from A join B`를 하면, A의 모든 컬럼이 조인 버퍼에 적재된다. 이는 조인 버퍼가 빨리 가득차기에 성능 저하에 원인이 된다. 따라서 결과 출력 컬럼은 꼭 필요한 컬럼만 골라서 쓰는 것이 권장된다. 

### (2) 드리븐 테이블 순회 및 조인 버퍼와 비교
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250717133647.png)

드리븐 테이블을 순회하면서, 유효한 레코드를 발견했다면, 해당 드리븐 테이블 레코드와 조인 버퍼의 튜플전체를 일괄 비교해본다. 

![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250717133718.png)
이후 조인 버퍼의 튜플과 드리븐 테이블 레코드가 매칭이 된다면 결과 테이블 레코드로 만들어서 반환한다.

### (3) 전체 과정 아키텍처
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250717133406.png)

- 전체 과정으로 봤을 때, NL 조인과 차이가 나는 BNL 조인만의 특징은 다음과 같다.
	1. 조인 버퍼를 사용한다.
	2. 조인의 순서가 뒤바뀌었다. 
	   (NL 조인은 드라이빙 테이블의 레코드 하나가 드리븐 테이블 전체를 순회, 
	   BNL 조인은 드리븐 테이블의 레코드 하나가 조인 버퍼 전체를 순회) 

# 3. BNL 조인과 BKA 조인의 차이점은? 

> 먼저 BKA 조인이 뭔지 까먹으신 분은 [[BKA 조인 (Batch-Key-Access)]] 의 동작 과정을 읽고 오자.

다음 부분에서 두 조인 방식은 차이를 보인다.
1. 조인의 순서
2. 인덱스 필수 여부
3. 버퍼 한 번 당 연산 횟수 

### (1) 조인의 순서
BNL 조인은 드리븐 테이블의 레코드를 기준으로 드라이빙 테이블의 유효한 레코드들을 비교함으로, 조회 순서가 일반적인 조인 알고리즘들과 반대이다.
반면 BKA 조인은 드라이빙 테이블의 레코드의 튜플을 기준으로 드리븐 테이블의 값을 탐색함으로 죄호 순서가 일반적인 조인 알고리즘들과 같다.

### (2) 인덱스 필수 여부 
BNL 조인 자체가 드리븐 테이블에 적절한 인덱스가 없어, driven table full scan이 너무 많이 일어나는 것을 방지하기 위한 조인 전략임으로, 드리븐 테이블 자체에 인덱스가 필요 없다.

반면 BKA 조인은 MRR(Multi Range Read) 방식을 활용한다. 따라서 **버퍼에 저장된 드라이빙 테이블 튜퓰들의 정렬을 위해 드리븐 테이블에 조인 컬럼을 기준으로 하는 보조 인덱스가 필수적으로 존재해야 한다.**

> 단, 조인 컬럼이 드리븐 테이블의 PK인 경우, 따로 보조 인덱스 필요 없다. 

## (3) 버퍼 한 번 당 연산 횟수
이 특징은 <u>(1)번과 (2)번 특징의 파급효과</u>이다. 

BNL 조인은 드리븐 테이블 기준으로 조인 버퍼 값들을 비교하기 때문에, 드리븐 테이블에서 유효한 레코드를 찾을 때마다 조인 버퍼를 전체 순회해야 한다. 따라서 조인 버퍼가 가득찰 때마다 드리븐 테이블 순차 스캔을 한 번 하는 건 맞지만 내부 연산이 추가로 더 필요하다.

반면 BKA 조인은 랜덤 버퍼의 값들을 MRR 인터페이스가 *드리븐 테이블의 PK를 기준으로 전체 정렬* 시키기 때문에, 정렬된 버퍼 한 번당 순차 스캔이 딱 한 번만 필요하다.

# 4. BNL 조인이 Hash Join으로 대체된 이유는?

> MySQL 8.0.20 버전부터는 BNL은 더 이상 사용되지 않고 BNL 조인 방식은 Hash-Join으로 대체되었다. 

**대부분의 조인 시나리오에서, Hash-Join이 BNL보다 I/O 횟수가 절반 이하로 낮으며, 성능은 훨씬 빠르기 때문이다. 해당 특징은 테이블의 크기가 클수록 도드라진다.**

## (1) I/O 비용 비교
드라이빙 테이블 R의 페이지 수를 $P_R$, 드리븐 테이블 S의 페이지 수를 $P_S$, 가용 버퍼 페이지 수를 $B$라고 했을 때, BNL의 I/O 비용은 다음과 같다.

$$
 P_R + \left\lceil \frac{P_R}{B} \right\rceil \times P_S  
$$

(드라이빙 테이블 읽기 + 버퍼 페이지 한 번 당 드리븐 테이블 순차 읽기)

반면 Hash-Join의 경우

$$
 P_R + P_S 
$$

(작은 쪽 테이블을 메모리 해시 테이블로 빌드, 드리븐 테이블 딱 한 번 순차 스캔) 

## (2) 성능 비교
### A. 등치 조인의 경우
해시 조인의 평균 O(1) 해시 테이블 조회로 매칭을 수행하므로 랜덤 I/O에 따른 오버헤드가 적다. 따라서 BNL 대비 내부 비교 연산과 디스크 엑세스 횟수가 크게 줄어들어 조인에서 우월한 성능을 보인다.

### B. 비등치 조인 (<, > , 복합 조건)의 경우

> MySQL 8.0.20 이후 버전 부터는 Hash Join 최적화가 일어나서, 비등치 조인에서도 Hash Join을 활용이 가능해졌다. 옵티마이저 또한 비등치 조인에서 Hash-Join을 활용할 수 있다.

해시 조인을 비등치 조인에서 사용한다면 다음과 같은 과정으로 이루어진다.
1. 작은 쪽 테이블로 해시 테이블 구축
2. 큰 테이블을 한 번 순차 스캔하며 나올 수 있는 모든 등치 조인 결과를 만들기 
3. 비등치 조인 조건 (범위 조건 혹은 복합 조건)으로 필터링 

> 공식문서 상, 비등치 조인에서 해시 조인과 BNL 조인의 성능 비교는 하지 않았으나, 옵티마이저가 위의 과정으로 이루어지는 Hash-Join을 활용한 비등치 조인 최적화 방안을 설명하는 것으로 보아, 대다수의 환경에서 Hash-Join의 성능이 우세하다고 판단한 것 같다.

# 핵심 요약
1. `BNL 조인`은 조인 버퍼를 활용하여 드리븐 테이블의 레코드가 역으로 조인 버퍼 내 유효한 드라이빙 레코드를 순회하여, 드리븐 테이블 순차 스캔 횟수를 줄이는 NL 조인을 개선한 조인 방식이다.
2. `BNL 조인의 동작 과정`은 다음과 같다.
	1. 조인 버퍼에 유효한 레코드 후보군을 '결과에 필요한 컬럼만 떼어내서' 적재한다.
	2. 조인 버퍼가 가득차면, 드리븐 테이블을 순회하며 다음 과정을 진행한다.
		- 드리븐 테이블의 유효한 레코드 발견 시, 조인 버퍼 순회
		- 조인 버퍼에서 매칭되는 쌍를 만나면 결합하여 결과 레코드로 만들어서 송신 버퍼로 보내기
3. `BNL과 BKA의 차이점`은
	1. BNL은 순서가 드리븐 -> 조인 버퍼 순이지만, BKA는  정렬된 버퍼 -> 드리븐 순으로 진행된다.
	2. BNL은 드리븐에 인덱스가 필요 없지만, BKA는 내부적으로 MRR 방식을 쓰기 때문에 버퍼의 튜플들을 정렬한 적절한 인덱스가 드리븐 테이블에 필요하다.
	3. BNL는 한 번의 순차 스캔 당 내부에 조인 버퍼 순회 연산이 N번 더 들지만, BKA는 버퍼 한 번 당 순차 스캔 한 번이다.
4. `MySQL 8.0.20` 부터는 BNL이 Hash Join으로 완벽 대체 되었다. 이유는 다음과 같다.
	- I/O 연산 횟수에서 Hash Join이 월등히 빠르다.
	- 8.0.20 버전부터는 Hash Join 최적화가 일어나서 비등치 조인도 Hash Join 활용이 가능해졌다.

---

# 부록

### A. 모르는 단어 정리 
- `카테시안 곱 (카테시안 조인, 크로스 조인)`
  : 두 테이블의 모든 행을 서로 한 번씩 조합하여 결과를 만든느 조인

###  B. 참고 문서
- real-my-sql  9.3.1.2 블록 네스티드 루프 조인 (320p - 323p) 
- [위키피디아 - BNL 조인](https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D_%EC%A4%91%EC%B2%A9_%EB%A3%A8%ED%94%84)
- [Hoing 블로그 - 공식 문서 BNL and BKA에 대한 설명](https://hoing.io/archives/24491#4_Batched_Key_Access_Joins)
- [BNL, Hash Join 시간복잡도 계산](https://pages.cs.wisc.edu/~paris/cs564-s18/lectures/lecture-18.pdf)
- [MySQl 8.4 공식 문서 - Hash Join Optimization](https://dev.mysql.com/doc/refman/8.4/en/hash-joins.html)

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
