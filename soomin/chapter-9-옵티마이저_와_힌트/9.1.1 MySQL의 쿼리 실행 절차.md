---
tags:
  - 데이터베이스
  - cs
parent: "[[쿼리 최적화]]"
related: 
created: 2025-06-23
---

# 0. 학습 목적
- MySQL의 쿼리 실행 절차를 대략적으로 이해한다.

# 0. 쿼리 실행 절차

1. MySQL 엔진의 `SQL 파서` 가 문자열 형식의 실행문을 서버가 이해할 수 있는 **파서 트리**로 분리 후 재조립 한다.
   
2. MySQL 엔진의 `PreProcessor` 가 파서트리의 의미를 분석해서, 정말 말이 되는지 확인 및 이걸 실행할 권한이 세션에게 있는지 확인한다. 확인이 끝나면 해당 파서트리를 옵티마이저에게 넘긴다.    
   
3. MySQL 엔진의 옵티마이저가 다음 과정을 거쳐 실행계획을 짠다.
	- 쿼리문 자체에서 불필요한 조건, 연산 삭제
	- 테이블의 데이터 분포도, 요구되는 조건, 테이블의 인덱스 정보를 규합하여, 최적의 쿼리문으로 변환
	  
4. 옵티마이저가 짠 실행 계획을 스토리지 엔진에게 넘겨주고, 스토리지 엔진이 계획 절차대로 데이터를 읽어온다.
	
5. 이후 MySQL 엔진이 데이터 후처리 진행 후 사용자에게 넘겨준다.

![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250624131153.png)

> 이제 절차 하나하나씩 세세하게 알아보자

# 1. `문자열 쿼리문`-> `Parser Tree`
SQL 엔진의 SQL 파서가 문자열 형태의 쿼리문을 잘게 쪼개서 Parser Tree로 바꾼다. 
다음 두 과정을 거친다. 

1. 어휘 분석
2. 구문 분석

## (1) 어휘 분석
일련의 문자열인 쿼리문을 구분자에 따라 나누어서 단어의 형태로 만든다. 
이재 단어가 무슨 어휘인지 분석해야 하는데, MySQL은 크게 두 가지로 토큰을 분류한다.

- Special Form (미리 정의된 형태)
	- 예약어 (SELECT, FROM WHERE 등)
	- 연산자 (+,-, * ,/ 등)
	- 구분자( 공백, 따옴표, 괄호)
	  
- General Form (프로그래머 정의 형태) 
	- 식별자 (테이블 명, 컬럼 명)
	- 상수 (숫자, 문자열, 참/거짓) 

즉 예를 들면 다음과 같이 된다.

### A. SQL문 입력
```sql
SELECT * FROM USER;
```

### B. 구분자 별로 나누기
여기서 구분자는 공백과 ';' 를 들 수 있겠다.
문자열에서 구분자를 통해 기계적으로 나눈다.
```java
S-E-L-E-C-T- -n-a-m-e- -F-R-O-M- -u-s-e-r-s
```

### C. 토큰 분류 및 분류에 따른 라벨링
내부 어휘 분석기에 위에서 나눈 덩어리를 하나씩 넣고, 토큰이 어떤 유형인지 확정 후 라벨링한다.

- "SELECT" → 명령어 토큰
- "name" → 컬럼명 토큰
- "FROM" → 키워드 토큰
- "users" → 테이블명 토큰

## (2) 구문 분석
`어휘 분석` 에서 나눈 어휘들은 아직 서로 연결되지 않은 채 각각 독립된 노드 형태로 존재한다. 구문 분석에서는 다음 과정을 거쳐 이들 간의 관계를 연결하고, 완성된 `파서 트리`로 만든다.

### A. 문법 규칙 확인 
토큰을 그냥 나열했을 때, SQL 문법이 맞는지 '기계적으로' 확인한다. 
여기서 *'기계적'* 이란 말을 활용한 이유는 해당 내용이 존재하는지는 확인하지 않고, 그저 맞춰봤을 떄 말이 되면 통과시키기 때문이다. 

즉 
```sql
SELECT FROM name user; -- 1
SELECT name FROM user; -- 2
```

1번의 경우, SELECT 다음에 조회 컬럼 대상이 와야한다는 문법 규칙을 어겼기에, 여기서 더 진행하지 않고 오류를 낸다.
2 번의 경우 `user` 테이블이 DB내에 존재하지 않아도, 문법적으로 맞기 때문에 다음으로 넘어간다. 

### B. 파서 트리 생성
내부적으로 `STACK & REDUCE` 라는 STACK과 buffer를 활용한 알고리즘으로 트리 구조를 만든다.

(예시) 
```bash
    쿼리
     |
  SELECT문
   /    \
컬럼목록  FROM절
  |       |
 name   users

```

# 2. PreProcessor의 파서 트리 점검
- PreProcessor는 해당 파서 트리가 의미적으로 말이 되는지 먼저 확인한다. (진짜 그 테이블이 있는지 등)
- 의미적으로 말이 되면 현 세션에게 해당 작업을 할 권한이 있는지 확인한다.

# 3. 쿼리 최적화 및 실행 계획 수립
MySQL 엔진의 **`옵티마이저`** 가 이번 작업을 도맡아 한다.
SQL 파서에서 파서트리를 보내주면 다음 작업을 거친다.

1. **쿼리문장 최적화**
   :중복되는 혹은 불필요한 조건 제거, 쉽게 풀어낼 수 있는 연산은 단순화 
   
2. **테이블 읽는 순서 정하기**
   : 여러 개의 JOIN으로 이루어져 있을 경우, 테이블을 읽을 순서를 정함

3. **각 테이블마다 어떻게 읽을지 결정**
   : 각 테이블에서 사용되어야 할 조건, 테이블의 데이터 분포도, 인덱스 통계 정보를 종합적으로 고려하여 사용할 인덱스 혹은 full scan 할지 정함.
   
4. **필요한 레코드 읽은 후 추가 가공 작업 필요한지 판단**
   : 정렬 작업이나, 서브 쿼리로 인한 임시테이블 가공 등

위의 과정을 전부 포함하는 실행계획이 만들어진다. 해당 실행계획을 mySQL 엔진이 스토리지엔진에게 전달한다.

# 4. 스토리지 엔진의 계획 수행
실행 계획대로 스토리지 엔진에서 디스크와 소통하며 데이터를 읽어오거나 쓴다. 

# 5. MySQL 엔진의 데이터 가공 수행
추가 가공 작업이 필요할 경우, MySQL 엔진이 스토리지 엔진으로부터 데이터를 받아서 추가 가공 작업을 실행한다.
- 추가 가공 작업의 예시: `ORDER BY`, `GROUP BY`, `임시 테이블 생성`, `조인 결과 합치기` 등 

> [!info] 참고: MySQL엔진과 스토리지 엔진의 관계
> 스토리지 엔진은 데이터를 읽거나 쓰는 '물리적인 역할만' 담당한다. 
> MySQL 엔진이 실행계획 짜고, 데이터 가공 뒤처리 등 그 외의 모든 작업을 담당한다. 
> 
> 삼국지로 예를 들어 MySQL 엔진이 제갈량이고, 스토리지 엔진이 조자룡이다.
> 유비가 오나라에 결혼하러 갔을 때 제갈량이 유비를 지킬 비책 꾀주머니를 3개 준다. 
> 이걸 실행계획이라 생각하면 되겠다.
> 오나라에서 조자룡은 스스로 생각하지 않고, 꾀주머니에 있는 대로만 행동한다.
> (= 실행계획 대로만 물리적인 작업을 한다.)

# 핵심 요약
- 쿼리 실행 절차를 간략하게 설명하면,
	- 먼저 문자열 형태의 쿼리를 `SQL PARSER`가 받아서 어휘 분석, 구문 구석 과정을 거쳐 파서 트리로 만든다.
	- 파서 트리를 옵티마이저가 받아서 다음을 고려하여 실행계획을 짠다.
		- 불필요하거나 중복된 조건 제거, 쉽게 풀어 쓸 수 있는 연산은 단순화
		- 조인이 여러 개 되어 있으면 그 중에서 읽을 테이블 순서를 정한다.
		- 테이블 순서가 정해지면, 그 하나하나에 대해서 어떻게 읽을지 결정한다. (인덱스 쓸지, 풀 스캔 탈지)
		- 데이터를 스토리지 엔진으로부터 다 읽으면, 그 뒤에 데이터 가공이 필요한지 판단한다. 

---

# Metadata

### A. 모르는 단어 정리 

###  B. 참고 문서

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
