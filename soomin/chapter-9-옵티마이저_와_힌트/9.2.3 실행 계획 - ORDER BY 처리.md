# 0. 학습 목적
- 옵티마이저가 정렬 요청을 어떤 방식으로 계획하고 처리하는지 이해한다.

# 0. 개괄
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250703232533.png)

옵티마이저가 정렬에 대한 실행 계획을 짤 때, 고를 수 있는 선택지는 크게 **`인덱스를 이용하는 방법`**, **`File sort를 이용하는 방법`** 으로 크게 나뉜다. 

| 구분 | 인덱스 활용하여 정렬                                         | `filesort`로 정렬                                            |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 방법 | 이미 정렬된 상태인 인덱스의 순서대로 데이터를 읽기           | 데이터를 읽어와서, 메모리의 버퍼 공간을 활용하여 직접 정렬 (quick sort + merge sort) |
| 장점 | 이미 정렬된 상태로 저장되어 있어 조회가 매우 빠름            | 삽입,삭제,변경 시 추가 작업을 요하지 않는다.<br>레코드 건 수가 충분히 작다면, 성능은 인덱스 이용과 비슷해짐. |
| 단점 | 대신 모든 삽입, 삭제, 변경 작업마다 B+Tree에서 값을 수정하는 작업이 추가로 든다.<br>-> 삽입,삭제,변경이 느려진다.<br>-> 디스크와 메모리에 인덱스를 위한 공간이 추가로 더 필요해진다. | 매 쿼리 요청마다 새로 정렬 해야해서, 정렬 작업에 비용이 들고, 성능이 비교적 느리다. |

filesort는 **JOIN 포함 계산 시**에 다시 다음의 2가지로 나뉜다.

- 드라이빙 테이블을 선 정렬 후, 정렬된 상태에서 JOIN 
- JOIN을 먼저 시행하여, 나온 결과값을 임시 테이블에 저장하고, 해당 임시테이블에 대해서 정렬

후자가 전자보다 소트버퍼에 저장해야할 컬럼 값 수가 배로 늘어나게 되므로, 당연히 전자의 속도가 훨씬 빠르다. 이 두가지와 INDEX 활용 방식의 속도 차이, 표시 등을 살펴보면 다음과 같다.

| 구분 | 인덱스를 활용한 정렬   | 드라이빙 테이블 선 정렬 후 조인 | 선 조인, 임시 테이블 후 정렬              |
| ---- | ---------------------- | ------------------------------- | ----------------------------------------- |
| 속도 | 1                      | 2                               | 3                                         |
| 표시 | Extra에 따로 표시 없음 | Extra에 `Using filesort`        | Extra에 `Using temporary; Using filesort` |

# 1. 실행 계획: 인덱스를 활용한 정렬
인덱스 리프노드의 순서 그대로 데이터를 read하기 때문에 따로 추가 정렬 작업을 하지 않는 실행 계획. 
그렇기에 속도도 정렬 실행 계획 중에 가장 빠르지만, 이것을 쓰기 위해선 지켜야할 조건이 많다.

## (1) 필수 조건
1. **ORDER BY에 적힌 컬럼 순서와 똑같은 순서로 생성된 인덱스가 존재해야 한다.**
2. **인덱스가 B-TREE 인덱스여야 한다.**
   (R-TREE가 B-TREE 기반이라도 안된다.)
   
3. **ORDER BY에 명시된 컬럼이 첫 번째 드라이빙 테이블이어야 한다.**
   
4. **WHERE 절에 제일 먼저 읽는 테이블에 대한 조건이 있다면 해당 조건과 ORDER BY가 같은 인덱스를 활용할 수 있어야 한다.**
   
5. **여러 개의 테이블이 조인 되어야 한다면, 조인 실행 계획이 `Nested Loop Join` 이여야 한다.**

> [!info] 부연 설명

1번에 대하여
- 정렬에서의 인덱스 활용은 B-Tree의 정렬된 리프노드의 레코드들을 순차적으로 읽어오는 방식이기 때문에 다른 알고리즘으로 구성된 인덱스는 정렬에 사용할 수 없다.

5번에 대하여
- Nested Loop Join은 계산 과정에서 별도의 임시 저장 공간을 사용하지 않고 B+tree의 정렬된 순서를 그대로 이용한다.
- 반면에 Blocked Nested Loop Join, Batch Key Access Join, Hash Join은 모두 계산 과정이나 혹은 계산 전에 B+Tree를 벗어나 별도의 Buffer에 값을 임시 저장한 뒤 일괄 처리하는 방식이다. 
- 즉 Nested Loop Join 이외의 방법은 B+Tree를 벗어나게 되어서, 인덱스 기반 정렬 방식을 활용하지 못한다.

## (2) 과정
- 실행 계획 상 조인이 없는 경우, 하나의 테이블 B+tree 리프노드의 레코드를 순차 스캔 후 반환
- 실행 계획 상 조인이 있는 경우,
	1. 우선순위 1위 드라이빙 테이블의 인덱스 순서로 정렬된 레코드를 순차 READ
	2. 레코드 별로 드리븐 테이블을 랜덤 접근 후 필요한 데이터 가져오기
	3. 두 레코드를 합쳐서 임시 테이블의 레코드로 저장 후 반환

## (3) 인덱스 활용이 확실하면 ORDER BY 안 써도 되겠네? 
**YES**, 안 써도 된다.

다음의 `employees` 테이블에서 `emp_no` 가 PK라고 해보자.
```sql
select *
from employees e, salaries s
where s.emp_no = e.emp_no
AND e.emp_no Between 100002 AND 100020
ORDER BY e.emp_no
```

해당 쿼리문의 실행 계획이 `employees` 를 최우선 드라이빙 테이블로 본다고 가정 해보자. 
이때, 조건문이 모두 PK인 `emp_no`에 대한 것이라, ORDER BY가 없더라도, employees의 클러스터링 테이블을 활용하여 필터링 할 것이고, 클러스터링 테이블의 순서대로 나올 것이다. 따라서 정렬을 사용하든 말든 상관 없이 같은 결과가 나온다.

**하지만, 다음 2가지 이유 때문에 굳이 ORDER BY를 명시하지 않을 이유가 없다.**

1. **쓰나 안 쓰나 성능적 차이는 없다.**
   : 위에서 살펴봤듯이 인덱스 활용한 정렬로 실행 계획이 확정되면, 실행 계획 상 정렬 연산을 따로 하지 않고, 그냥 B+Tree의 순서 그대로 읽는다.
   따라서 `ORDER BY`를 명시하나 안하나 실제 동작은 차이가 없는 것이다.

2. **안 썼을 경우, 예상치 못한 오류가 날 수 있음**
   : 만약 클라이언트에게 정렬된 순서로 주지 않으면 에러가 나는 API라고 치자. 실행 계획이 살짝 달라져서 인덱스를 활용하지 않는 경우, `ORDER BY`를 쓰지 않는 것이 오히려 에러를 야기하고, API의 안정성을 떨어트린다.

## (4) 인덱스 활용 조건 다 지켜도 정렬에 filesort를 선택하는 경우
다음과 같은 경우에, 인덱스를 활용한 정렬이 오히려 비용과 시간이 많이 들어서 filesort를 사용한다. 

1. 정렬 기준이 너무 많은 경우 
2. 특정 연산 작업을 거친 결과에 대해 정렬 해야 하는 경우
	- `GROUP BY` , `DISTINCT` 활용
	- `UNION` 같이 임시 테이블을 만들어서 거기에 데이터 넣은 경우
3. 레코드에 대한 랜덤 접근하여 결과를 가져와야 하는 경우

> 부연 설명

정렬 기준이 너무 많으면, 정렬 기준마다 인덱스를 활용하여 정렬하는 것보다 filesort 한 번이 더 빠르다.
특정 연산 작업으로 처리한 경우에도 인덱스를 쓸 수 없는데, `GROUP BY`, `DISTINCT` 활용하면, 결과 레코드가 이미 인덱스의 정렬 순서와 다르기 때문에 활용 불가하다. 임시 테이블 생성은 해당 임시 테이블에 인덱스가 없으므로 당연히 활용 불가하다.

# 2. 실행 계획: 선 드라이빙 테이블 정렬 후 조인
조인 후에는 레코드의 크기가 엄청 커지고, 레코드 건 수도 기하급수적으로 불어난다. 따라서 인덱스를 활용한 정렬을 하지 못하는 상황이라면, 드라이빙 테이블을 미리 정렬 후 그에 해당하는 드리븐 테이블 데이터 를 붙이는 것이 차선책이다. 

## (1) 조건
- ORDER BY 의 조건이 첫 번째 드라이빙 테이블의 컬럼을 대상으로만 한다.

## (2) 과정
조건에 해당하면서도 인덱스 활용 정렬이 불가능한 경우 다음의 과정을 거쳐 데이터가 정렬된다.

1. 소트버퍼에 드라이빙 테이블 레코드 올린 후 정렬
2. 정렬된 결과에 대해 조인을 실행하여 결과값 완성

### A. 예시

다음과 같은 쿼리문이 있다고 하자. 이것이 `선 드라이빙 테이블 정렬 후 조인` 을 선택하는 이유를 알아보자.
```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BEWTEEN 100002 AND 100010
ORDER BY e.last_name;
```

#### a. 드라이빙 테이블 고르기
다음의 이유로 `employees`가 드라이빙 테이블이 된다. 

1. WHERE 조건을 보면, employees의 PK를 활용한 범위 필터링 조건이 있다. (Between) 
2. 드리븐 테이블(salary)과 조인하는 컬럼인 `emp_no`에 대해 salaries에서도 인덱스가 걸려있다.

#### b. 정렬 방식 선택
WHERE 절은 첫 번째 드라이빙 테이블인 employees의 PK를 활용하기 때문에 인덱스 활용 정렬의 조건을 만족하지만, **ORDER BY의 대상이 첫 번째 드라이빙 테이블의 PK가 아니기 때문에** 인덱스를 활용한 정렬을 쓸 수 없다.
 하지만, ORDER BY의 조건 전체가 첫 번째 드라이빙 테이블을 대상으로 하기 때문에, `선 드라이빙 테이블 정렬 후 조인` 은 쓸 수 있다. 

따라서 옵티마이저가 `선 드라이빙 테이블 정렬 후 조인`이 실행 계획을 선택한다. 

#### C. 실행 과정 
이제 실행 계획은 다 짰으니, 어떻게 실행될지 과정을 보자.

1. 검색 조건은 employees의 PK 인덱스를 활용하여 데이터 필터링
2. 필터링 된 데이터를 소트버퍼에 올리고 정렬
3. 정렬된 employees 레코드를 순차적으로 읽으면서 salaries와 join 수행 

# 3. 실행계획: 조인 연산 다하고 그 결과를 저장한 임시 테이블을 최종 단계에서 정렬

## (1) 조건
- 조인이 꼭 필요한 쿼리문인데, 1번과 2번 정렬 방법을 쓸 수 없는 모든 상황

## (2) 과정 예시 
```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BEWTEEN 100002 AND 100010
ORDER BY s.salary;
```

해당 쿼리문은 드라이빙 테이블 선 정렬 방식과 같은 이유로 `employees`가 드라이빙 테이블이다. 하지만 ORDER BY의 조건이 드리븐 테이블을 조건으로 하므로 인덱스 활용 정렬, 선 드라이빙 테이블 정렬 모두 못한다. 왜냐하면 정렬 하기 전에 정렬 기준이 결과 레코드 안에 있어야 하는데, 위의 쿼리문은 조인 수행 전까지 결과 레코드에 `salaries.salary`라는 값이 없기 때문이다. 

따라서 다음과 같이 실행 계획이 뜰 것이다.

| id   | table | type  | key     | Extra                                        |
| ---- | ----- | ----- | ------- | -------------------------------------------- |
| 1    | e     | range | PRIMARY | Using Where; Using temporary; Using Filesort |
| 1    | s     | ref   | PRIMARY | null                                         |

`Extra` 항목의 `Using temporary; Using Filesort`는 임시 테이블에 값을 저장하고, 그 내용을 정렬했음을 보여주는 항목이다.

# 핵심 요약
1. 정렬에 대한 실행 계획에는 인덱스를 활용한 정렬, 소트버퍼를 활용한 정렬 두가지 방식으로 나뉜다. 
2. 소트 버퍼를 활용한 정렬은 테이블을 조인해야 하는 경우 다시 나뉘는데, `선 드라이빙 테이블 정렬 후 조인` 과 `전체 조인 연산 후 해당 결과를 저장한 임시 테이블을 정렬`로 나뉜다.
3. `인덱스 활용 정렬`은 조건이 까다롭다. 조건은 다음과 같다.
	1. ORDER BY 조건과 같은 컬럼 순서를 가진 인덱스가 존재해야 한다. 
	2. 1번의 인덱스가 B-Tree여야 한다. ( R-Tree도 안됨.)
	3. 1,2번을 만족하는 인덱스가 첫 번째 드라이빙 테이블의 소속이여야 한다.
	4. Where 조건에 첫 번째 드라이빙 테이블에 대한 조건이 있다면 해당 조건 또한 위 1,2,3번을 만족하는 인덱스만으로 필터링이 가능해야 한다.
	5. 조인 실행 계획이 `Nested Loop Join`이여야 한다. (Buffer를 쓰면 인덱스 활용이 불가)
4. `선 드라이빙 테이블 정렬` 방식은 ORDER BY의 조건이 모두 첫 번째 드라이빙 테이블의 컬럼을 대상으로 해야 한다는 조건이 있다. 
5. `전체 결과 임시 테이블을 정렬`하는 방식은 2 개 이상의 테이블을 조인 하는 방식이면서도, 위의 다른 두 가지 방식으로 정렬할 수 없는 경우 활용하는 방식이다. 예시로는 ORDER BY 조건이 드리븐 테이블의 컬럼을 대상으로 하는 경우를 들 수 있다.

---

# Metadata

### A. 모르는 단어 정리 
- `데이터 웨어하우스`
  : 여러 소스의 데이터를 통합하고 저장하여 분석 및 의사 결정 지원을 위한 시스템 

###  B. 참고 문서
- real-my-sql

### C. 관련 글

