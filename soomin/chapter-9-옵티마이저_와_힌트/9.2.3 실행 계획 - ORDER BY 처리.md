---
tags:
  - 데이터베이스
  - cs
parent: "[[쿼리 최적화]]"
related: 
created: 2025-06-25
---

# 0. 학습 목적
- 옵티마이저가 정렬 요청을 어떤 방식으로 계획하고 처리하는지 이해한다.

# 0. 개괄
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250625174659.png)

옵티마이저가 정렬에 대한 실행 계획을 짤 때, 고를 수 있는 선택지는 크게 **`인덱스를 이용하는 방법`**, **`File sort를 이용하는 방법`** 으로 크게 나뉜다. 

| 구분        | 인덱스 활용하여 정렬                                                                                                       | `filesort`로 정렬                                                                                           |
| --------- | ----------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| 방법        | 이미 정렬된 상태인 인덱스의 순서대로 데이터를 읽기                                                                                      | 데이터를 읽어와서, 메모리의 버퍼 공간을 활용하여 직접 정렬 (quick sort + merge sort)                                              |
| 장점        | 이미 정렬된 상태로 저장되어 있어 조회가 매우 빠름                                                                                      | 삽입,삭제,변경 시 추가 작업을 요하지 않는다.<br>레코드 건 수가 충분히 작다면, 성능은 인덱스 이용가 비슷해짐.                                        |
| 단점        | 대신 모든 삽입, 삭제, 변경 작업마다 B+Tree에서 값을 수정하는 작업이 추가로 든다.<br>-> 삽입,삭제,변경이 느려진다.<br>-> 디스크와 메모리에 인덱스를 위한 공간이 추가로 더 필요해진다. | 매 쿼리 요청마다 새로 정렬 해야해서, 정렬 작업에 비용이 들고, 성능이 비교적 느리다.                                                        |

filesort는 **JOIN 포함 계산 시**에 다시 다음의 2가지로 나뉜다.

- 드라이빙 테이블을 선 정렬 후, 정렬된 상태에서 JOIN 
- JOIN을 먼저 시행하여, 나온 결과값을 임시 테이블에 저장하고, 해당 임시테이블에 대해서 정렬

후자가 전자보다 소트버퍼에 저장해야할 컬럼 값 수가 배로 늘어나게 되므로, 당연히 전자의 속도가 훨씬 빠르다. 이 두가지와 INDEX 활용 방식의 속도 차이, 표시 등을 살펴보면 다음과 같다.

| 구분  | 인덱스를 활용한 정렬     | 드라이빙 테이블 선 정렬 후 조인      | 선 조인, 임시 테이블 후 정렬                        |
| --- | --------------- | ----------------------- | ---------------------------------------- |
| 속도  | 1               | 2                       | 3                                        |
| 표시  | Extra에 따로 표시 없음 | Extra에 `Using filesort` | Extra에 `Using temporary; Using filesort` |

# 1. 실행 계획: 인덱스를 활용한 정렬
인덱스 리프노드의 순서 그대로 데이터를 read하기 때문에 따로 추가 정렬 작업을 하지 않는 실행 계획 
그렇기에 속도도 정렬 실행 계획 중에 가장 빠르지만, 이것을 쓰기 위해선 지켜야할 조건이 많다.

## (1) 인덱스를 활용한 정렬이 되는 필수 조건
1. **인덱스가 B-TREE 인덱스여야 한다.**
   (R-TREE가 B-TREE 기반이라도 안된다.)
   
2. **ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속해야 한다.** 
   (제일 먼저 읽는 테이블 =  우선순위 1위의 드라이빙 테이블)
   
3. **ORDER BY에 적힌 컬럼 순서와 똑같이 생성된 인덱스가 존재해야 한다.**
   
4. **WHERE 절에 제일 먼저 읽는 테이블에 대한 조건이 있다면 해당 조건과 ORDER BY가 같은 인덱스를 활용할 수 있어야 한다.**
   
5. **여러 개의 테이블이 조인 되어야 한다면, 조인 실행 계획이 `Nested Loop Join` 이여야 한다.**

> [!info] 부연 설명

1번에 대하여
- 정렬에서의 인덱스 활용은 B-Tree의 정렬된 리프노드의 레코드들을 순차적으로 읽어오는 방식이기 때문에 다른 알고리즘으로 구성된 인덱스는 정렬에 사용할 수 없다.

5번에 대하여
- Nested Loop Join은 계산 과정에서 별도의 임시 저장 공간을 사용하지 않고 B+tree의 정렬된 순서를 그대로 이용한다.
- 반면에 Blocked Nested Loop Join, Batch Key Access Join, Hash Join은 모두 계산 과정이나 혹은 계산 전에 B+Tree를 벗어나 별도의 Buffer에 값을 임시 저장한 뒤 일괄 처리하는 방식이다. 
- 즉 Nested Loop Join 이외의 방법은 B+Tree를 벗어나게 되어서, 인덱스 기반 정렬 방식을 활용하지 못한다.

## (2) 인덱스 활용 정렬의 과정
- 실행 계획 상 조인이 없는 경우, 하나의 테이블 B+tree 리프노드의 레코드를 순차 스캔 후 반환
- 실행 계획 상 조인이 있는 경우,
	1. 우선순위 1위 드라이빙 테이블의 인덱스 순서로 정렬된 레코드를 순차 READ
	2. 레코드 별로 드리븐 테이블을 랜덤 접근 후 필요한 데이터 가져오기
	3. 두 레코드를 합쳐서 임시 테이블의 레코드로 저장

## (3) 인덱스 활용이 확실하면 ORDER BY 안 써도 되겠네? 
**YES**, 안 써도 된다.

다음의 `employees` 테이블에서 `emp_no` 가 PK라고 해보자.
```sql
select *
from employees e, salaries s
where s.emp_no = e.emp_no
AND e.emp_no Between 100002 AND 100020
ORDER BY e.emp_no
```

해당 쿼리문의 실행 계획이 `employees` 를 최우선 드라이빙 테이블로 본다고 가정 해보자. 
이때, 조건문이 모두 PK인 `emp_no`에 대한 것이라, ORDER BY가 없더라도, employees의 클러스터링 테이블을 활용하여 필터링 할 것이고, 클러스터링 테이블의 순서대로 나올 것이다. 따라서 정렬을 사용하지 않은 것과 같은 결과가 나온다.

**하지만, 다음 2가지 이유 때문에 굳이 ORDER BY를 명시하지 않을 이유가 없다.**

1. **쓰나 안 쓰나 성능적 차이는 없다.**
   : 위에서 살펴봤듯이 인덱스 활용한 정렬로 실행 계획이 확정되면, 실행 계획 상 정렬 연산을 따로 하지 않고, 그냥 B+Tree의 순서 그대로 읽는다.
   따라서 `ORDER BY`를 명시하나 안하나 실제 동작은 차이가 없는 것이다.

2. 안 썼을 경우, 예상치 못한 오류가 날 수 있음
   : 만약 클라이언트에게 정렬된 순서로 주지 않으면 에러가 나는 API라고 치자. 실행 계획이 살짝 달라져서 인덱스 활용을 못하고 정렬이 어긋날 경우, `ORDER BY`를 쓰지 않는 것이 오히려 에러를 야기하고, API의 안정성을 떨어트린다.

## (4) 인덱스 활용 조건 다 지켜도 정렬에 filesort를 선택하는 경우
다음과 같은 경우에, 인덱스를 활용한 정렬이 오히려 비용과 시간이 많이 들어서 filesort를 사용한다. 

1. 정렬 기준이 너무 많은 경우 
2. 특정 연산 작업을 거친 결과에 대해 정렬 해야 하는 경우
	- `GROUP BY` , `DISTINCT` 활용
	- `UNION` 같이 임시 테이블을 만들어서 거기에 데이터 넣은 경우
3. 레코드에 대한 랜덤 접근하여 결과를 가져와야 하는 경우

> 부연 설명

정렬 기준이 너무 많으면, 정렬 기준마다 인덱스를 활용하여 정렬하는 것보다 filesort 한 번이 더 빠르다.
특정 연산 작업으로 처리한 경우에도 인덱스를 쓸 수 없는데, `GROUP BY`, `DISTINCT` 활용하면, 결과 레코드가 이미 인덱스의 정렬 순서와 다르기 때문에 활용 불가하다. 임시 테이블 생성은 해당 임시 테이블에 인덱스가 없으므로 당연히 활용 불가하다.

# 2. 실행 계획: 선 드라이빙 테이블 정렬 후 조인

# 3. 실행계획: 연산 다하고 조인 결과 임시 테이블을 마지막에 정렬

# 핵심 요약

---

# Metadata

### A. 모르는 단어 정리 
- `데이터 웨어하우스`
  : 여러 소스의 데이터를 통합하고 저장하여 분석 및 의사 결정 지원을 위한 시스템 

###  B. 참고 문서

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
