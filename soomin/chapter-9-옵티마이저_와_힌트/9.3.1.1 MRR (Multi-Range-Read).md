---
tags:
  - 데이터베이스
  - cs
parent: "[[고급 최적화]]"
related:
  - "[[B-Tree 인덱스를 통한 데이터 읽기 방식의 종류]]"
  - "[[BKA 조인 (Batch-Key-Access)]]"
created: 2025-07-16
---

# 0. 학습 목적
- MRR 옵션이 무엇인지, 작동 원리가 어떻게 되는지 이해한다.
- MRR과 BKA의 관계를 이해한다.
- BKA의 작동 원리에 대해 이해한다. 

# 1. MRR (Multi-Range-Read) 이란? 
**랜덤 I/O 접근을 순차 I/O 접근으로 변환하여 읽기 속도를 최적화하는 전략**이다. 

# 2. MRR 작동 원리
```sql
-- 테이블 생성
CREATE TABLE employees (
    emp_no INT PRIMARY KEY,
    last_name VARCHAR(50),
    department VARCHAR(50),
    salary INT,
    hire_date DATE,
    INDEX idx_hire_date (hire_date)
)engine='innodb';

-- 실행할 쿼리
SELECT * FROM employees 
WHERE hire_date BETWEEN '2020-01-01' AND '2020-12-31';

```
다음 테이블에 대하여, *'2020년에 고용된 직원들을 모두 구하라.'* 라는 쿼리를 실행해보겠다. 
해당 쿼리는 고용일로 이루어진 보조 인덱스를 사용할 것이다. 

## (1) MRR을 쓰지 않은 읽기
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716140706.png)

1. 세컨더리 인덱스에서 유효한 PK값을 찾는다.
2. 찾는 즉시 본 테이블 (클러스터링 인덱스)에 랜덤 접근하여 PK의 본데이터를 가져온다.
3. 위의 1번과 2번의 과정을 세컨더리 인덱스에서 유효한 PK 값을 발견할 때마다 반복한다.

해당 방식은 보조 인덱스의 튜플 한 건당 랜덤 접근을 매번 진행하기 때문에, 테이블이 크거나, 버퍼풀에 테이블의 데이터가 적재되지 않을 시, 성능 저하의 원인이 된다.

## (2) MRR 방식을 사용한 읽기
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716140920.png)
1. idx_hire_date 보조 인덱스 스캔 시작
	- 조건에 맞는 키들을 버퍼에 수집 
	- 버퍼가 가득차거나, 인덱스 스캔이 끝나면 다음 단계로 이동

![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716141011.png)
2. 버퍼에 있는 인덱스 튜플을 PK로 **정렬** 
	- PK 기준 오름차순 정렬
	- 정렬된 순서로 테이블 접근 계획 수립

![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250716141133.png)
3. 본 테이블에 순차 접근하여 데이터 얻어오기. 

### A. 만약 버퍼 크기보다, 버퍼에 적재해야할 튜플의 양이 더 많다면?
버퍼가 가득찰 때까지 데이터 받아서 정렬 후, 순차 리드를 데이터 처리 끝까지 계속 반복한다. 

# 3. MRR 사용 이점
1. 데이터 접근 최소화 (디스크에서의 페이지 읽기 혹은 버퍼풀에서의 페이지 읽기 접근이 최소화된다.)
2. 순차 접근으로 바뀌기 떄문에 Read-Ahead의 대상이 된다. -> 데이터 처리 속도가 높아짐.

# 4. MRR이 사용되는 시점
1. Secondary Index Range Scan
2. BKA 조인 시
3. 대용량 결과 집합 계산 시

# 5. MRR이 사용되지 않는 시점
1. 커버링 인덱스인 경우
2. 찾는 데이터가 소량인 경우 (즉 버퍼링 정렬 비용 > 랜덤 접근 비용인 경우) 

# 6. MRR 상태 변수
다른 고급 최적화 전략 스위치 옵션과 똑같이 `optimizer_switch` 변수에 같이 있다.

| 설정 이름          | 기본값 | 의미                                        |
| -------------- | --- | ----------------------------------------- |
| mrr            | on  | MRR을 활성화하여, 옵티마이저의 실행 계획 선택지 중 하나로 둘 것인가? |
| mrr_cost_based | on  | 옵티마이저가 mrr을 쓸지 안 쓸지를 비용 기반으로 판단하게 할 것인가?  |

`'mrr_cost_base=on'`이 되면, 옵티마이저가 비용 모델을 토대로 MRR을 사용할지 말지를 결정한다. 하지만 MySQL의 비용모델이 너무 보수적이라 MRR을 사용하는 게 유리한 타이밍에도 MRR을 쓰지 않게 될수도 있다고 한다.
`'mrr_cost_base=off'` 를 하게 되면, MRR이 적용 가능한 모든 경우에 MRR을 즉시 적용하게 된다. 이는 소량 데이터에도 무조건 MRR이 적용되어 오히려 성능 저하를 일으킬 수 있다.

### A. MRR과 BKA의 관계 
MRR은 BKA에 의존하지 않으나, BKA는 MRR에 의존한다. 
위에서 보았듯이 MRR은 BKA 조인말고도 보조 인덱스 레인지 스캔, 동등 조인에도 쓰인다. 하지만 BKA는 MRR 없이 연산을 진행하지 못한다. 따라서 `'BKA=ON, MRR=OFF'` 이면 BKA는 동작하지 않는다.

# 7. 핵심 요약
1. MRR은 데이터 읽기 전략을 랜덤 접근에서 순차 접근으로 전환하여 최적화 시키는 전략이다. 
2. MRR 이전의 조인이나 보조 인덱스 범위 스캔은 드라이빙 테이블(혹은 보조 인덱스)에서 유효한 데이터 레코드를 발견할 때마다 즉시 드리븐 테이블 (혹은 클러스터링 테이블)에 랜덤 접근하여 필요한 데이터를 찾았다. 이는 테이블 용량이 크거나, 메모리에 적재된 데이터가 없을 때, 큰 성능 저하를 일으킨다.
3. 반면 MRR 방식 읽기는 드라이빙 테이블의 유효한 레코드 Set을 버퍼에 저장한 뒤, 조인 컬럼 기준 혹은 PK 기준으로 정렬한다. 이후에는 이를 통해 드리븐 테이블에 순차 접근을 하면 된다.
4. 이를 통해 데이터 읽기를 최소화하고, 순차 읽기가 되어 read-ahead 대상이 되기 때문에 데이터 읽기가 최적화 된다.
5. MRR은 보조 인덱스 레인지 스캔, BKA 조인에서 사용된다. 반면 커버링 인덱스 이거나 데이터량이 작을 때 사용되지 않는다. 

---

# 부록

### A. 모르는 단어 정리 

###  B. 참고 문서
- [MySQL 공식문서 - Multi-Range Read Optimization](https://dev.mysql.com/doc/refman/8.4/en/mrr-optimization.html)

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
