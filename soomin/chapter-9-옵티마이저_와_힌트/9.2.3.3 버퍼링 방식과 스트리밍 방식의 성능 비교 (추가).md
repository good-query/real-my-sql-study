---
tags:
  - 데이터베이스
  - cs
parent: "[[쿼리 결과 데이터를 전송 방법]]"
related: 
created: 2025-07-17
---

> 이번 글은 [스트리밍 방식 vs 버퍼링 방식 성능 비교](https://vladmihalcea.com/how-does-mysql-result-set-streaming-perform-vs-fetching-the-whole-jdbc-resultset-at-once/)를 해석하며 만들었습니다. 잘못된 해석이 존재할 수 있습니다.

# 0. 학습 목적
- java, MySQL 환경에서, 스트리밍 방식과 버퍼링 방식의 성능적 차이는 얼마나 나는지 이해한다.

# 1. JDBC 스트리밍 방식의 제약 사항
JDBC의 데이터 적재 방법의 기본값은 **`fetch-all` (버퍼링 방식)** 이다. 이를 streaming 방식으로 바꾼다면, 다음 3가지 제약 사항이 생긴다.

1. 현재 MySQL로부터 결과 레코드를 받고 있는 `ResultSet` 의 결과를 전부 순회해야지만,  같은 Connection으로 다음 SQL문을 실행할 수 있다.
2. 만약에 `ResultSet`이 읽어야할 레코드를 전부 받은 게 아니라면, SQL문은 닫히지 않는다. 
3. SQL문이 닫히지 않는 한 트랜잭션은 계속 유지되며, SQL문에 전제된 LOCK 또한 트랜잭션이 끝날 때까지 해제되지 않는다. 

### (1) `ResultSet.close()` 나 `Statement.close()` 를 하면?
`close()` 함수를 써서 결과 레코드 저장 객체와 statement 객체를 해제하려고 하여도, 내부적으로 데이터 read를 위해 만들어둔 패킷을 전부 소비할 때까지 해제되지 않는다. 따라서 `close()` 함수를 써도, 내부 JDBC 드라이버가 전제 데이터를 읽을 때 까지 다음 코드 실행이 blocking 된다. 

이러한 제약사항 떄문에 실무에서 스트리밍 방식이 사용되는 순간은 극히 제한된다. 

# 2. 스트리밍 방식이 실무에서 사용되지 않는 이유

## (1) 대용량 데이터를 처리해야 할 경우
database에 존재하는 저장용 프로시저를 써서 데이터를 처리하는 것이 훨씬 성능적으로 우수하다. 

즉 DB에서 저장용 프로시저를 써서 데이터 가공을 끝마친 후 한번의 I/O로 데이터 전체를 주는 것이, 부분 데이터를 조금씩 바로바로 클라이언트 사이드 (여기선 백엔드 서버) 로 보내는 것보다 성능면에서 유리하다는 것이다.

### A. 만약 데이터 가공을 꼭 백엔드 서버에서 해야하는 경우라면? 
이 경우에는 스트리밍 방식보다 **배치 처리 전략**을 쓰는 것이 훨씬 바람직하다. 이유는 다음과 같다. 

1. 배치 처리 시, 배치 단위로 트랜잭션이 분할되기 때문에, 하나의 엄청 긴 트랜잭션을 피할 수 있음.
   (하나의 큰 트랜잭션은 2PL 락이나, MVCC의 트랜잭션 관리에 바람직하지 않은 상황이다.) 
2. 배치 처리 시 트랜잭션이 분할되므로 병렬 처리 및 가공이 가능해진다. 
3. 배치 전략을 사용하면, 페이지네이션 처리가 부가적으로 가능해진다.
   (데이터 크기가 크면 cursor key 기반 페이지네이션 전략, 작으면 offset 기반 페이지네이션 전략 쓰기를 권장) 

## (2) 그래도 스트리밍 방식을 사용해야 하는 경우
DB의 클라이언트 사이드(여기선 백엔드 서버) 에 중대한 메모리 할당 제한이 존재해서, 병렬적 배치 실행을 위한 SQL문 처리를 피해야 하는 경우이다. 

# 3. 성능 비교

## (1) Fetch-all (버퍼링 방식) 의 JDBC 쿼리문
```java
private void stream(EntityManager entityManager) {
    final AtomicLong sum = new AtomicLong();
    try(Stream%3CPost%3E postStream = entityManager
        .createQuery("select p from Post p", Post.class)
        .setMaxResults(resultSetSize)
        .unwrap(Query.class)
        .stream()) {
        postStream.forEach(post -> sum.incrementAndGet());
    }
    assertEquals(resultSetSize, sum.get());
}
```

## (2) 스트리밍 전략을 위한 JDBC 쿼리문
```java
private void stream(EntityManager entityManager) {
    final AtomicLong sum = new AtomicLong();
    try(Stream<Post> postStream = entityManager
        .createQuery("select p from Post p", Post.class)
        .setMaxResults(resultSetSize)
        .setHint(QueryHints.HINT_FETCH_SIZE, Integer.MIN_VALUE)
        .unwrap(Query.class)
        .stream()) {
        postStream.forEach(post -> sum.incrementAndGet());
    }
    assertEquals(resultSetSize, sum.get());
}
```

스트리밍 전략을 위해서는 추가적으로 `org.hibernate.fetchSize`의 Hibernate Query Hint를 써서 DB에서 한 번에 데이터를 가져오는 양인, fetchsize를 얼마나 할건지 정해야한다.
```java
.setHint(QueryHints.HINT_FETCH_SIZE, Integer.MIN_VALUE)
```
정하는 방법에는 2가지가 있다.

- `Integer.MIN_VALUE`: 레코드 단위로 하나씩 가져오겠다는 뜻이다.
- `저 위치에 양수`: 사용자가 원하는 양수 값 만큼 한 번에 가져오겠다는 뜻이다. 이를 위해서는 `userCursorFetc = true`로 바꿔줘야 한다. 

## (3) 성능 측정 결과
성능 측정 전에 각각에 방법 모두 25,000번 매서드 호출을 하여 워밍업을 진행하였다. 

`y축`은 응답시간의 98번째 백분위 수이다. 즉 98%가 해당 응답 시간 이내에 처리되었고, 2%가 응답 시간을 초과하여 처리되었다.
`x축`은 요청한 데이터set의 크기이다 x = 500일 경우, 버퍼링 방식은 한 번에 500개를 보냈을 테고, 스트리밍 방식은 1개의 레코드 씩 누적 500번을 보냈을 것이다. 
![글 게시자의 성능측정 화면 사진](https://vladmihalcea.com/wp-content/uploads/2016/11/mysqlstreaming.png)

요청 처리 결과를 보면, 스트리밍 방식의 성능이 데이터 크기가 커질수록 느려지는 것을 볼 수 있다.

# 핵심 요약
1. JDBC의 스트리밍 방식은 스트리밍 진행 중에 트랜잭션이나 쿼리 실행을 종료할 수 없으므로 타 쿼리문 실행에 영향을 줄 수 있어 안 좋다.
2. 스트리밍 방식은 현대에 와서 대처할 수 있는 것들이 많고, 대체제가 훨씬 성능이 좋다.
3. 스트리밍 방식과 fetch-all 방식을 성능 비교해보았을 때, 스트리밍 방식이 가져와야할 데이터 크기가 커질수록 느려진다.

---

# 부록

### A. 모르는 단어 정리 
- `better off`
  : 더 나은 
- `fetch`
  : 동사 뜻으로 가져오다. 
- `Batch` 처리 전략
  : 큰 데이터 집합을 작은 청크 단위로 분할하여 각각을 별도의 트랜잭션으로 처리하는 방식

###  B. 참고 문서
- [스트리밍 방식 vs 버퍼링 방식 성능 비교](https://vladmihalcea.com/how-does-mysql-result-set-streaming-perform-vs-fetching-the-whole-jdbc-resultset-at-once/)
- [stack-over-flow 질문: streaming에서 result set을 닫는데 너무 오래 걸려요](https://stackoverflow.com/questions/20140178/closing-a-streaming-result-set-using-mysql-jdbc-takes-a-long-time)

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
