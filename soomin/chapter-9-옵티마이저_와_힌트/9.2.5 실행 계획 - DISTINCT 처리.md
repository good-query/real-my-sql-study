---
tags:
  - 데이터베이스
  - cs
parent: "[[쿼리 최적화]]"
related: 
created: 2025-07-04
---

# 0. 학습 목적
- `DISTINCT` 키워드가 미치는 영향력이 달라지는 두 가지 경우를 이해한다.
- 해당 경우마다 쿼리 실행 계획이 어떻게 이루어지는지 이해하여 쿼리 최적화에 도움이 된다. 

# 1. 개괄
`DISTINCT` 키워드는 집계함수 내부에 썼을 때와 그렇지 않을 때 두 가지 경우에서 해당 키워드가 적용되는 범위가 달라진다. 이에 따라 실행 계획도 달라진다.

# 2. `DISTINCT` 키워드를 집계 함수 없이 썼을 때
**`DISTINCT`는 조회 대상이 되는 컬럼 값 모두가 유니크한 튜플을 검색하는 키워드이지, 특정 컬럼이 유니크한 튜플을 찾는 키워드가 아니다.**

```sql
SELECT DISTINCT first_name, last_name
FROM employees
```

위의 SQL문을 '성 (first_name)이 유니크하고, 이름(last_name)은 중복되도 상관 없게  성과 이름 튜플을 조회' 하는 SQL문이라 생각할 수 있겠지만, 실상은 *성과 이름 모두 유니크한 튜플을 조회* 하는 쿼리문이다. 

# 3. `DISTINCT`를 집계 함수 내부에서 썼을 때
**집게 함수 내부에서 쓰면 해당 컬럼 값에 한정하여 `DISTINCT` 가 적용된다.**

```sql
SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
AND e.emp_no BETWEEN 10001 AND 100100; 
```

해당 쿼리문은 `s.salary`에 한정하여 distinct가 적용되고, `s.salary`가 유니크한 값의 개수를 세는 것이다.

## (1) 실행 계획 
### A. 집계함수 내의 `DISTINCT` 대상 컬럼에 대한 인덱스가 없는 경우
1. `DISTINCT` 대상 컬럼이 유니크 인덱스인 임시 테이블을 생성한다. 
2. 해당 임시 테이블은 *'집계함수 내부 `DISTINCT`'* 조합의 개수만큼 생기기에, 한 쿼리에 해당 조합을 많이 실행할수록 쿼리 성능이 느려진다.
3. 이 경우는 임시 테이블을 생성해서 내부적으로 처리함에도 실행 계획에 *'Using Temporary'* 라는 실행계획이 표시되지 않아, 개발자가 놓칠 수 있다.

### B. DISTINCT 대상 컬럼에 인덱스가 있는 경우
임시 테이블 활용 없이 `인덱스 풀 스캔` 이나 `인덱스 레인지 스캔` 으로 쿼리 최적화가 가능하다.

# 4. 핵심 요약
- `DISTINCT` 키워드의 적용 범위는 집계함수 내부에서 썼냐 아니냐에 따라 달라진다.
	- 집계함수 내부에서 쓰지 않았을 경우, (노멀한 사용의 경우) 해당 키워드는 조회하려는 대상 컬럼 전체에 적용된다. 즉 결과는 모든 컬럼이 유니크한 튜플을 조회하는 쿼리문이 된다.
	- 반면 집계함수 내부에서 썼을 경우, 해당 함수 안의 컬럼 한정으로 적용된다.
- 집계함수 내부에서 썼을 경우, 해당 대상 컬럼으로 인덱스가 생성되었는지 아닌지에 따라 성능 차이가 극명하게 갈린다.
	- 인덱스 안 만들었을 경우, 해당 집계함수 + 내부 `DISTINCT` 조합 개수만큼 해당 컬럼이 유니크한 임시테이블이 생성되고, 집계 함수를 계산한다. 이후 최종 결과 Set을 위해 합쳐진다. 따라서 성능이 매우 느리다.
	- 반면 인덱스를 만들었을 경우, 임시 테이블 생성 없이 인덱스 풀 스캔이나 인덱스 레인지 스캔이 적용된다.

---

# Metadata

### A. 모르는 단어 정리 

###  B. 참고 문서

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
