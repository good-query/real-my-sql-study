---
tags:
  - 데이터베이스
  - cs
parent: "[[쿼리 최적화]]"
related: 
created: 2025-07-15
---

# 0. 학습 목적
- 실행계획 최적화 중 고급 최적화란 무엇을 의미하는지 이해한다. 
- 조인 관련 옵티마이저 옵션과 옵티마이저 스위치가 무엇을 뜻하는지 이해한다. 

# 1. 고급 최적화란? 
**옵티마이저 옵션을 이용해 실행 계획을 개발자가 원하는 방향으로 유도하는 행위**

옵티마이저는 최상의 실행 계획을 수립하기 위해, 다음 과정을 거친다.

1. DB 내의 갖가지 통계정보를 종합적으로 참조한다. (인덱스 선택도, 코스트 모델 등) 
2. 옵티마이저 옵션들 

지금까지 살펴본것은 '옵티마이저가 실행 계획을 짤 때, DB 내 통계정보들을 어떻게 활용하는지'에 대한 것 이다. 이제부터 알아볼 것은 2번의 옵티마이저 옵션들을 활용해, 실행계획을 개발자가 원하는 방향으로 유도 되도록 하는 방법이다. 

# 2. 옵티마이저 옵션의 종류
1. 조인 관련 옵티마이저 옵션
2. 옵티마이저 스위치 옵션

## (1) 조인 관련 옵티마이저 옵션
조인의 순서나 방법을 원하는 방향으로 유도하는 옵션
`/*+ */` 이라는 문법 내부에 원하는 조인 관련 옵티마이저 옵션을 적으면, 해당 방향으로 조인의 순서나 방법이 유도된다.

### A. 조인 순서 유도 옵션

| 힌트명              | 설명                                        |
| ---------------- | ----------------------------------------- |
| JOIN_FIXED_ORDER | FROM절의 테이블 순서대로 강제 조인 (STRAIGHT_JOIN과 동일) |
| JOIN_ORDER       | 지정된 테이블 순서로 조인 권고                         |
| JOIN_PREFIX      | 조인 실행 계획의 첫 번째 테이블들 순서 지정                 |
| JOIN_SUFFIX      | 조인 실행 계획의 마지막 테이블들 순서 지정                  |
|                  |                                           |

#### 1. JOIN_FIXED_ORDER
```sql
SELECT /*+ JOIN_FIXED_ORDER() */ *
FROM table1, table2, table3
WHERE table1.id = table2.id
AND table2.id = table3.id;

```
FROM절에 적힌 테이블 순서대로 조인 강제

#### 2. JOIN_ORDER
```sql
SELECT /*+ JOIN_ORDER(table1, table2) */ *
FROM table1, table2, table3
WHERE table1.id = table2.id
AND table2.id = table3.id;

```
특정 테이블 간의 조인 순서 지정 
힌트에 적힌 테이블 간의 우선순위에만 신경 쓰고, 나머지 테이블들은 해당 우선순위만 지킨다면 어디에 오든 상관이 없다. 따라서 해당 힌트문에서 나올 수 있는 테이블간의 조인 순서는 다음과 같다.

- table1 - table2 - table3 (o)
- table1 - table3 - table2 (o)
- table3 - table1 - table2 (0)
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250715233109.png)
[공식 문서 본문 발췌](https://dev.mysql.com/doc/refman/8.4/en/optimizer-hints.html)

#### 3. JOIN_PREFIX
```sql
-- 처음 조인 순서 지정
SELECT /*+ JOIN_PREFIX(table1, table2) */ *
FROM table1, table2, table3, table4;
```
최초 실행될 테이블들을 순서대로 진행한다. 
해당 힌트를 통해 1번 드라이빙 테이블은 table1이 되고, 그 뒤 조인되는 드리븐 테이블은 table2가 된다.

#### 4. JOIN_SUFFIX
```sql
-- 마지막 조인 순서 지정
SELECT /*+ JOIN_SUFFIX(table3, table4) */ *
FROM table1, table2, table3, table4;
```
PREFIX와 반대로 마지막 조인 순서를 지정한다.

### B. 조인 방법 관련 옵션

| 힌트명                                                       | 설명                                   |
| --------------------------------------------------------- | ------------------------------------ |
| BKA, NO_BKA                                               | Batched Key Access 조인 처리 제어          |
| BNL, NO_BNL                                               | Block Nested-Loop 조인 처리 제어           |
| HASH_JOIN, NO_HASH_JOIN                                   | Hash Join 최적화 제어 (MySQL 8.4에서 효과 없음) |
| MERGE, NO_MERGE                                           | 파생 테이블/뷰 병합 제어                       |
| DERIVED_CONDITION_PUSHDOWN, NO_DERIVED_CONDITION_PUSHDOWN | 파생 테이블 조건 푸시다운 최적화 제어                |

사용방법은 조인순서 옵션과 똑같고, 해당 힌트 옆에 (테이블 이름)을 적어서 해당 테이블 조인 시에만 특정 방법을 사용하도록 유도 하는 것이다.

ex ) 
```sql
-- t1 조인 시에만, BKA 활성화
SELECT /*+ BKA(t1) */ t1.*, t2.*
FROM customer t1
INNER JOIN orders t2 ON t1.customer_id = t2.customer_id
WHERE t1.country = 'USA';

-- t1,t2 조인 시 BKA 비활성화
SELECT /*+ NO_BKA(t1, t2) */ t1.*
FROM t1 
INNER JOIN t2 ON t1.id = t2.id
INNER JOIN t3 ON t2.id = t3.id;
```

## (2) 옵티마이저 스위치 옵션
MySQL의 고급 최적화 기능을 활성화할지 여부에 대한 On/Off 옵션이다.
만약 활성화한다면 옵티마이저가 실행계획을 짤 때, 해당 고급 최적화 기능을 선택지에 두고 고려할 수 있다.

### A. 스위치 옵션의 위치
**`optimizer_switch`** 라는 시스템 변수에 모든 최적화 옵션이 함께 저장되어 있다. 

### B. 스위치 옵션의 종류

| 옵티마이저 스위치 이름                            | 기본 값 | 설명                                 |
| --------------------------------------- | ---- | ---------------------------------- |
| **batched_key_access**                  | off  | BKA 조인 알고리즘을 사용할지 여부 설정            |
| **block_nested_loop**                   | on   | Hash Join 처리 제어 (MySQL 8.0.20+ 이후) |
| **engine_condition_pushdown**           | on   | 엔진 조건 푸시다운 최적화 제어                  |
| **index_condition_pushdown**            | on   | 인덱스 조건 푸시다운 최적화 제어                 |
| **use_index_extensions**                | on   | 인덱스 확장 사용 제어                       |
| **index_merge**                         | on   | 모든 인덱스 병합 최적화 제어                   |
| **index_merge_intersection**            | on   | 인덱스 병합 교집합 접근 최적화 제어               |
| **index_merge_sort_union**              | on   | 인덱스 병합 정렬 합집합 접근 최적화 제어            |
| **index_merge_union**                   | on   | 인덱스 병합 합집합 접근 최적화 제어               |
| **mrr**                                 | on   | Multi-Range Read 전략 제어             |
| **mrr_cost_based**                      | on   | 비용 기반 MRR 사용 제어                    |
| **semijoin**                            | on   | 모든 세미조인 전략 제어                      |
| **firstmatch**                          | on   | Semijoin FirstMatch 전략 제어          |
| **loosescan**                           | on   | Semijoin LooseScan 전략 제어           |
| **materialization**                     | on   | 서브쿼리 구체화 제어 (세미조인 구체화 포함)          |
| **subquery_materialization_cost_based** | on   | 비용 기반 서브쿼리 구체화 선택 제어               |

### C. 스위치 옵션을 입맛에 맞게 적용하는 법
#### a. 일괄 적용
```sql
SET GLOBAL optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=default';

SET SESSION optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=default';
```
위와 같이 시스템 변수에 대하여, 적용 범위를 적고, 쉼표 단위로 옵션들을 on/off하여 나열하면 된다. 

- On/off 외에도 default 옵션이 있는데, 이것은 해당 옵션의 기본값을 따라가겠다는 뜻이다. 
- `GLOBAL`로 하면 MySQL 서버 전체에 적용, `SESSION`으로 하면 해당 세션에만 적용

#### b. 특정 쿼리에만 적용
`SET_VAR` 옵티마이저 힌트를 활용하면 옵티마이저 옵션들을 특정 쿼리에만 타겟 적용할 수도 있다.
```sql
SELECT /*+ SET_VAR(optimizer_switch = 'condition_fanout_filter=off') */
...
FROM ...
```

# 3. 핵심 요약
- 옵티마이저는 실행 계획을 수립할 때, DB 내 갖가지 통계정보와 옵티마이저 옵션을 고려하여 수립한다.
  
- 이제까지 알아본 것은 '옵티마이저가 통계정보를 어떻게 인식하고 실행 계획을 수립하는지' 에 대한 것이라면, 이번 장에서는 `옵티마이저 옵션`을 활용해 옵티마이저의 실행 계획이 원하는 방향으로 유도되기 하는 고급 최적화 전략을 학습할 것이다. 
  
- 옵티마이저 옵션에는 크게 <u>(1) 조인 관련된 옵션</u> 과 <u>(2)옵티마이저 스위치 옵션</u> 이 있다.
	1. 조인 관련된 옵션은 옵티마이저에게 조인의 순서와 방법을 알려주어서 원하는 방향으로 유도하는 옵션이다.
	2. 옵티마이저 스위치 옵션은 쿼리 수행과 관련된 최적화 기법을 활성화할지 말지를 정하는 옵션이다. 이를 통해 옵티마이저는 실행 계획을 짤 때, 해당 고급 최적화 기법도 선택지에 두고 고려할 수 있게 된다.

- 옵티마이저 스위치 옵션은 `optimizer_switch` 라는 시스템 변수에 모두 묶여서 관리된다.
- `SET GLOBAL`, `SET SESSION` `SET_VAR` 등으로 해당 옵션의 적용 범위를 설정할 수 있다.

---

# 부록

### A. 모르는 단어 정리 
- `ENGINE CONDITION PUSHDOWN 기능`
  : (**NDB (Network DB) 엔진 한정 기능**)
  컬럼과 상수 간의 직접 비교 조건을 스토리지 엔진(NDB 데이터 노드)에서 미리 평가하여, 조건에 맞지 않는 행이 MySQL 서버로 전송되는 것을 방지함으로써 네트워크 트래픽을 줄이고 쿼리 실행 시간을 단축시키는 기능
  
- `INDEX CONDITION PUSHDOWN 기능`
  : WHERE 절 조건 중 인덱스 컬럼을 이용하여 연산할 수 있는 조건의 경우, 스토리지 엔진이 직접 연산 하도록 책임을 옮기는 기능  (원래 스토리지 엔진이 인덱스 기반 범위 탐색만 가능하던 것에서, 해당 인덱스로 할 수 있는 모든 조건 연산도 같이 진행)
  
- `MySQL에서 PUSH DOWN이란?`
  : 'PUSH DOWN'은 '아래로 내리기' 라는 뜻으로, **컴퓨터 과학에서 처리 책임을 상위 레이어에서 하위 레이어로 옮기는 행위**를 말한다. MySQL에서는 상위 레이어인 MySQL이 담담하던 연산 중 일부를 하위 레이어인 스토리지 엔진에게 전가하는 것이다. 
  
- `Index Extension`
  : 보조인덱스를 만들 때, 논리적으로 PK 또한 인덱스 키 컬럼에 포함되도록 보조 인덱스를 확장하는 기능을 말한다. 
```sql
CREATE TABLE t1 (
    i1 INT NOT NULL DEFAULT 0,
    i2 INT NOT NULL DEFAULT 0,
    d DATE DEFAULT NULL,
    PRIMARY KEY (i1, i2),
    INDEX k_d (d)
) ENGINE = InnoDB;

```
위와 같이 테이블을 생성한다고 쳤을 떄, PK는 (i1,i2) 복합키이고, 보조 인덱스는 d 컬럼 하나만이 키 컬럼이다. 하지만 `use_index_extension = ON` 되어 있다면, 보조 인덱스의 물리적 구조는 같지만, 옵티마이저가 인식할 때, (d, i1, i2) 복합 컬럼처럼 다뤄진다. 장점은 다음과 같다.
	- 더 정확한 쿼리 실행 계획 수립 가능
	- 커버링 인덱스 가능
	  
- `Index Merge`
  : 단일 테이블에서 여러 개의 인덱스를 동시에 사용하여 검색 결과를 병합하는 최적화 기법 
  `index_merge = off` 가 되어 있으면, 하나의 테이블에서 오직 하나의 인덱스만 활용하여 필터링 및 범위 탐색을 하려고 한다. 하지만, `index_merge = on`이 되어 있다면 다음과 같이 움직인다.
	1. 하나의 테이블에서 여러 보조 인덱스 동시에 스캔
	2. 각 보조 인덱스에서 유효한 PK 모두 추출
	3. PK 병합 (교집합, 합집합, 정렬 후 합집합 등) 
	4. 3번의 과정을 거치고 최종적으로 유효한 PK들에 대해서만 본 테이블 접근 후 데이터 Read
   
   그 뒤에 나오는 옵션들, `index_merge_intersection`, `index_merge_sort_union`, `index_merge_union` 등은 3번에서 쓰이는 알고리즘으로 해당 알고리즘을 쓸지 말지를 제어하는 것이다. 

| 옵션                           | 기본값 | 의미                   | EXPLAIN 표시            |
| ---------------------------- | --- | -------------------- | --------------------- |
| **index_merge**              | on  | 전체 Index Merge 기능 제어 | `type: index_merge`   |
| **index_merge_intersection** | on  | 교집합 알고리즘 제어          | `Using intersect(…)`  |
| **index_merge_union**        | on  | 합집합 알고리즘 제어          | `Using union(…)`      |
| **index_merge_sort_union**   | on  | 정렬 후 합집합 알고리즘 제어     | `Using sort_union(…)` |
- **`MRR`**
  : 랜덤 I/O를 순차 I/O로 변환하는 최적화 기법
  
###  B. 참고 문서
- [MySQL 공식 문서 - 옵티마이저 힌트](https://dev.mysql.com/doc/refman/8.4/en/optimizer-hints.html)
- [MySQL 공식 문서 - 인덱스 힌트](https://dev.mysql.com/doc/refman/8.4/en/index-hints.html)
- [MySQl 공식 문서 - Engine-condition-pushdown](https://dev.mysql.com/doc/refman/8.4/en/engine-condition-pushdown-optimization.html)
- [index condition pushdown](https://devlog-wjdrbs96.tistory.com/447)
- [MySQL document 10.3.10 Use Of Index Extension](https://dev.mysql.com/doc/refman/8.4/en/index-extensions.html)

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
