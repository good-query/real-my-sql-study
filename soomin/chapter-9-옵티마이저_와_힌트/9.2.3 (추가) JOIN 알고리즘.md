---
tags:
  - 데이터베이스
  - cs
parent: "[[조인 (Join)]]"
related:
  - "[[두 테이블에서 조인하는데, 각 테이블에서 전체 약 15% 정도만 사용 예정, 이럴 때, 어떤 알고리즘을 선택하시겠습니까]]"
created: 2025-06-01
---

# 0. 학습 목적

- JOIN의 내부 구현에 대해서 이해하고, 적절한 알고리즘 활용을 유도해서 쿼리 튜닝을 더 잘하게 된다.

# 0.5 사전 세팅

## (1) 테이블

![](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250601145924.png)

다음과 같이 변수를 상정한다.

- **M**: 학생 테이블의 페이지 수
- **N**: 비상연락망 테이블의 페이지 수
- **m**: 학생 테이블 전체 레코드 수
- **n**: 비상연락망 테이블의 전체 레코드 수
- k: 학생 테이블에서 필터링 걸러진 레코드 건 수

## (2) 우리가 진행할 쿼리

> 학번이 1과 100인 학생의 비상연락망을 모두 조회하세요!

```sql
SELECT 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
FROM 학생
JOIN 비상 연락망
ON 학생.학번 = 비상연락망.학번
WHERE 학생.학번 IN (1,100)

```

보면 알 수 있듯이 `Driving Table`: 학생, `Diven Table`: 비상연락망 이다.

# 1. NESTED LOOP JOIN (이하 NL Join)

- 이중 반복문 형태로 되어있는 JOIN 알고리즘
- Driving 테이블이 외부 루프, Driven 테이블이 내부 루프임.
- 학생 테이블에서 학번이 인덱스가 아닌 상황을 가정한다. 따라서 외부 루프에서는 Where 절 필터링을 위해 모든 레코드를 조회하는 것이다.

## (1) SIMPLE NLJ

(Driven 테이블에 Join KEY로 인덱스화 되어 있지 않은 경우)

![](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250601162840.png)

**시간 복잡도: $O(M + k \times N)$**

- Driving 테이블의 전체 페이지를 전부 확인해서 필터링
- 필터링된 레코드 하나 하나마다 Drvien 테이블 전체 페이지 조회가 필요함.

## (2) Indexed NLJ

Driven 테이블이 JOIN KEY로 인덱스화 되어 있는 경우 여기서는 JOIN KEY인 학번이 비상연락망 테이블에 INDEX화 되어 있음.

![](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250601163405.png)

**시간복잡도: $O(M + k * C)$**

- Driving 테이블에서 전체 페이지 조회해서 학생 필터링
- C는 학번 별로 비상연락망 테이블을 랜덤 접근하여 실제 데이터를 얻는데 걸리는 시간에 대한 지칭이다. (비상연락망 테이블 랜덤 접근 ($logN$) + 클러스터형 인덱스 가는 비용 별도로 더 산정)

## (3) Drving 테이블에도 필터링 컬럼에 대해 인덱스화되어 있는 경우

![](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250601170314.png)

JoinKey로 인덱스 안되어 있으면 전체 조회 후, 필터링 조건에 맞는 값이 나올 때마다 비상 연락망 확인함.

![](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250601170630.png)

하지만 학번으로 인덱스가 잡혀 있다면, 1번과 100번에 대해서 단건 조회 하여 값을 바로 찾고 비상연락망을 확인

**외부 테이블 조회의 시간 복잡도: $O(M)$에서 $O(C)$ 로 변경** (C = M개의 페이지에 대해 인덱스 활용 검색으로 원하는 값을 찾는데 걸리는 시간 = ($k \times logM + @$)

)

# 2. 블록 중첩 루프 조인 (BNL Join)

![](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250601171541.png)

**시간 복잡도: $O(M + R \times N )$** (R은 조인버퍼에 들어있는 Driving 테이블의 레코드 수)

- Driving 테이블에서 조건에 적합한 값들의 전체 혹은 일부를 조인 버퍼에 넣어둔다.
- 이후 비상연락망 테이블을 딱 한번만 순차 탐색한다. 다음 규칙을 지킨다.
	- 하나의 레코드를 확인할 때, 조인 버퍼에 있는 Driving 테이블의 레코드를 순회하며, JOIN 조건에 맞는 값이 있는지 확인한다.
	- 있으면 조인, 없으면 지나간다.

### A. 장점

- SIMPLE NLJ에서는 매 Driving Table의 레코드마다 Drvien 테이블 전체에 대한 조회가 필요했으나, 이번 BNLJ는 Driven 테이블을 한 번만 전체 탐색하면 모든 JOIN 결과를 반환받을 수 있다.

# 3. 배치 키 엑세스 조인 (BKA join)

![](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250601172908.png)

- Driving 테이블에서 필요한 데이터 필터링 후 Join Buffer에 적재하는 과정까지는 같음.
- 이후 MRR 기능을 활용해, 조인 버퍼에 있는 컬럼을 기반으로 Driven 테이블에서 필요할 거라 예상되는 데이터들을 전부 읽어서 랜덤 버퍼에 저장
- 이제 조인 버퍼와 랜덤버퍼에 있는 내용을 비교하며, 관련된 것을 JOIN만 하면 된다.

# 핵심 요약

---

# Metadata

### A. 모르는 단어 정리 to Layman's term

###  B. 참고 문서

### C. 자식 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
