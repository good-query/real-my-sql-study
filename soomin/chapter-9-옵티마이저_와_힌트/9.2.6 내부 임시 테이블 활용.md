---
tags:
  - 데이터베이스
  - cs
parent: "[[쿼리 최적화]]"
related:
  - "[[실행 계획 - 데이터 읽기]]"
  - "[[실행 계획 - DISTINCT 처리]]"
  - "[[실행 계획 - GROUP BY 처리]]"
  - "[[실행 계획 - ORDER BY 처리]]"
created: 2025-07-11
---

# 0. 학습 목적
1. 사용자가 생성한 임시테이블과 실행 계획상 임시테이블의 차이를 이해한다.
2. 임시 테이블은 어떤 스토리지 엔진을 활용해서 생기는지 이해한다.
3. 임시 테이블은 어디에 저장되는지, 무엇을 기준으로 그 위치가 나뉘는지 이해한다.
4. 임시 테이블이 필요한 쿼리에는 어떤 것들이 있는지 이해한다. 

# 1. 사용자 생성 임시 테이블과 내부 임시테이블의 차이

| 구분    | 사용자가 생성한 임시 테이블                              | 쿼리 실행을 위해 내부적으로 생성된 임시테이블                |
| ----- | -------------------------------------------- | ---------------------------------------- |
| 정의    | 사용자가 `CREATE TEMPORARY TABLE`을 통해 생성한 임시 테이블 | 옵티마이저가 특정 쿼리문 실행을 위해 내부적 생성을 지시한 임시 테이블  |
| 접근 여부 | 다른 세션이나, 쿼리문이 접근 가능                          | 쿼리 실행 종료 후 즉시 삭제되므로, 다른 세션이나 쿼리문이 접근 불가능 |

# 2. 임시 테이블의 엔진, 저장 위치

## (1) 사용 엔진의 변천사
**MySQL 8.0 이전 버전에서는** 메모리에 저장되는 임시 테이블은 `MEMORY` 엔진을 활용하여 생성되었고, 디스크에 저장되는 임시 테이블은 **`MyISAM`** 을 활용하여 생성되었다.

하지만 **MySQL 8.0 버전부터는** 메모리에 저장되는 임시테이블은 `TempTable` 이라는 특수한 엔진을 활용하여 생성되고, 디스크에 저장될 때는 사용자의 설정에 따라 MMAP 파일 혹은 InnoDB 형태로 저장된다. 

## (2) 엔진 변경의 이유
**`결론` :  `Memory` 엔진 = 가변 길이 허용이 안됨, `MyISAM`엔진 트랜잭션 지원을 안함**

먼저 메모리에 저장될 때 사용하는 Memory 엔진의 경우, `VARBINARY`나 `VAR CHAR` 와 같은 가변 길이 타입이 지원되지 않는다. 따라서 임시 테이블 생성 시 이러한 가변 길이 칼럼을 저장해야할 경우, 무조건 해당 컬럼에 최대 길이를 할당했다. 이는 심각한 메모리 낭비로 이어졌다.

두번째로 디스크에 저장될 때 사용하는 MyISAM은 트랜잭션 지원이 안된다. 따라서 트랜잭션 처리가 필요할 경우 곤욕을 치뤘다. 

## (3) 저장 위치 선택 기준
후술할 임시 테이블이 디스크에 바로 생성되는 경우를 제외하고는, 기본적으로 임시테이블은 메모리에 저장된다. 임시테이블 데이터가 **특정 임게치**를 넘어가면 메모리에서 디스크로 넘어간다.

이 특정 임계치가 바로, `temptable_max_ram`이란 변수로 설정되어 있다. (기본값: 1GB)

## (4) 디스크에 저장되는 방식

### A. 메모리 -> 디스크로 옮겨지는 경우
메모리에 있던 임시 테이블이 디스크로 옮겨져야할 때, 저장하는 방식은 `temptable_use_mmap` 시스템 변수에 의해 결정된다. ( '=ON' 이면 MMAP 파일 형태, '=OFF' 이면 InnoDB 테이블 형태, ON이 기본값)

기본갑은 `MMAP` 파일 형태로 디스크에 저장하는 방식인데, 그 이유는 InnoDB 테이블로 저장할 때보다 이 형식이 오버헤드가 적기 때문이다.

### B. 디스크로 바로 저장되는 경우
밑에 후술할 특수한 경우에 임시 테이블은 메모리에 저장되지 않고, 곧장 디스크에 저장된다. 이 경우 `internal_tmp_disk_storage_engine`이란 시스템 변수에 의해 저장 방식이 결정되고, 이 경우 기본값은 `InnoDB` 테이블 저장 방식이다.

# 3. 임시 테이블 생성이 필요한 쿼리
1. `ORDER BY`와 `GROUP BY`에 명시된 컬럼이 다르다.
2. `ORDER BY`와 `GROUP BY`의 대상 테이블이 조인 순서상 첫 번째 드라이빙 테이블이 아니다.
3. `DISTINCT`가 인덱스 활용을 못하는 경우
4. `UNION` (혹은 UNION DISTINCT) 가 사용된 쿼리
5. 쿼리 실행 계획에 select_type이  `DERIVED` 인 경우

1,2,3번은 인덱스 활용이 안되므로, 임시 테이블을 어쩔 수 없이 써야 하는 상황이다. 4번은 결과 집합의 합집합을 만들어야 하는 쿼리이므로, 임시 테이블을 써야 한다. 5번은 서브 쿼리 실행을 위하여 임시 테이블을 만드라고 지시가 된 상황이다. 

### A. 실행 계획 상 표시
1,2번은 실행계획의 Extra 파트에 `Using Temporary`라고 임시 테이블 활용이 명시되지만, 3,4,5번은 명시되지 않는다. 

### B. 임시 테이블에 인덱스 생성
1 - 4 번은 MySQL 명령어 실행 순서상 먼저 실행되는 명령어의 컬럼에 대해 유니크 인덱스가 생성된다.
- 1,2번 `GROUP BY`의 실행 순서가 `ORDER BY`보다 빠름. GROUP BY의 컬럼에 대한 유니크 인덱스를 생성해서 그루핑 작업을 이어간다.
- 3번은 `DISTINCT`에 명시된 컬럼에 대해 유니크 인덱스가 생성된다.
- 4번은 `UNION` 결과에 대한 모든 컬럼에 대해 유니크 인덱스가 생성된다.

5번은 서브 쿼리 결과 저장을 위한 임시 테이블 생성이기 때문에 따로 유니크 인덱스가 존재하는 임시 테이블은 아니다. (다만 다음 쿼리 실행 속도를 높이기 위해, 파생 테이블에 인덱스 자체는 만들 수 도 있다.)

# 4. 임시 테이블이 디스크에 생성되는 경우

곧장 디스크에 저장되는 경우
- `UNION`이나 `UNION ALL` 컬럼 중 길이가 512 바이트 이상인 크기의 컬럼이 있는 경우
- `GROUP BY`나 `DISTINCT` 컬럼 중 512 바이트 이상인 크기의 컬럼이 있는 경우

메모리에서 디스크로 옮겨지는 경우
- 메모리 임시 테이블의 크기가 시스템 변수로 설정한 특정 임계치를 넘기는 경우

# 5. 임시 테이블 관련 상태 변수
실행 계획의 Extra 부분을 통해 임시 테이블 활용 여부는 알 수 있지만, 임시 테이블의 생성 위치나 생성 횟수는 파악할 수 없다. 이를 파악하기 위해서는 **임시 테이블 관련 상태 변수**를 활용해야 한다.

### A. 특정 쿼리문의 임시 테이블 생성 위치와 횟수 확인법

0. `FLUSH STATUS;` 
1. 임시 테이블 관련 메타 데이터 확인하려는 쿼리문 실행
2. `SHOW SESSION STATUS LIKE 'Created_tmp%';` 

실행 결과는 다음과 같이 뜰 것이다.

| Variable Name           | Value |
| ----------------------- | ----- |
| Created_tmp_disk_tables | 1     |
| Created_tmp_tables      | 1     |

### B. 상태 변수의 의미
- `Created_tmp_tables`: 쿼리 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값
  (임시 테이블 저장 위치에 상관없이 모두 센다.)
- `Created_tmp_disk_tables`: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값

#### 왜 `FLUSH STATUS`를 했을까?
위의 변수들은 세션에서 만든 임시 테이블 개수를 *누적하는* 변수라서 `FLUSH STATUS`를 통해 세션 상태 값 전체를 초기화 해주어야지만, 하나의 쿼리문에서 쓰인 임시 테이블 개수를 정확히 확인할 수 있다.

# 6. 핵심 요약

1. 사용자 생성 임시 테이블과 내부 임시 테이블의 차이는 *다른 세션이나 쿼리문이 해당 임시 테이블에 접근할 수 있는지* 여부이다. 내부 임시 테이블은 그것을 만든 쿼리 실행 이후 자동 삭제되므로, 다른 쿼리나 세션에서 접근이 불가하다.
2. 임시 테이블 사용 엔진은 8.0 이전까지 메모리에서는 `MEMORY 엔진`, 디스크에서는 `MyISAM`을 사용했다. 하지만 Memory 엔진은 가변 길이 표현이 안된다는 점에서 메모리 낭비가 심했고, MyISAM은 트랜잭션을 지원하지 않는다는 치명적인 단점이 있었다. 따라서 8.0 부터는 각각 `TempTable`과 `MMAP 혹은 InnoDB 테이블` 형태 저장으로 바뀌었다.
3. 저장 위치 선택 기준은 특수한 경우를 제외하고는 보통 메모리에 저장된다. 다만 임시 테이블 용량이 특정 임계치를 넘었을 때, 메모리에서 디스크로 넘어간다.
4. 임시 테이블 생성이 필요한 쿼리는 대표적으로 다음 5가지가 있다.
	1. GROUP BY와 ORDER BY의 대상 컬럼이 다른 경우
	2. GROUP BY와 ORDER BY의 대상 컬럼이 같지만, 해당 컬럼들이 조인 순서상 첫 번째 드라이빙 테이블이 아닌 경우
	3. DISTINCT가 인덱스 활용을 못하는 경우
	4. UNION 쓴 쿼리
	5. 실행 계획상 select_type이 DERIVED인 경우 
5. 위의 경우에서 1,2번은 실행 계획 상 Extra 부분에 `Using Temporary`라고 뜨지만, 나머지는 안 뜬다.
6. 위의 경우에서 1-4번은 유니크 인덱스가 있는 임시 테이블을 쓰지만, 5번만은 그렇지 않다. 
7. 디스크에 곧장 생성되는 경우는 SELECT나 ORDER BY, GROUP BY, DISTINCT 대상 컬럼의 크기가 512MB를 넘길 경우이다.

---

# Metadata

### A. 모르는 단어 정리 
- `MMAP`
  : 메모리 맵핑 파일(Memory Mapping File) 의 줄임말이다. 운영 체제에서 파일을 다루는 특별한 방법으로, 디스크에 있는 파일을 메모리에 있는 것처럼 직접 접근할 수 있게 해주는 기술 
  
  작동원리
  1. 가상 메모리 매핑: 디스크에 있는 파일을 프로세스의 가상 메모리 공간에 연결 시킴
  2. 지연 로딩: 파일 전체를 메모리에 올리지 않고, 필요한 부분만 메모리에 부분적 로드
  3. 투명한 접근: 프로그램이 파일을 직접 읽고 쓰는 대신, 메모리 주소를 통해 데이터에 간접적 접근

- `select_type: DERIVED`
  : 실행 계획 상 파생 테이블 (Derived Table)이 사용되었음을 의미한다. 해당 계획의 의미는 다음과 같다.
	- FROM절의 서브 쿼리를 위한 임시 테이블이 생성되었다.

###  B. 참고 문서
- [MySQL 공식 문서 - 내부 임시 테이블](https://dev.mysql.com/doc/refman/8.4/en/internal-temporary-tables.html)

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
