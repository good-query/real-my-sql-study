<h1 align = 'center'>4.4 MySQL 로그 파일</h1>

## 로그가 뭔데?

MySQL 서버는 단순히 데이터를 저장하고 응답만 하는 게 아니라, 그 안에서 벌어지는 각종 **이벤트, 에러, 쿼리 처리 내역**을 꼼꼼하게 기록(log)으로 남긴다.

이 기록 파일들은 단순한 참고용 그 이상이다.  
MySQL에서 문제가 생겼을 때, 성능이 느려졌을 때, 무슨 쿼리가 느린지 알고 싶을 때, 서버가 죽고 나서 무슨 일이 있었는지 확인할 때...  
**무조건 로그부터 본다.**

---

## 1️⃣ 에러 로그 (Error Log)

MySQL 서버의 **생명 주기 전체에서 벌어지는 주요 사건들**을 기록한다.

- 서버가 **언제 켜졌는지 / 꺼졌는지**
- 설정 파일이 어떻게 적용됐는지
- **InnoDB가 트랜잭션 복구**를 어떻게 했는지
- 커넥션이 왜 끊겼는지
- 심각한 **에러, 경고, 충돌 정보**

이 모든 걸 담고 있다.

---

### (1) MySQL 시작 시 나오는 메시지

MySQL 서버를 시작하면, 제일 먼저 설정 파일(`my.cnf`)에 명시된 값들을 로딩한다.  
근데 이때 변수가 잘못됐다거나, 오타가 있다거나 하면...  
**MySQL은 그냥 무시하거나 디폴트 값으로 대체해버린다.**

그래서 이 로그를 안 보면 설정이 잘 반영됐는지 절대 알 수가 없다.

- `"InnoDB: using atomic writes"`  
- `"Server hostname (bind-address): 0.0.0.0; port: 3306"`  
- `"Buffer pool size set to 128M"`

이런 식의 메시지로 실제 적용된 설정을 보여준다.

---

### (2) InnoDB 트랜잭션 복구 메시지

서버가 강제 종료되거나, 커널 패닉으로 죽었다가 다시 부팅되면,  
InnoDB는 디스크에 남아 있던 **Redo Log / Undo Log**를 이용해서 트랜잭션 복구를 시도한다.

그 과정이 로그에 상세하게 남는다:

- `"InnoDB: Starting crash recovery..."`  
- `"InnoDB: Rolling back trx with id=4828"`  
- `"InnoDB: Recovery completed"`

데이터 무결성을 지키는 이 로직이 잘 작동했는지 확인할 수 있다.  
만약 여기서 에러가 나면, 정말로 **데이터 손실**이 발생할 수도 있다.

---

### (3) 쿼리 실행 중 발생하는 에러 메시지

이건 클라이언트에게 직접 보내지지 않을 수도 있다.  
예를 들어:

- 디스크 공간 부족 (`Error writing file`),
- 잠금 충돌 (`Lock wait timeout exceeded`),
- 테이블 깨짐 (`Corrupt table`),
- UTF-8 인코딩 에러 등

쿼리가 제대로 실행됐는지, 혹시 내부적으로 무슨 문제가 있었는지를 확인할 수 있는 **디버깅 단서**들이 된다.

---

### (4) Aborted Connection 메시지

"Aborted connection"은 클라이언트가 제대로 `QUIT` 명령을 보내지 않고 **중간에 끊긴 경우**다.  
예를 들어:

- 사용자가 Ctrl+C로 프로세스를 종료함
- 네트워크가 불안정해서 연결이 끊김
- 커넥션 풀에서 강제로 expire됨

이게 너무 자주 보이면, **어플리케이션 레이어의 커넥션 관리 로직을 점검**해봐야 한다.

---

### (5) InnoDB 상태 조회 결과

`SHOW ENGINE INNODB STATUS` 명령을 실행하면,
InnoDB 내부의 상태를 굉장히 자세히 보여준다. (잠금, 버퍼풀, 대기 중인 트랜잭션 등)

이 결과는 단순히 콘솔에만 출력되는 게 아니라, **에러 로그에도 기록**된다.  
(이게 유일한 복사본이 되기도 한다)

---

### (6) MySQL 종료 메시지

정상적으로 `mysqladmin shutdown` 같은 명령으로 종료했는지,
아니면 강제 킬됐는지에 따라 메시지가 다르게 뜬다.

- `"MySQL server shutting down"`  
- `"InnoDB: Flushing buffer pool..."`  
- `"Shutdown complete"`  

이런 메시지가 없다면, 이전 종료는 비정상이었을 가능성이 높다.

---

## 2️⃣ 제너럴 쿼리 로그 (General Query Log)

이건 말 그대로, 서버로 **들어온 모든 요청을 전부 다 기록**한다.

- 누가 로그인했는지
- 무슨 SQL 문장이 들어왔는지
- 어떤 커넥션이 어떤 명령을 실행했는지

다 기록된다.

```sql
2025-04-04T15:32:10 12 Connect user@host on db 2025-04-04T15:32:10 12 Query SELECT * FROM users
```

### 이게 왜 필요하냐?

- 디버깅할 때: 서버에 어떤 쿼리가 들어오는지 그대로 확인 가능
- 악의적인 접근 추적: 의심스러운 활동을 탐지
- 쿼리 파싱 실험: ORM이 실제로 어떤 SQL을 던지는지 분석

### 단점?

- 실시간으로 계속 파일이 append 되므로, **디스크 쓰기 부담 큼**
- 느려지고, 로그 파일이 폭발적으로 커짐
- 운영 환경에서는 **절대 상시 활성화 금지**

---

## 3️⃣ 슬로우 쿼리 로그 (Slow Query Log)

**"느린 쿼리만 기록해줘"** 라고 설정해두면,
MySQL은 특정 조건에 해당하는 쿼리만 이 로그에 따로 기록한다.

기본 조건은 다음과 같다:

- 실행 시간이 `long_query_time` 이상
- 사용하는 인덱스가 없을 경우 (옵션에 따라)

### (1) 슬로우 쿼리 통계

단순히 한두 개 쿼리를 보는 게 아니라, **로그에 쌓인 모든 슬로우 쿼리들을 통계적으로 분석**할 수 있다.  
실제로는 `mysqldumpslow` 또는 `pt-query-digest` 같은 도구를 써야 한다.

### (2) 실행 빈도 및 누적 실행 시간 순 랭킹

- 느리지만 하루에 1번만 실행되는 쿼리  
- 좀 덜 느리지만 하루에 50만 번 실행되는 쿼리

당연히 후자가 시스템에 더 부담이 되겠지.  
이런 **“자주 호출되는 비효율적인 쿼리”**를 이 랭킹에서 찾아낸다.

### (3) 쿼리별 상세 정보

각 쿼리에 대해 다음 항목을 볼 수 있다:

- 총 몇 번 실행됐는지 (`Count`)
- 평균 실행 시간
- 최대/최소 실행 시간
- 평균 Lock 대기 시간
- 평균 Rows_examined / Rows_sent

쿼리 튜닝을 할 때 가장 유용한 정보들이 여기 다 담겨 있다.

---