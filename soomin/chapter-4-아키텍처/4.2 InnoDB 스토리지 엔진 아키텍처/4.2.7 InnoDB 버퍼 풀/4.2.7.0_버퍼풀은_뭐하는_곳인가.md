<h1 align = 'center'>0️⃣ InnoDB의 버퍼풀은 뭐하는 곳인가?</h1>

1. 사용자가 디스크에서 꺼낸 데이터 파일이나 인덱스 정보를 저장해두는 공간 (이러한 행위를 **캐싱**이라 함)
2. 사용자로부터 쓰기 작업이 들어오면 개별적으로 즉시 실행하지 않고, 한 번에 처리하기 위해 일정량 쌓아두는 공간

## 1. 효과

- `시간 절약` : 디스크 접근과 데이터 읽기 관점에서 메모리 버퍼는 HDD[^1] 와 SSD[^2] 보다 작게는 수천배 많게는 수십만배 더 빠르다. 
- `전체적 성능 향상, 디스크 I/O 부담 감소`: 단건 DML 마다 디스크 write가 들어가면, 디스크 I/O가 매번 일어나게 되고, 이는 해당 DML 작업 뿐만 아니라 동시에 일어나는 다른 쿼리 작업에 대한 심각한 성능 저하로 이어짐. 순차적인 대량 쓰기 (Batch Write)를 하면 여러 개의 작은 쓰기를 한 번의 큰 쓰기로 변환하여 디스크 I/O 부하를 줄일 수 있음.

 





## 가. 왜 메모리 접근보다 디스크 접근이 더 오래 걸리는가?

### a. 데이터 접근 관점

**HDD**는 사진과 같이 이루어져 있고, <u>(a) 탐구 시간: 디스크 실린더에 헤드를 놓는 시간</u> + <u>(b) 지연시간: 헤드가 트랙 내에서 원하는 섹터까지 가는데 걸리는 시간</u> 이 추가로 걸린다. 이러한 **물리적 탐색**으로 인해, HDD에서의 데이터 접근은 평균 7.5ms의 시간이 든다.

![70577713-1adc4b80-1bef-11ea-9cd6-5ba24d7dc539](https://github.com/user-attachments/assets/39b73775-1c1b-48d5-9836-41918f515855) [사진 출처: 디스크 스케줄 알고리즘 블로그](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-19.-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

**SSD**는 사진과 같이 이루어져 있고, **데이터를 페이지 단위로 저장하기에** 페이지 단위로 끊어서 원하는 데이터를 찾아야 한다. 만약 랜덤 I/O가 발생하면, 단 건의 조회마다 그것이 저장된 페이지를 찾아야 한다. 물리적인 기계가 돌아가는 형식은 아니기 때문에, HDD보단 빠른 0.1ms 정도의 접근 속도가 나온다. 하지만 이는 앞에서 말했듯이 하나의 페이지에 대한 접근이고, 순차 I/O의 경우 +@, 랜던 I/O의 경우 *@의 시간이 든다. 

![image-20250319013002137](https://github.com/user-attachments/assets/06f73e9c-010b-45e2-9765-7740e16a10e7) [사진 출처: SSD의 구조](https://medium.com/@develicit/ssd%EC%9D%98-%EA%B5%AC%EC%A1%B0-99afa6aba098)

반면 **버퍼 풀**은 작업이 이루어지는 메모리 공간에 데이터가 공존하고 있기 때문에 데이터를 직접 접근 하여 읽을 수 있다. 따라서 데이터 접근에 걸리는 시간은 평균 150ns 정도 이다.

### (b) 데이터 읽기

**HDD**는 데이터를 블록 단위 (하나 당 최소 512B ~ 4KB)에 저장하고 있다. 만약 사용자의 요청이 랜덤 I/O이면 엄청나게 느려진다.
**SSD**는 앞에서도 설명했듯이 데이터를 페이지 단위(하나 당 최소 4KB) 로 저장하고 있다. 순차 I/O의 경우도 페이지에 걸쳐서 데이터가 저장되어 있을 경우 +@의  접근이 추가로 들고, 랜덤 I/O는 *@로 배로 들 수 있다. 
**RAM**은 바이트 단위의 읽기가 가능하다. 특정 바이트를 바로 읽을 수 있어서 훨씬 빠르다.



#### 각주참고

[^1]: 회전하는 디스크 (플래터)와 이동하는 헤드로 이루어진 물리적인 기계식 저장 장치
[^2]: 반도체 기반 장치로 전자신호로 데이터를 저장하고 읽음



