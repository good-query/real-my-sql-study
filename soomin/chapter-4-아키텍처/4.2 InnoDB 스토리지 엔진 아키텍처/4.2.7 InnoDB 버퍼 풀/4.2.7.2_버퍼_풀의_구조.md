<h1 align='center'>2️⃣ 버퍼 풀의 구조</h1>

## (1) 버퍼풀 자체의 구조
![image-20250319175253944](https://github.com/user-attachments/assets/7b07a47c-bd71-409a-8c09-3a66c76d6e0c)


사진과 같이, 거대한 메모리 공간을 페이지 단위로 쪼개어서 관리하고 있다. 페이지 하나의 크기는 16KB이다. 

- `페이지에 데이터 삽입` : **ROW는 절대 분할되어서 페이지에 저장되지 않는다.** 즉 하나의 행은 온전히 하나의 페이지에 저장된다.
  - 만약 데이터를 삽입하려는 **페이지가 꽉 차 있다면?**
    **`페이지 분할`**이 실행됨. 페이지 분할이란, 꽉 차있는 페이지의 데이터 중 절반을 새로운 페이지에 저장하고, 현재 삽입하려는 대상을 페이지에 삽입하는 절차. 즉 하나의 페이지에 저장된 데이터를 두 곳으로 분할하기에 붙은 이름이다.

- `페이지에서 데이터 추출`: 행은 한 페이지에 온전히 저장됨으로 그것을 가져오면 된다. 
  - **`페이지 분할`이 일어난 상태라면?**
    **인덱스 기반 페이지 조각화 해결기법**이 들어간다. InnoDB 또한 인덱스 트리와 마찬가지로 B+Tree 형태로 데이터를 저장한다. 예를 들어 SELECT 문으로 복수의 데이터를 조회해야할 경우, 조회의 첫 시작 ROW가 저장된 페이지를 B+TREE 리프 노드 중에서 찾고, 마지막으로 조회할 데이터가 나올 때까지 리프노드를 순회하며 한 번에 긁어온다.

## (2) 버퍼 풀의 조각난 페이지를 관리하는 InnoDB의 자료 구조 3가지

### a. 프리 리스트

실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록 관리하는 자료 구조
사용자의 쿼리 실행 후, 디스크에서 읽어들인 데이터는 프리 리스트에 있는 빈페이지에 저장된다.

### b. LRU 리스트

버퍼 풀에서 데이터를 담고 있는 페이지들을 관리하는 자료구조이다. 에이징 기법을 활용해 사용자에 의해 쓰여지지 않은 기간만큼 페이지들에 나이를 먹이고 (사용되면, 다시 0으로 갱신), 나이가 들수록, List의 꼬리 부분으로 보낸다. 끝에 꼬리에서 밀려난 페이지는 자신의 데이터를 삭제하고, 다시 프리리스트에 등록된다.

  LRU 리스트의 사용 이유는 디스크로부터 한 번 읽어온 페이지를 최대한 InnoDB 버퍼 풀에 유지해서 디스크 읽기 자체를 최소화 하는 것이다.  

![image-20250319190732848](https://github.com/user-attachments/assets/d30feb8f-ceb2-49ec-af1f-d81c07dfd4bf)



### c. 플러시 리스트 

**플러시 리스트란** 버퍼 풀에 존재하는 **데이터가 변경된 페이지**를 관리하는 자료 구조이다.  페이지 속 데이터가 DML에 의해 그 내용이 변경된다면, 페이지는 플러시 리스트에 기록되고 관리된다. 이렇게 내용이 변경된 페이지를 더티 페이지라고 한다.

#### 플러시 리스트의 존재 이유  

플러시 리스트는 **배치 작업**을 위해 존재한다. 더티 페이지가 발생할 때마다 디스크에 쓰기 작업을 한다면 I/O 부하가 심해짐으로, 플러시 리스트에서 목록을 관리 후 특정 시점에 모아둔 변경 데이터들을 한 번에 디스크에 반영한다. 

#### DML 명령어로 데이터가 변경된 경우,

InnoDB는 변경 내용을 먼저 리두 로그에 기록하고 후에 버퍼 풀의 데이터 페이지에도 내용이 반영된다. 리두 로그의 각 엔트리는 자신 변경 내용을 기록한 데이터 페이지와 연결되 어있다. 



## (3) 추가 학습 - InnoDB에서 데이터를 찾는 과정

1. 클라이언트가 쿼리를 실행
2. SQL 파싱 및 옵티마이저가 실행 계획을 수립
   - 여기서 PK를 활용해 찾을 건지, 풀스캔을 때릴 건지, 보조인덱스를 통해 찾을 건지를 찾는다. 
3. 버퍼 풀 검사 
   1. Adaptive Hash Index[^1] 이용해서 버퍼 풀 내에 내가 찾는 페이지가 있는지 확인
   2. 해당 테이블의 인덱스(B-tree)가 버퍼 풀 내에 존재한다면 그것을 이용해 페이지 검색 
      (있으면 Cash-Hit -> 해당 데이터는 LRU 리스트 내에서 헤더 방향으로 승급 없으면 Cash-miss)

4. 없으면 디스크로 간다. 
   - 실행 계획이 보조인덱스 활용이면 보조 인덱스 -> 클러스터형 인덱스 과정을 통해 데이터 가져옴
   - Full scan이면 full scan 타서 데이터 가져옴
   - 클러스터형 인덱스 가져오는 거면 그걸로 데이터 바로 가져옴
5. 가져온 데이터를 버퍼 풀에 적재 및 LRU 리스트의 헤더에 추가
6. 버퍼 풀에 상주하는 페이지는 얼마나 최근에 접근했는지에 따라 LRU 리스트 내에서 나이가 부여하며 관리한다. 버퍼 풀 내  상주하는 동안 나이를 먹으나, 재사용되는 순간 LRU 리스트 상에 나이가 리셋 된다. 만약 계속 사용되지 않아서 나이를 먹고 LRU 리스트의 꼬리에서도 밀려나면, 그대로 버퍼 풀 내 해당 페이지의 데이터는 삭제되고, 해당 페이지는 프리 리스트로 이동한다.

## (4) DB 서버의 모든 데이터 구조는 B+Tree 인가?

맞다. DB 서버에서는 **`DEFAULT`**로 데이터를 페이지 단위로 나누고, 해당 페이지는 **B+Tree**의 리프 노드로 저장된다. B+Tree는 리프 노드를 제외한 나머지 NODE는 Key 값을 활용한 대소 관계 포인터만 가지고 실제 값을 포함하고 있지 않다. 모든 데이터는 B+Tree의 리프 노드가 가지고 있다. 

  **SSD**에 저장되는 데이터도 B+Tree의 인덱스 구조로 저장되고, 버퍼 풀(메모리)의 데이터 또한 조각난 페이지가 B+Tree 인덱스 구조를 가지고 있다.

  **B+Tree의 리프 노드 하나가 페이지 하나이다.** 즉 둘은 정확히 동일한 개념이다. 하나의 페이지는 여러 개의 레코드를 가진다.





[^1]: Adaptive Hash Index란 자주 사용되어서 일정 임계값을 넘은 데이터가 들어있는 페이지 (즉 리프노드)의 주소를 VALUE로 가지고 있고, 그것의 key 값 (혹은 index 값)을 키로 가지는 자료 구조이다. 사용자로부터 정확히 똑같은 요청이 몇 번 와야지 활용된다. 즉 `SELECT * from members Between id = 1000 AND id = 2000` 이란 요청이 매번 왔다면, Adaptive Hash Index에는 `key = 1000`이고 `value = 해당 id의 리프노드`를 가지는 값이 저장된다. 이제 같은 요청이 오면 루트 노드부터 리프노드까지 쭉 안 돌아도 한 번에 찾을 수 있어 조회가 더 빨라짐. 다만 `id = 1001`이 되면 이 Adaptive  Hash index는 활용이 안됨.
