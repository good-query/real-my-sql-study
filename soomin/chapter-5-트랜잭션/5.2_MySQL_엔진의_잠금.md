<h1 align = 'center'> 5.2 MySQL 엔진의 잠금</h1>

### A. MySQL 엔진 레벨의 잠금과 스토리지 엔진 레벨의 잠금 차이

| 개요                  | MYSQL 엔진                                              | 스토리지 엔진                                                |
| --------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 뜻                    | 스토리지 엔진을 제외한 나머지 부분                      | InnoDB, MyISAM, Memory 등                                    |
| 해당 레벨 잠금의 영향 | MySQL 엔진의 잠금은 모든 스토리지 엔진에 영향을 미친다. | 스토리지 엔진 레벨의 잠금은 타  스토리지 엔진에 상호 영향을 끼치지 않는다. |

### B. MySQL 엔진 레벨의 잠금 종류

- 테이블 데이터 동기화를 위한 테이블 락
- 테이블 구조 잠그는 메타데이터 락
- 사용자가 필요에 맞게 커스텀해서 쓰는 네임드 락

# 1️⃣글로벌 락

**`KEY WORD`:  글로벌 락 = MySQL 전체를 대상으로 거는 읽기 전용 락 **

## (1) 명령어

```sql
FLUSH TABLES WITH READ LOCK;
```

해석하면,

- Flush Table = MySQL 내에 스토리지 엔진 상관 없이 모든 테이블을 디스크로 Flush 해라
- WITH READ ROCK: Flush 이후에 전체 MySQL 서버에 대해 읽기 락을 걸어라

### 명령어 실행 전, 후 과정

- `실행 전`: 현재 실행 중인 모든 SQL문이 잠금 해제할 때까지 기다린다.
- `실행`: 모든 테이블 플러시, MySQL 전체 테이블에 대하여 읽기 락
- `실행 후`: 당연히 읽기 락만 걸었으니, SELECT 문 제외 `DDL`, `DML`은 글로벌 락 해제 시 까지 대기 상태 

## (2) 문제점

### A. 쿼리들의 대기 시간이 길어짐

실행 과정에서 봤듯이 글로벌락은 모든 잠금(읽기 락 포함)이 해제될 때까지 기다려야 한다. 만약 웹 서비스에서 특정 SELECT 문이 장시간 실행된다고 하면 (주가 계산 등) 
`SELECT 락` <- `글로벌 락 (대기)` <- `그 뒤로 밀린 모든 DDL, DML 작업 (대기)` 이 되어서  모든 쿼리가 아주 오랜 기간 동안 쓰이지 못하고 대기해야할 수 있으므로 웹 서비스 시는 가급적 사용하지 마라

### B. 복제 지연 발생 

- 레플리카서버에서 `mysqldump --master-data`와 같은 백업 도구 활용해서 자신의 데이터를 백업 
- 이때 위의 명령어는 데이터 정합성 보장을 위해서, 레플리카 서버 내부적으로 `FTWRL (글로벌 읽기 락)`을 실행
- 레플리카 서버의 모든 SQL 쓰레드가 작업 중지 (**주의! I/O 쓰레드는 살아있음!**)
- 소스 서버의 쓰기 작업은 계속 binLog에 쌓이고, I/O 쓰레드가 그걸 가져와서 relay log에 저장한다. 
- 하지만 **FTWRL** 때문에, relay Log가 실제 레플리카 서버 테이블엔 적용되지 않음 (SQL Thread는 블락 상태)
- 이후 글로벌 락이 해제된 이후에야 SQL Thread가 밀린 relay log를 한번에 처리 -> 복제 지연

### C. 장애 대응으로 인한 Replica 승격 시 문제

- Source 서버가 다운됨
- 다운 대응을 위해 Replica가 Source 서버로 승격해서 서비스를 이어 나가려고 한다.
- 만약  이때 **글로벌 읽기 락**이 걸려 있다면 이 락 때문에 SQL Thread가 이벤트를 아직 테이블에 적용하지 못한 상태일 수 있다. (relayLog 반영 못한 상태)
- 이 상태에서 승격해버리면? 
  - 적용안된 binlog 유실 (승격된 소스 서버가 최신 상태가 아니게 된다.)
  - 신규 트랜잭션 처리하려고 해도, Replica 시절의 글로벌 읽기 락이 해제가 안 된 상태로 옴으로 처리 불가

### D. `XtraBackup`, `Enterprise Backup`툴 사용해 백업 하는 도중에 DDL 쿼리를 만나면 백업이 실패하는 문제

- 예전에는 해당 도구로 백업 도중에 누군가 `ALTER TABLE`을 하면 → 백업 도구가 에러 내고 중단됨



## (3)글로벌 읽기 락 사용 예시

여러 데이터 베이스에 산재된 MyISAM과 MEMORY 테이블에 대하여 `mysqldump`로 일관된 백업을 할 때 사용

### 왜 InnoDB는 빼놓고 위의 두 개만 백업할 때 쓸까? 

MyISAM, Memory 테이블 은 트랜잭션을 지원하지 않기 때문에 데이터의 정합성을 보장하는 SnapShot을 찍어서 보관해야 한다.

## (3) 백업 락의 등장

**`KEY WORD`: **DDL만 블로킹, 복제 행위에 영향을 안 주면서도 백업 가능하게 함.

### A. 등장 배경

- 글로벌 읽기 락이 너무 강력해서 위의 3가지 문제가 발생 - 대안이 필요
- InnoDB의 상용화로 트랜잭션 사용이 대중화 됨.  - 데이터 정합성을 위해 모든 데이터에 변경 작업을 Block할 필요 없어짐
- 전통적인 글로벌 락보다 조금 더 가벼운 백업락 출시!

### B. 백업 락의 원리

복제는 **그대로 진행**시키되 백업 도중 **DDL(스키마 변경)**만 못하게 락을 건다.

# 2️⃣ 테이블 락

**`KEY WORD`: 지정된 테이블 단위로 작동하는 락**

## (1) 명시적 테이블 락

```sql
-- 다른 세션에서는 users 테이블을 읽지도, 쓰지도 못함 (만약 WIRTE 부분이 READ 였다면 읽기는 가능)
LOCK TABLES users WRITE;
... -- 트랜잭션 또는 DML 수행


-- 현재 세션의 모든 테이블 락 반납
UNLOCK TABLES;

```

**개발자가 직접 테이블 락을 선언하는 방식**

- 쓰기 락(WRITE)을 걸면 다른 세션은 SELECT조차 못 함
- 읽기 락(READ)을 걸면 다른 세션은 SELECT는 가능, INSERT/UPDATE/DELETE는 못함

### A. 주의사항

>  특별한 상황이 아니면 애플리케이션에서 사용하지 마라

왜?

- 테이블 락은 걸고 해제하는 작업 자체가 상당히 무겁다. (테이블이 클수록 더 무겁다.)
- 락 해제 전까지 테이블이 사용 불가 상태가 되는 것이, 단일 프로세스 일괄 작업에서는 괜찮지만,  멀티 쓰레드 환경인 MySQL에서는 치명적인 성능저하로 이루어진다.

## (2) 묵시적 락: 자동 발생하는 테이블 락

```sql
-- 묵시적인 테이블 락: 데이터를 변경할 때 자동 획득/반납
UPDATE table_name SET column_name = 1;
```

- 테이블의 데이터를 변경하는 쿼리 실행 시 자동으로 획득, 쿼리 완료 후 자동으로 반납
- MyISAM과  MEMORY는 레코드 수준의 락을 지원하지 않아서 쿼리 실행 시 MySQL 엔진이 자동으로 테이블 전체에 잠금을 건다.
- InnoDB 는 MVCC를 기반으로 한 **레코드 기반 잠금** 이기 때문에 단순 데이터 변경 DML로 묵시적 테이블 락이 설정되진 않음.
- InnoDB에서도 DDL 작업이면 묵시적 락 걸린다!
  - 테이블 구조 자체를 변경하는 작업이기 때문에



# 3️⃣ 네임드 락

**`KEY WORD`: `GET_LOCK()` 함수로 임의의 문자열에 대한 잠금 설정하는 락**

| 항목      | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| 락 대상   | **문자열(String)** – 사용자가 직접 정의 (`'mylock'` 같은 문자열) |
| 적용 범위 | **세션 단위** (세션이 닫히면 자동 해제됨)                    |
| 주요 목적 | **서로 다른 클라이언트(서버들) 간 동기화, 충돌 방지, 순서 보장** |
| 사용 시점 | 배치, 백업, 설정 동기화, 특정 레코드 군에 대한 독점적 처리   |

## (1) 활용 예시

```sql
-- 배치 작업 시작 시
IF GET_LOCK('batch-job-2024', 0) THEN
    -- 이 작업은 다른 인스턴스가 이미 실행 중이면 시작 안 함
    -- 배치 실행 로직...
    -- 끝나고 해제
    SELECT RELEASE_LOCK('batch-job-2024');
END IF;
```

# 4️⃣ 메타데이터 락

**`KEY WORD`: 테이블 이름이나 구조를 바꾸는 순간 자동으로 걸리는 락**

## (1) 메타데이터 락이란?

- 테이블, 뷰 등 **데이터베이스 객체의 구조나 이름**을 바꾸는 순간 자동으로 획득되는 락
- MySQL에서 **자동으로 관리됨** (개발자가 명시적으로 걸거나 해제 불가)
- 대표적인 예: `RENAME TABLE`, `ALTER TABLE`, `DROP TABLE` 등

```sql
RENAME TABLE t1 TO t2;  -- 실행 시 자동으로 메타데이터 락이 걸렸다가 해제됨
```

## (2) 실무 예시: 배치 작업에서 자주 등장

### A. 랭킹 테이블 교체 예시

- `rank_new` 테이블에 배치 작업으로 최신 랭킹 데이터를 생성
- 기존 `rank` 테이블은 서비스 중이므로 교체 시점에 일관성이 필요함

```sql
-- 나쁜 방식 (순차 실행)
RENAME TABLE rank TO rank_backup;
RENAME TABLE rank_new TO rank; 
-- 실행 사이에 rank 테이블이 "존재하지 않는" 짧은 순간이 생김
-- 서비스에서 "Table not found" 오류 발생 가능

-- 좋은 방식 (동시에 실행)
RENAME TABLE rank TO rank_backup, rank_new TO rank;
-- → 두 작업이 하나의 트랜잭션처럼 처리 → 오류 없음
```





# 💡 모르는 내용 정리!

# (가) 레플리카 서버와 소스 서버의 차이

## (1) 레플리케이션 기능이란?

- 하나의 MySQL 서버에서 발생한 **쓰기 작업 (트랜잭션)**을 다른 MySQL 서버들에 **자동으로 복제**하는 기능

| 역할                           | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| **Source** (이전 이름: Master) | 데이터를 실제로 쓰는 서버 (INSERT/UPDATE/DELETE 발생)        |
| **Replica** (이전 이름: Slave) | Source의 데이터를 **읽기 전용으로 복제**하는 서버 (읽기 부하 분산용) |

## (2) 복제 방식 요약

1. Source 서버에서 트랜잭션이 커밋됨
2. 그 내용을 **Binary Log (binlog)**에 기록
3. Replica 서버는 binlog를 받아서, `relay log`에 저장  (I/O 쓰레드 담당)
4. Replica의 **SQL Thread**가 relay log를 읽고 해당 변경사항을 적용 (SQL 쓰레드 담당)

→ 이 흐름이 계속 반복되면서 Source와 Replica는 거의 실시간으로 일치하게 됨

## (3) 레플리카 서버에 있는 쓰레드들의 역할과 종류

| 복제 스레드 구성 요소 | 역할                                             |
| --------------------- | ------------------------------------------------ |
| **IO Thread**         | Source 서버에서 binlog를 읽고 → relay log로 저장 |
| **SQL Thread**        | relay log를 읽고 → 실제로 DML을 테이블에 적용    |

```sql
SHOW SLAVE STATUS\G
```

```bash
# 결과
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
```

