---
tags:
  - 데이터베이스
  - cs
parent: "[[인덱스]]"
related: 
created: 2025-06-06
---

# 0. 학습 목적
- 멀티 벨류 인덱스가 무엇을 하는 것인지를 이해한다.
- 멀티 벨류 인덱스의 작동원리를 이해한다.
- 멀티 벨류 인덱스 활용법을 이해한다. (제약조건, 가능한 변주) 

# 1. 멀티 벨류 인덱스란? 
테이블의 JSON 컬럼의 값 안에 Array가 있다면 그 Array의 원소마다 개별적 인덱스로 분리 저장하여, 그 개별 원소로 검색했을 때도 그것을 포함한 레코드를 빠르게 검색할 수 있게 해주는 B-tree 기반 인덱스이다.

하나의 레코드가 여러가지 키를 가질 수 있고, 하나의 키도 여러가지 value (레코드)를 가질 수 있기 때문에 `멀티 벨류 인덱스`라고 한다.

> 이하 부터 Multi-valued-index를 줄여서 MVI라 칭하겠다.

## (0) 필요성?
- **JSON 기반 검색에서 성능이 저하되던 mySQL의 단점 보완하기 위해**

MySQL은 JSON 타입의 컬럼은 지원했지만, 이 JSON을 활용해 효율적으로 검색할 수 있는 인덱스는 따로 지원하지 않았다. 따라서 JSON 안에 특정 값이 포함된 레코드만 검색하려할 경우 다음과 같이 동작했다.

- JSON 자체를 하나의 덩어리의 문자열로 취급한다.
- JSON 내부 값을 처음부터 쭉 훑어서 원하는 값이 있는지 찾는다.
- 이 과정을 모든 레코드에 대해서 반복한다. (table full scan) 

위와 같이 JSON에 대한 검색 부분에서 엄청난 성능 저하가 일어났고, 기본적으로 JSON 포맷으로 데이터를 저장하며 다양한 JSON 기반 인덱스를 지원했던 MongoDB에게 해당 부분에서 밀렸다.

MySQL 8.0부터 이러한 MySQL의 단점을 극복하고자, 해당 **`JSON 기반의 인덱스`** 인 **MULTI-VALUED-INDEX(MVI)** 가 지원하게 되었다.

## (1) 멀티 벨류 인덱스가 생성되는 과정 

JSON 타입의 tag라는 키가 존재하고, 해당 컬럼 내의 Array가 다음과 같이 있다고 해보자.
우리는 이 tag를 컬럼 키로 가지는 Multi-valued Index를 만든다고 해보자.

![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250606235806.png)

- B-tree 기반
- tag 값도 중복되고, PK도 중복되어서 나옴. 다만 그 둘의 조합은 유니크함을 알 수 있다.

## (2) 멀티 벨류 인덱스의 제약 조건
- JSON 속 Array 값이 비어있는 경우, MVI는 해당 레코드에 대한 인덱스를 만들지 않는다. 따라서, 빈 배열 값은 MVI 활용 검색으로 찾을 수 없다.
  
- 배열 안에 null 값이 존재하면, 멀티 벨류 인덱스를 만들지 못한다. ERROR가 난다. 
  (ex - [1, null, 3])
  
- 복합 인덱스를 만들 때는 딱 하나의 JSON 타입의 Array만 사용 가능하다. 두 개의 JSON 타입 ARRAY를 동시에 사용한 복합 컬럼 인덱스는 만들 수 없다. 
  (ex-  user_id, CAST(tags AS ARRAY) 두 개 복합 가능, CAST(tags AS ARRAY), CAST (regions AS ARRAY) 와 같이 멀티 벨류 두개 복합한 인덱스는 불가)
  
- 멀티 벨류 인덱스는 컬럼 키 정렬이 안된다. 따라서 ORDER BY의 정렬 기준으로 못 쓴다.
  
- 멀티 벨류 인덱스는 PK로 사용하지 못한다.
- 멀티 벨류 인덱스 활용은 멀티 벨류 전용 함수 (MEMBER OF(), JSON_CONTAINS()를 써야지만 가능하다.) 

# 2. 멀티 벨류 인덱스의 Variation

## (1) 멀티 벨류 인덱스로 복합키 만들기
위에서 설명했듯이, 두 개의 JSON 타입으로 하나의 복합키를 만들지 못한다. 다만 하나의 일반 컬럼 + 멀티 벨류는 가능하다.

```sql
ALTER TABLE location_data ADD INDEX idx_postal_codes_modified((CAST(location_info -> '$.postal_codes' AS UNSIGNED ARRAY)), user_id);
```

## (2) 멀티 벨류 인덱스를 유니크 키로 만들기 
멀티 벨류를 유니크 키로 설정한다는 뜻은 다음과 같다. 

- 하나의 레코드는 다른 레코드와 겹치는 원소 값을 가질 수 없다.
- 하나의 레코드는 배열안의 원소가 중복되는 것은 괜찮다.

예시는 다음과 같다.

```sql
-- 하나의 레코드의 원소가 중복되어도 괜찮음 (현재 우편번호 10001이 중복되고 있음)
mysql> INSERT INTO location_data (location_info) VALUES ('{"city":"New York", "state":"NY", "country": "America","postal_codes":[10001, 10001, 10002, 10002, 10003, 10004]}'); 
Query OK, 1 row affected (0.01 sec) 

-- 오류 (위에 삽입한 레코드와 같은 원소를 가짐.
mysql> INSERT INTO location_data (location_info) VALUES ('{"city":"New York", "state":"NY", "country": "America","postal_codes":[10001, 10002, 10003, 10004]}'); 
ERROR 1062 (23000): Duplicate entry '[10001, ' for key 'location_data.idx_postal_codes'
```

# 3. 멀티 벨류 인덱스 활용법

### (1) 사전 설정
다음과 같은 JSON 타입을 가진 테이블이 있다고 해보자.

```sql
CREATE TABLE users (
	user_id BIGINT,
	name VARCHAR(30),
	characters JSON
)
```

characters라는 json은 다음과 같은 형태라고 해보자.
```json
{
	"type" : "introvert",
	"mbti" : "INFP",
	"tags" : ["shy", "cute", "Awesome", "chill"]
}
```

### (2) 인덱스 생성
해당 characters란 구성요소 중 tags라는 녀석에 대해서 INDEX를 만들어 보겠다.

```sql
CREATE INDEX idx_postal_codes ON location_data ((CAST(characters -> '$.tags' AS CHAR ARRAY)));
```

mySQL 공식 구조는 다음과 같다.
```sql
CAST(json_column -> '$.json_path' AS data_type ARRAY)
```
$ 다음으로 json 구조내의 Key 이름을 적으면 된다. 만약 더 깊은 depth에 있는 값에 대하여 인덱스를 걸고 싶다면,
```sql
CREATE INDEX idx_postal_codes
ON location_data ((CAST(info -> '$.address.postal_codes' AS UNSIGNED ARRAY)));

```

위의 예시처럼 걸면된다. 위는 주소라는 객체안에, 우편번호라는 배열을 다시 고른 것이다.

### (3) 인덱스 활용
MVI를 활용하려면 다음의 정해진 함수를 써야 한다.

| 함수                                          | 의미 (Layman's Term)                     | 대상 타입            | 사용 의도                |
| ------------------------------------------- | -------------------------------------- | ---------------- | -------------------- |
| `MEMBER_OF(value, array)`                   | "이 값이 배열에 들어 있니?"                      | **스칼라 vs 배열**    | 배열 안의 **단일 값 포함 여부** |
| `JSON_CONTAINS(target, candidate [, path])` | "이 JSON 구조 안에 정확히 이 target 값이 포함돼 있니?" | **JSON vs JSON** | 부분 포함 (스칼라/배열/객체)    |
| `JSON_OVERLAPS(json1, json2)`               | "두 JSON 안에 겹치는 값이 하나라도 있니?"            | **JSON vs JSON** | 교집합 검사               |

### (1) MEBER OF()
```sql
SELECT * FROM users
WHERE 'shy' MEMBER OF (characters -> '$.tags');
```

- characters.tags라는 배열 안에 'shy'가 있는 레코드만 전부 가져오기 
- 배열을 대상으로만 쓸 수 있다.
- 찾으려는 값은 단일 값만 가능하다. (복수의 값 검색 불가) 

### (2) JSON_CONTAINS()
```sql
SELECT * FROM users
WHERE JSON_CONTAINS(characters, '"shy"', '$.tags');

```

- characters.tags의 하위 경로안에 'shy'라는 값이 포함되어 있는지 검사 후, 그것이 있는 레코드만 전부 가져옴
- shy가 배열에 있든, 객체의 value이든 가능 
- 2번째 인자가 문자열 하나일 필요가 없다. 두번째 인자또한 JSON 타입이기 때문에 다음과 같은 것도 가능하다.
```sql
JSON_CONTAINS(characters, '["shy", "cute"]', '$.tags')
```

### (3) JSON_OVERLAPS()
```sql
SELECT * FROM users
WHERE JSON_OVERLAPS(characters -> '$.tags', '["cute", "genius"]');
```

- tags 배열안에 cute나 genius 중 하나라도 겹치는 레코드를 모두 가져옴
- 배열 간 교집합 검사, 다중 매칭 시 활용

# 4. 핵심 요약
- 멀티벨류인덱스(이하 MVI)는 JSON에 대한 검색 서비스가 미비하던 mySQL의 단점을 상쇄하고, JSON 내의 구조들에 대한 효율적인 검사를 위해 추가되었다.
  
- MVI는 JSON 내의 Array의 원소에 대해 개별적인 인덱스를 만든다. 따라서 하나의 키 컬럼이 가리키는 레코드 개수가 여러 개이고, 하나의 레코드와 연관된 키 컬럼 또한 여러 개이다. (N:M 관계) 
  
- 멀티벨류 인덱스는 복합 컬럼 인덱스, 유니크 인덱스로 만들 수 있지만 제약사항이 있다.
  
- 멀티벨류 인덱스의 제약 조건은 해당 키 컬럼으로 정렬을 못하고, PK로 활용하지 못하며, Array가 빈 값인 경우, index로 만들지 않고, Array에 null이 포함된 경우, MVI로 못 만들고 에러가 난다.

---

# Metadata

### A. 모르는 단어 정리 to Layman's term
- `yield` : 산출하다. 생성하다.
- `accomodate`: 수용하다.
- `commposite index`: 복합키

###  B. 참고 문서
- [Improving Query Performance with Multi-Valued Indexing in MySQL 8.0](https://www.mydbops.com/blog/improving-query-performance-with-multi-valued-indexing-in-mysql-80)
- [mySQL 공식 문서 - multi-valued 부분](https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-multi-valued)
- real-my-sql 8.7

### C. 자식 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
