---
tags:
  - 데이터베이스
  - cs
parent: "[[클러스터링 인덱스]]"
related: 
created: 2025-06-17
---

# 0. 학습 목적
- innoDB의 기본 테이블인 클러스터링 테이블 사용 시 주의사항을 숙지한다.

# 1. 클러스터링 인덱스 키의 크기가 너무 커서는 안된다. 
`이유`: **클러스터링 키 크기 증가 -> 동일 테이블의 보조 인덱스 크기도 함께 증가 -> 필요 메모리 증가**

모든 세컨더리 인덱스는 리프노드에 클러스터링 인덱스 키 (즉 PK)를 가지고 있다. 클러스터링 인덱스 키가 커지면 자연스럽게 해당 테이블의 보조 인덱스의 크기 또한 같이 커진다. 이는 <u>(1) 인덱스를 저장하기 위한 공간이 더 필요</u>해지고 <u>(2) 인덱스를 메모리에 적재할 때 드는 메모리 공간도 더 필요</u>해짐으로 비효율적이다.

보통, 실무에서는 하나의 테이블 당 보조 인덱스가 4~5개 정도 존재하는데, 이런 환경에서는 클러스터링 인덱스 크기가 커질수록 부작용이 더 커질 것이다. 

### A. PK 크기에 따른 파급효과 예시
하나의 테이블에 보조 인덱스가 5개가 존재한다고 가정하고 다음 예시를 보자

| PK 크기   | 레코드 당 증가하는 인덱스 크기      | 100만 건 레코드 저장 시 증가하는 인덱스 크기  |
| ------- | ---------------------- | ---------------------------- |
| 10 byte | 10 byte * 5 = 50 byte  | 50 byte * 1,000,000 = 47MB   |
| 50 byte | 50 byte * 5 = 250 byte | 250 byte * 1,000,000 = 238MB |

보조 인덱스가 5개 있으므로, 하나의 레코드 당 자신을 가리키는 인덱스 컬럼이 5개 존재한다는 뜻이다. 따라서 10byte일 때는 하나의 레코드 당 50 byte가 추가로 들고, 50 byte라면 250 byte가 더 든다. 
 하나씩 비교했을 때는 200 byte 밖에 차이가 나지 않지만, 레코드가 늘어날수록 그 격차가 벌어짐을 알 수 있다.

# 2. 프라이머리 키는 반드시 명시할 것
`이유`: **클러스터링 테이블은 PK 기반 조회가 빠른 것이 장점인데, PK 안 쓰는 건 모래주머니 차고 경기 뛰는 것이기 떄문에**

저번 장에서 배웠듯이 PK를 명시하지 않으면 innoDB 내부적으로 다음 규칙에 맞는 컬럼을 *암묵적인 PK*로 활용한다.
- 컬럼 중 유니크 + NON NULL 인 컬럼들 중 첫 번째를 PK 삼아 클러스터링 테이블 구성
- 그런 게 하나도 없으면, 내부적으로 각 레코드마다 유일무이한 가상 값을 만들어 클러스터링 테이블 구성

이 암묵적인 PK는 사용자가 활용할 수 없음은 당연하다.
그럼 PK를 뭘로 하면 좋을지는 다음을 통해 알아보자. 

# 3. PK는 웬만하면 Surogate Key보단 Natural Key로
`이유`: InnoDB 테이블 = PK 기준으로 데이터 정리 -> 따라서 PK로 검색할 때 조회 성능이 빠르다. 
업무적으로 중요하고 빈번하게 쓰이는 컬럼을 Key로 만들어서 (Natural Key) PK 조회의 성능을 최대한 활용하라.

# 4. Surogate Key를 써야하는 경우
- 보조 인덱스가 많이 있을 수 있는 상황 && Natrual Key를 PK로 할 경우 인덱스 크기가 엄청 커진다.

# 5.핵심 요약
- PK 인덱스 크기가 커지면 테이블의 부가 인덱스 크기 증가 -> B-tree 높이 UP -> 조회 조인 성능 증가 
- PK는 무조건 만들고 웬만하면 Natural Key로 하삼. 안되면 Serogate라도 하삼.

---

# Metadata

### A. 모르는 단어 정리 

###  B. 참고 문서

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
