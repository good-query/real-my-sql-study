---
type: study
source:
  - real-my-sql
tags:
  - 데이터베이스
  - cs
created: 2025-05-28
---

### Relevace Framing 🧩

**`부모 글` : [[B-Tree 인덱스]]**

# 0. 학습 목적

B-tree를 활용한 검색 혹은 값 변경 작업의 성능에 영향을 주는 요소를 이해한다. 
이를 통해 인덱스 생성을 더 효율적으로 한다.

인덱스를 활용한 검색 혹은 값 변경의 성능에 영향을 주는 요소는 총 3가지로 `인덱스를 구성하는 컬럼의 크기`, `레코드 건수`, `유니크한 인덱스 키 값의 개수` 가 있다.

# 1. 인덱스 키를 구성하는 컬럼의 크기 

인덱스의 모든 노드는 Page 이다. 따라서 해당 노드의 크기도 Page의 크기와 같다. 
(4KB ~ 64 KB 중 선택할 수 있으나, 여기서는 Page 크기를 16KB라고 가정하자.) 

## (1) 하나의 인덱스 페이지가 가질 수 있는 자식 노드의 개수를 결정

인덱스 페이지가 가질 수 있는 자식 노드의 개수는 **인덱스의 키 컬럼의 크기가 커질수록 줄어든다.**

인덱스의 키 크기를 `16` 바이트, 자식 노드 주소 크기를 `12` 바이트라고 가정해보자.
(주소값은 6 ~12 바이트 까지 다양한 크기를 가질 수 있다. 또한 해당 주소값은 루트나 브랜치의 경우, 자식노드의 주소이고 리프 노드의 경우, 데이터 파일 속 레코드의 주소값이다.)

그러면 하나의 인덱스 페이지 당 **585**개의 자식노드를 가질 수 있다.

반면 인덱스의 키 크기가 `32` 바이트라고 가정한다면 하나의 인덱스 페이지 당 **373**개의 자식노드만 가질 수 있다. 

만약 우리가 SELECT로 500개의 레코드를 읽어야 한다면, 전자는 한 번의 디스크 I/O로 데이터를 읽을 수 있지만, 후자는 두 번의 디스크 I/O가 필요하다.

### A. 파급효과, B-tree의 깊이

인덱스의 키 컬럼 크기가 커진다. -> 하나의 인덱스 페이지가 가질 수 있는 자식 노드의 개수가 줄어든다. -> B-tree의 깊이가 커진다. -> 더 많은 디스크 읽기가 필요하다.

B-tree 깊이가 3인 경우, 전자의 경우 2억개의 키 값을 담을 수 있다. 반면 후자의 경우 5000만 개가 최대이다. 

## (2). 버퍼풀에 올릴 데이터 레코드의 개수도 결정 (참고) 

버퍼 풀에 올릴 수 있는 데이터 레코드의 개수는 마찬가지로 **인덱스의 키 컬럼 크기가 커질수록 줄어든다.**

버퍼풀 또한 크기가 한정적이기 때문에, 인덱스 키 컬럼의 크기가 커져서 전체 인덱스 크기가 커지면 한 번에 매모리에 캐시할 수 있는 레코드 건수가 줄어든다. 이는 메모리의 효율적 사용을 저해한다.

# 2. 선택도 (기수성) 

> SELECTIVITY 혹은 CARDINALITY 라고 부른다.

- 선택도 혹은 기수성은 **모든 인덱스 키 값 가운데 유니크한 값의 개수**를 의미한다.
  
- 선택도가 높을수록 검색 성능이 올라간다.
  (인덱스로 걸러지는 값이 많아져서, 검색 대상이 줄어들기 때문에 )
  
- 선택도의 계산은 $선택도 = 고유값의 개수 / 전체 레코드 건수$ 이다.

### A. 선택도 UP -> 검색 성능 UP의 예시

테이블 `Location`에 `country`와 `city`  컬럼이 있다고 해보자. Location의 레코드 건 수는 만 개 이다.

- CASE A: country에 index가 걸려 있고, 유니크한 레코드 건 수는 10개 
- CASE B: country에 index가 걸려 있고, 유니크한 레코드 건 수는 1,000개

즉 Case A에서는 나라가 10개만 존재한다는 것이고, B에서는 나라가 1000개 존재한다는 것이다. 이때 다음을 계산해보자.

```sql
SELECT *
FROM Location
WHERE country = 'KOREA' AND city = 'SEOUL'
```

만약 계산 결과가 레코드 건 수 하나라면 
CASE A는 coutnry 인덱스로 거르고 난 후에도 인덱스가 중복된 레코드가 1000개가 생긴다. 따라서 1000개의 레코드를 일일히 들여다봐야 한다. 이는 999개의 불필요한 레코드를 확인해야 하는 작업이다.
 
반면 CASE B는 coutnry로 거르고 나면 중복되는 인덱스르 가진 레코드가 10개로 줄어든다. 따라서 9개의 불 필요한 레코드만 확인하면 된다. 

# 3. 찾아야 하는 레코드 건수

**찾아야 하는 레코드 건 수가 작을수록 인덱스 활용 가치가 있다.**

이유:
- 인덱스를 통해 테이블 레코드를 읽는 작업은 인덱스 거치지 않고 테이블 레코드를 읽는 것보다 높은 비용이 든다.
- DBMS의 옵티마이저는 대체적으로 인덱스를 통해 레코드 1건 읽는 것은 테이블에서 직접 레코드를 읽는 것보다 **4 ~ 5 배 정도 비용**이 더 많이 드는 작업으로 예측한다. 

따라서 만약 전체 테이블 레코드 건 수 중 20 ~ 25 %를 넘어서는 레코드들을 읽어들여야 한다면, 인덱스 활용 검색보다 전체 다 읽어서 필요한 것만 가려내는 것이 훨씬 효율적이다.

# 핵심 요약

- B-tree 인덱스의 성능에 영향을 주는 요소는 `키 컬럼의 크기`, `선택도`, `레코드 건수` 가 있다.
	- 키 컬럼의 크기가 클수록 하나의 인덱스 페이지에 담을 수 있는 키 값의 개수가 줄어들어, 전체 디스크 I/O 횟수를 증가 시킨다. = 키 컬럼 UP, 인덱스 성능 DOWN
	  
	- 선택도는 인덱스 내의 유니크 컬럼의 개수이다. 선택도 = $유니크 레코드 개수 / 전체 레코드 개수$ 이다. 선택도가 높아질수록 인덱스 활용 시 걸러지는 레코드가 많아지기에 검색 성능이 높아진다.
	  
	- 찾아야하는 레코드 건 수가 많아질수록 인덱스 활용이 오히려 성능을 떨어트릴 수 있다. 왜냐하면 인덱스 활용 레코드 read는 테이블에 직접 레코드를 읽는 것보다 4~5배 큰 비용이 들기 때문이다.

---

# Metadata

### A. 모르는 단어 정리 to Layman's term

###  B. 참고 문서

### C. 자식 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
