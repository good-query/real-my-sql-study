---
tags:
  - 데이터베이스
  - cs
parent: "[[클러스터링 인덱스]]"
related:
  - "[[세컨더리 인덱스 (보조 인덱스)]]"
created: 2025-06-07
---

# 0. 학습 목적
- 각 스토리지엔진의 내부 인덱스 구현 원리를 이해한다.
- innoDB가 타 스토리지엔진과 비교했을 때 누리는 장점과 단점을 이해한다.

# 1. InnoDB와 다른 스토리지 엔진의 인덱스 작동 방식 비교

### A. 다른 스토리지 엔진의 경우 (MyISAM, MEMORY) 
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250607230824.png)

- 데이터 저장: 데이터 파일 끝 (혹은 임의의 장소)에 데이터가 저장된다. 한 번 저장되면 위치가 바뀌지 않으며, 해당 위치를 나타내는 ROWID를 부여받는다.
- 인덱스의 작동원리: PK 인덱스이든, 세컨더리 인덱스이든 무조건 리프노드는 ROWID를 가지고 있고, 데이터 파일에 존재하는 실제 레코드 데이터의 위치를 바로 가리킨다. 

### B. InnoDB의 경우
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-05/20250607231617.png)

- 데이터 저장: 클러스터링 인덱스 자체가 데이터 파일이다. B-Tree로 구조화, 리프노드에 실 데이터 저장
- 인덱스의 작동 원리
	- 클러스터링 인덱스(=PK 인덱스)
	  : 원하는 값의 리프노드를 찾아서 리프노드에 저장된 데이터 레코드를 읽는다.
	  
	- 세컨더리 인덱스
	  : 세컨더리 인덱스는 해당 데이터의 PK값이 리프노드에 저장되어 있다.
	  따라서 원하는 데이터를 보조 인덱스로 찾을 경우 다음 형식으로 진행된다.
		1. 세컨더리 인덱스로 탐색하여 원하는 데이터 레코드의 PK값을 찾는다.
		2. 해당 PK 값으로 클러스터링 인덱스를 재탐색하여 실제 데이터를 얻는다. 

# 2. InnoDB를 타 스토리지엔진과 비교했을 때 장단점

| InnoDB 메타의 장점                                                                                                                                                                                            | InnoDB 메타의 단점                                                                                       |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------- |
| 1. PK 값으로 데이터를 찾을 경우 어떠한 스토리지 엔진보다 빠르다.<br>(데이터 파일을 한 번 더 탐색하는 과정이 없기 때문)                                                                                                                                | 1. 세컨더리 인덱스 활용 검색 시, 장점의 2번 경우를 제외하면 원하는 데이터 레코드를 찾기 위해, 클러스터링 인덱스를 찾은 PK로 다시 한번 더 검색해야 한다. (성능 저하) |
| 2. 세컨더리 인덱스를 쓰더라도, 세컨더리 인덱스의 리프노드에서 원하는 데이터를 다 찾는 경우, 1번과 같은 성능으로 빠르다.<br><br>리프노드에서 원하는 데이터를 다 찾는 경우<br>  a. 내가 원하는 것은 PK 뿐이다.<br>  b. 세컨더리 인덱스가 PK에 더해 여러 컬럼 값을 가진 커버링 인덱스이다                           | 2. INSERT 시, 데이터 자체를 PK에 맞게 정렬해서 저장해야함으로 상대적으로 속도가 느리다.<br><br>                                     |
| 3. 클러스터링 인덱스 덕분에 데이터 위치 특정이 훨씬 수월해졌다. <br>그 덕에, MVCC, undo Log 등, 고차원의 트랜잭션 관리와 crash 상황 대처 능력이 올라갔다.<br><br>(MyISAM 등 논 클러스터링 아키텍처는 delete 된 데이터로 인해 생기는 빈 공간도 불규칙적으로 이용함으로 데이터의 위치 파악이 상대적으로 어려움) <br> |                                                                                                     |

3번 맞는지 스터디원들과 확인하기

# 핵심 요약

-  innodb는 클러스터링 테이블로 데이터를 저장하고, 모든 보조 인덱스의 리프노드는 실데이터의 PK를 가지고 있다. (즉 해당 PK로 클러스터링 테이블 재탐색 해야함.) 
- MyISAM이나 Memory 같은 논 클러스터링형 아키텍쳐들은 PK 인덱스이든, 세컨더리 인덱스이든, 모두 데이터 파일내 데이터의 실주소인 ROWID를 가지고 있다. 
- innodb는 그것의 아키텍처 덕분에 PK 이용 검색이 빠르다. 보조 인덱스 활용 검색은 커버링 인덱스가 없으면 느릴 수 있다.
- innodb의 아키텍처는 데이터의 위치를 PK로 100% 특정할 수 있다는 장점이 있다. 이는 undo-log나 MVCC라는 고차원 아키텍처를 쌓을 수 있는 신뢰의 기반이 되었다.

---

# Metadata

### A. 모르는 단어 정리 

###  B. 참고 문서

### C. 자식 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
