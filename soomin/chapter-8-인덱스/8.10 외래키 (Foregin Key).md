---
tags:
  - 데이터베이스
  - cs
parent: "[[인덱스]]"
related: 
created: 2025-06-18
---

# 0. 학습 목적
- 외래키가 무엇인지 이해한다.
- 외래키 적용 시 부모 테이블과 자식 테이블에서 일어날 수 있는 잠금 경합에 대해 이해한다.
- 부모 테이블에서 변경 작업이 있는 경우와 자식 테이블에서 변경 작업이 있는 경우를 따로 뗴어내서 이해한다.

# 1. 외래키란? 
한 테이블의 컬럼이 다른 테이블의 PK를 참조하고 있을 때, 해당 컬럼을 **FK (외래키)** 라고 한다.
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250618183446.png)

## (1) 외래키의 필요성
1. 데이터의 무결성과 일관성을 지키기 위해
	: FK를 활용한 테이블 연결은 업무 상  데이터간의 연관관계를 DB에 그대로 반영할 수 있게 만들어준다.
	그 덕에 데이터간의 연결성, 동기화를 언제나 정확하게 유지할 수 있다. 

2. 중복된 데이터 최소화
   : FK로 설정된 PK만 관리하면, 그것을 참조하는 컬럼들은 간접적으로 관리된다.
	이는 동일한 데이터에 대한 중복 저장 및 관리할 필요가 없게 만들어줘서 데이터 관리를 수월하게 해준다.

## (2) 관련된 용어 설명 
- 부모 테이블
  : 참조되는 PK가 존재하는 테이블 
  
- 자식 테이블
  : 부모 테이블의 PK를 FK로 들고 있는 테이블 
   해당 FK를 통해 부모 테이블을 참조한다.

> 자식은 부모를 찾기 위해, 부모의 전화번호를 들고 있어야 한다.

# 2. InnoDB의 부모, 자식 테이블 관계 관리 규칙
두 테이블은 연결되어 있기 때문에, 한 쪽 테이블의 변경 사항이 다른 쪽 테이블에 영향을 줄 수 있다. 따라서 InnoDB는 둘 중 하나에서 변경 사항이 발생 했을 시, 다음 **2가지 규칙**을 준수하여 일을 처리한다.

부모, 자식 테이블에 대한 동시 처리 상황이 생긴 경우우,
1. 테이블 변경 작업이 발생하는 경우에만, 잠금 경합을 발생 시켜 순차적으로 처리한다.
2. 외래 키와 연관되지 않은 컬럼의 변경 작업에서는 최대한 잠금 경합을 발생 시키지 않고 일을 처리한다.

이제 위 규칙이 드러나는 트랜잭션 간의 경쟁 예시를 보며 이해해보자. 먼저 table 예시는 다음과 같다.

```sql
CREATE TABLE parent (
  id INT PRIMARY KEY,
  name VARCHAR(20)
);

CREATE TABLE child (
  id INT PRIMARY KEY,
  name VARCHAR(20),
  pid INT,
  FOREIGN KEY (pid) REFERENCES department(id) on delete cascade
);

```

## (1) 자식 테이블이 변경을 대기하는 경우

| 작업 번호 | 커넥션 - 1                                               | 커넥션 - 2                                     |
| ----- | ----------------------------------------------------- | ------------------------------------------- |
| 1     | BEGIN;                                                |                                             |
| 2     | UPDATE tb_parent<br>SET name='changed-2' where id = 2 |                                             |
| 3     |                                                       | BEGIN;                                      |
| 4     |                                                       | UPDATE child<br>SET pid = 2 where id = 100; |
| 5     | ROLLBACK;                                             |                                             |
| 6     |                                                       | Query OK, 1 row affected (3.04 sec)         |

1. 커넥션-1에서 부모 테이블 변경 작업이 필요하기에, 부모 테이블에 대한 베타락 잠금 
2. 커넥션-2도 트랜잭션이 시작되지만, 커넥션 - 1의 변경 작업이 완료할 떄까지 대기 
3. 커넥션-1의 작업이 끝나고서야 비로소 커넥션 -2가 작업을 끝내고 자신의 일을 한다.

위와 같이 일처리가 된 이유는 
1. 부모 테이블에 대한 쓰기 작업이었다. (읽기가 아니었음)
2. 자식 테이블에서 변경 하려던 것이 FK였다. (외래키와 연관된 변경 작업) 

따라서 위의 두 가지 규칙이 지켜져서, 변경이 된다.

## (2) 부모 테이블이 변경을 대기하는 경우

| 작업 번호 | 커넥션 - 1                                                    | 커넥션 - 2                             |
| ----- | ---------------------------------------------------------- | ----------------------------------- |
| 1     | BEGIN;                                                     |                                     |
| 2     | UPDATE child<br>SET name = 'changed-100'<br>WHERE id = 100 |                                     |
| 3     |                                                            | BEGIN                               |
| 4     |                                                            | DELETE FROM parent<br>where id = 1; |
| 5     | ROLLBACK;                                                  |                                     |
| 6     |                                                            | Query OK, 1 row affected (6.09 sec) |

1. 자식 테이블에서의 쓰기 작업을 위해 자식 테이블 전체에 대한 베타락
2. 부모 테이블에서 id = 1인 행을 지우려고 하는데 테이블 설정이 `on delete cascade` 라서 부모 행 삭제 시 연관된 자식 행도 지워져야 함. 
   하지만 자식 테이블은 현재 1번의 트랜잭션이 끝나지 않았기 때문에 커넥션-1이 완료될 때까지 잠금 대기
3. 커넥션 - 1이 작업을 끝내면 비로소 커넥션-2도 자신의 할 일을 마친다.

# 핵심 요약
- 외래키는 두 테이블을 연결시키는 제약 조건. 
	- 부모 테이블 = 참조되는 테이블
	- 자식 테이블 = 부모를 참조하는 테이블
- 부모 자식 테이블 사이에서 작업 경쟁이 붙은 경우에는 <u>(1) 쓰기 작업이며</u>, <u>(2) 해당 쓰기 작업이 FK와 연관된 컬럼을 대상으로 일어나는 경우</u>  잠금 경합을 발생시켜 일을 순차적으로 처리한다.

---

# Metadata

### A. 모르는 단어 정리 
- `무결성`
  : 데이터가 항상 정확한 값을 유지하는 성질

###  B. 참고 문서

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
