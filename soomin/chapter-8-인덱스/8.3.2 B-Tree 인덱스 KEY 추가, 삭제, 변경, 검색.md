---
type: study
source:
  - real-my-sql
tags:
  - 데이터베이스
  - cs
created: 2025-05-28
---

### Relevace Framing 🧩

**`부모 글` : [[B-Tree 인덱스]]**

# 0. 학습 목적

- 인덱스에서의 `KEY` 추가, 삭제, 변경 과정을 이해해서 쿼리 성능 예측을 더 쉽게 하기 위해
- 인덱스 사용하면서 주의할 점 체크 

# 1. 인덱스 키 추가

(1) 저장될 `KEY` 값이 B-tree 내의 어느 위치에 있어야 적절한지 위치 검색
(2) 저장될 위치 결정 후, 레코드의 Key값과 대상 레코드의 실제 데이터 주소 정보를 리프노드에 저장 

(3) 혹시, 리프노드가 꽉 찼다면, 리프노드 분리가 필요함. 이때는 대공사가 되어서 처리 범위가 상위 브랜치노드까지 커질 수 있다. 

### A. 비용은 얼마나 될까? 

위와 같은 작업 덕분에 인덱스 키 추가 작업은 비용이 많이 드는 것으로 알려짐. 

정확히 얼마나 비용이 드는지는, 테이블의 칼럼 수, 칼럼의 크기, 인덱스 칼럼의 특성에 따라 천차만별이지만, 대략적으로 계산한다면, 레코드 추가 작업 비용을 `1`이라고 치면, **인덱스 추가 작업 비용은 1.5 정도로 예측**하면 된다.

ex) B-tree 인덱스가 3개 존재하는 테이블에 값을 삽입한다고 치면, 인덱스가 하나도 없을 경우 비용이 1 이라면, 이 경우는 5.5가 든다. ($1 + 1.5 * 3$ )

### B. 비용은 뭐 때문에 들까?

인덱스 키 추가 작업 비용의 대부분은 디스크 I/O 비용이다. (디스크로부터 인덱스 페이지 읽어서 쓰고 다시 저장) 
메모리나 CPU 비용은 그리 높지않다.

### C. 스토리지 엔진 별 인덱스 키 추가 시점

- MyISAM이나 MEMORY 엔진의 경우, 인덱스 키 추가는 INSERT 문장 실행 시 즉시 삽입
- InnoDB는 체인지 버퍼를 활용하여 지연처리가 가능하긴 하지만, PK 혹은 유니크 인덱스를 위한 데이터 중복 체크가 필요해서, INSERT 즉시 B-tree에 추가한다.

# 2. 인덱스 키 삭제

(1) 삭제하려는 키가 저장된 리프노드를 찾는다.
(2) 해당 리프노드 속 삭제하려는 키에 `삭제 마킹`을 해놓는다. (삭제 작업 완료) 
(3) 삭제 마킹된 키는 방치해도 되고, 재활용해도 된다. 

### A. 인덱스 키 추가와 특성이 동일

이것도 디스크 I/O가 비용의 주된 원인이고, InnoDB에는 체인지 버퍼를 통해 지연처리가 될 수 있다. 
(MySQL 내부적으로 지연처리 여부와 실행을 결정하므로, 사용자는 모르고, 이것 때문에 악영향을 받지도 않음) 

# 3. 인덱스 키 변경

(1) 기존 인덱스 삭제 ( 인덱스 키 삭제 과정 그대로)
(2) 변경된 인덱스 추가 (인덱스 키 추가 과정 그대로) 
(3) 변경 작업 자체도 InnoDB에는 체인지 버퍼로 지연 처리 가능

# 4. 인덱스 키 검색  ⭐

위의 단순한 데이터 삽입보다 시간이 오래 걸리는 인덱스 추가 삭제 작업을 굳이 한 이유는 바로 **월등한 인덱스 키 검색 성능**을 위해서다. 

-  인덱스 키 검색은 **`트리 탐색`** 이라 불리는 루트 노드부터 리프 노드까지 반복적 비교 작업으로 이루어진다.
- 인덱스 키 검색은 단순히 `SELECT`에서만 이루어지는 것이 아니라, 당연하게도 `UPDATE`, `DELETE` 작업에서도 이루어진다.

이제부터 B-tree가 활용되는 검색과 B-tree가 활용될 수 없는 검색을 나누어, 설명하고자 한다. 
(B-tree 검색을 정확히 활용할 수 있기 위하여)

## (1) B-tree가 활용되는 검색

### A. 100% 일치 검색

```sql
-- name으로 인덱스 생성된 경우
WHERE name = '김철수'
```

```sql
-- id로 인덱스 생성된 경우
where id = 25
```

### B. 인덱스 키의 앞부분만 활용한 검색

```sql
-- name과 email로 index가 생성되었음을 가정

WHERE name LIKE '김%'
WHERE email LIKE 'admin@%'
```

> 왜 인덱스가 적용될까?  

인덱스는 정렬된 값임을 기억하자.  따라서 이름은 사전 순으로 정렬되어 인덱스에 저장되어 있다.

```bash 
김가영 → 김나영 → 김다영 → 김철수 → 박가영 → 박나영 → 이가영
```

따라서 인덱스의 앞부분만 활용하면 **`Range 검색`** 이 된다.
위의 예시를 통해 설명하면 

- 시작점 찾기: 김으로 시작하는 첫 번째 위치를 트리 탐색으로 찾는다.
- 끝점까지 순차 읽기: '김가영' → '김나영' → '김다영' → '김철수'
- 중단 조건: 박가영을 만나면 김이 아니므로 중단 

### C. 범위 비교

> 이는 인덱스 컬럼에 변형을 주지 않아야 한다는 가정이 선행된다. (이유는 뒤에서 설명)

```sql
WHERE age >= 25
WHERE salary < 5000000
```

```sql
WHERE age BETWEEN 20 AND 30
WHERE created_date BETWEEN '2024-01-01' AND '2024-12-31'
```

## (2) B-tree가 활용되지 않는 검색

### A. 인덱스 키의 뒷부분만 활용한 검색 

인덱스 키의 뒷부분만 활용한 검색은 왜 인덱스 활용이 안되는지 살펴보자. 

```bash 
김가영 → 김나영 → 김다영 → 김철수 → 박가영 → 박나영 → 이가영
```
위와 같이 name으로 B-tree 인덱스를 만들었다고 가정해보자. 그리고 우리가 원하는 sql문은 다음과 같다.

```sql
WHERE name LIKE '%영'
```

- '김나영', '박가영', '이가영'이 흝어져 저장되어 있다. 
- B-tree에서는 연속된 위치에 있지 않아서 어짜피 점프 뛰며 찾아야 한다. 
- 결국 전체 스캔이랑 다를바가 없다.

### B. 변형된 인덱스 키 컬럼 값을 활용한 비교 검색 

인덱스 키 컬럼 값을 변형해서 비교해도 인덱스 활용을 못한다.
그 이유는 **키 값이 변형되었을 때, 조건을 만족시키는지 확인해야 하기에 어짜피 모든 키 값을 변형해야 한다.**

```bash
'Apple' → 'Banana' → 'Cherry' → 'apple' → 'banana' → 'cherry'
```

name을 key로 가지는 인덱스 b-tree가 위와 같이 이루어져 있다고 했을 때, 

```sql
WHERE UPPER(name) = 'APPLE'
```

이것을 찾는다면, 어짜피 모든 name을 UPPER CASE로 바꿔봐야 한다. 따라서 인덱스가 활용될 수 없다.

```sql 
WHERE age + 10 > 35
```

이건 수학적 연산에서도 마찬가지이다.

# 핵심 요약

- 인덱스 키 추가는 신규 키가 저장되어야 할 리프노드 검색, 해당 리프노드에 키 추가 ( 노드가 가득차면리프노드 분리 작업 필요)
- 인덱스 키 삭제는 삭제되어야할 키에 삭제 마킹을 달아두면 완료 
- 인덱스 키 변경은 삭제 -> 추가 작업을 동시에 하는 것
  
- 위의 작업은 모두 InnoDB에서 체인지 버퍼로 지연처리가 가능
- 인덱스 키 검색의 빠른 성능 위의 오래 걸리는 인덱스 키 추가, 삭제를 한 이유 
- 근데, 인덱스 키 검색이 활용되는 것과 안되는 것이 있으니 주의 바람
	- 활용되는 것: 컬럼 변형 없는 순수 비교, 100% 일치 검색, 키의 앞부분 활용 검색
	- 활용 안되는 것: 컬럼 변형한 비교, 키 뒷부분 활용 검색

---

# Metadata

### A. 모르는 단어 정리 to Layman's term

- `트리 탐색` : B-tree의 루트 노드부터 브랜치 노드를 거쳐 최종 리프 노드까지 원하는 값을 찾기 위해 비교 작업을 수행하는 과정

###  B. 참고 문서

### C. 자식 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
