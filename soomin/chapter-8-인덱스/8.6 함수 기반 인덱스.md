---
tags:
  - 데이터베이스
  - cs
parent: "[[인덱스]]"
related: 
created: 2025-06-06
---

# 0. 학습 목적
- 함수 기반 인덱스가 필요한 이유를 안다.

# 1. 함수 기반 인덱스란?
기존에 존재하는 컬럼 값을 함수식을 이용하여 변형한 뒤, 그 변형된 값으로 만든 인덱스를 뜻한다.

# 2. 함수 기반 인덱스의 필요성? 
1. 변형된 컬럼 값은 원본 컬럼 기반 인덱스를 활용하지 못하기 때문에
2. 데이터 정합성을 위하여

## (1) 변형된 컬럼 값은 원본 컬럼 기반 인덱스 활용 못함
```sql
select *
from user
where LOWER(email) = 'test@gmail.com'
```

위의 식은 email로 index가 생성되어 있더라도 그 인덱스를 활용하지 못한다. 왜냐하면 옵티마이저가 email로 정렬된 인덱스 값이라도 소문자로 바꿨을 때  그 값이 어떻게 될 지 예측하지 못하기 때문에 모든 값을 다 바꿔봐야 하기 때문이다. 따라서 위와 같은 식은 email로 index가 생성되었어도 `table full scan`을 탈 것이다. 
반면 user 테이블에 다음과 같이 index를 만들면
```sql
CREATE INDEX idx_lower_email ON user (LOWER(email))
```

모두 소문자로 강제 변환된 값으로 만들어진 index가 있으므로, 위와 같은 조회문이 들어올 시 해당 index를 활용할 수 있을 것이다.

## (2) 데이터 정합성을 위해
```sql
CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10)
)
```

다음과 같이 있다고 하자. 근데, 고객의 요구사항 중 하나가 *'full-name으로 검색을 빠르게 하고 싶어요'*라고 해보자. 

다음과 같이 만들 수도 있을 것이다.
```sql
-- 신규 컬럼 full_name 삽입
ALTER TABLE user ADD COLUMN full_name VARCHAR(255);

-- full_name을 기존의 first_name 과 last_name으로 업데이트
UPDATE user set full_name = CONCAT_WS('', first_name, last_name);
```

하지만 이는 다음과 같은 부작용을 낫는다. 
- 성 + 이름과 풀네임 관리가 따로 되기 때문에 매번 동기화를 수동으로 해야함.
- trigger를 쓰더라도, 해당 trigger 함수가 외부에 있기 때문에 관리할 곳이 2 곳으로 나누어짐.

이에 따라 데이터 동기화와 전체 아키텍쳐 유지보수를 하며 신경 써야 할 부분이 많이 생긴다. 반면 위의 full_name을 함수 기반 인덱스로 설정한다면, 

```sql
ALTER TABLE user
ADD full_name VARCHAR(30) AS CONCAT(first_name + ' ' + last_name) VIRTUAL,
ADD INDEX ix_fullname (full_name);
```

해당 테이블에 가상 컬럼을 만들어주고, 그것을 인덱스로 잡았다. 
이 경우, 성과 이름을 넣으면 풀네임이 자동으로 동기화되며, 함수 또한 테이블 안에 있어서 유지보수 해야할 곳이 하나로 줄게된다ㅏ. 

# 핵심 요약
- 가상 컬럼 인덱스는 기본 컬럼 값을 변형하여 만들어진 값으로 만든 인덱스를 뜻한다.
- 이것이 필요한 이유는 다음과 같다.
	- 1. 변형된 컬럼에 대해서는 인덱스를 활용하지 못하기 때문
	- 2. 데이터의 정합성과 유지보수를 수월히 하기 위함.

---

# Metadata

### A. 모르는 단어 정리 to Layman's term

###  B. 참고 문서

### C. 자식 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
