# 0. 학습 목적
- 모든 b-tree 인덱스 기반 데이터 읽기들의 원리를 이해한다.

# 0. 가정
우리는 **`InnoDB`를 활용하는 상황을 가정**한다. 
InnoDB는 데이터를 기본적으로 [[클러스터링 인덱스]] 형식으로 저장한다. InnoDB에서 테이블의 기본 저장 형식과 추가적인 인덱스가 있을 경우를 그림으로 나타내면 다음과 같다.

### (1) 테이블 명세
```sql
CREATE TABLE employees (
    emp_no INT UNSIGNED NOT NULL,
    username VARCHAR(50) NOT NULL,
    hire_date DATETIME,
    position VARCHAR(50),
    department VARCHAR(50),
    email VARCHAR(100),
    -- Primary Key (Clustered Index in InnoDB)
    PRIMARY KEY (emp_no),
    -- Secondary Index
    INDEX idx_hire_date (hire_date)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

```

### (2) 전개도
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250624143501.png)

# 1. 테이블 풀 스캔 (Table full scan)
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250624143631.png)

어떠한 보조 인덱스도 사용하지 않고 바로 본 테이블 (innoDB에서는 클러스터링 인덱스)로 접근하여 모든 데이터를 읽는 방식

## (1) `Table full scan`이 활용되는 상황
다음과 같은 상황에서는 인덱스를 활용하기보단 테이블 전체를 읽는 것이 오히려 빠를 수 있다.

1. **테이블 전체 레코드 건 수가 작을 경우**
2. **WHERE 나 ON 등 조건문에 인덱스가 활용될 수 있는 조건이 없을 경우**
3. **조건문에 인덱스 활용 가능한 조건이 있으나, 옵티마이저가 예측했을 때, 조건 일치 레코드 건수가 너무 많아서, 오히려 인덱스 활용 검색이 느린 경우,**

# 2. 인덱스 풀 스캔 (Index full scan)
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250624163938.png)

테이블의 특정 보조 인덱스를 접근하여 처음부터 끝까지 데이터를 읽지만, 본 테이블(클러스터형 인덱스)은 참조하지 않는 방식

## (1) 예시
쿼리문이 **`보조 인덱스` 의 전체 리프노드를 읽으면, 클러스터링 인덱스를 가지 않아도,** 질의문을 충족시킬 수 있는 경우 **`index full scan`** 을 선택

1. 질의문이 원하는 모든 조건을 만족시키는 커버링 인덱스가 있다. 
2. 질의문이 `SELECT count(*) from users` 인 경우, 인덱스 풀 스캔을 타서, 보조 인덱스의 리프노드 개수만 세면 된다.

### A. InnoDB는 기본적으로 클러스터링 테이블 형태로 데이터 저장하는데, 보조 인덱스를 쓰나, 클러스터링 인덱스를 쓰나 성능적 차이 없는 거 아닐까?
**NO! 차이 있음**
- 보조 인덱스는 컬럼의 일부만 리프노드에 저장하므로, 전체 데이터 용량이 같은 클러스터링 인덱스에 비해 작다.
- 따라서 보조 인덱스를 써서 탐색할 경우, 봐야할 페이지 수가 작고, 이는 디스크 읽기 횟수를 줄인다.

# 3. 인덱스 레인지 스캔 (Index range scan)
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250624170029.png)

다음과 같은 이루어지는 읽기 방식을 말한다.

1. 보조 인덱스에서 필요한 범위만큼 리프 노드를 순차 접근 (보조 인덱스는 B+Tree라서 순차 접근이 가능함)
2. 각 리프노드 별로 PK를 활용해 그것이 가리키는 실제 데이터를 클러스터링 인덱스에서 랜덤 접근 후 가져온다.

(만약 보조 인덱스가 사용자의 요구를 모두 받아낼 수 있는 커버링 인덱스이면 1번에서 끝남. 
이 경우 범위가 짧은 `index full scan` 과 같아서, 성능이 더 빨라짐.)

## (1) 활용 예시 
1. 사용자가 원하는 질의문이 `Between` 이나 `부등호 식`을 활용하면 범위 검색이고, 그 범위 검색에 해당하는 인덱스가 존재할 경우

# 4. 루스 인덱스 스캔 (loose Index scan)
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250624170730.png)

> 그림에서 형광펜으로 'x' 표 되어있는 것은 본 테이블 안 가도 되는 리프노드들이다.

다음과 같이 이루어지는 읽기 방식을 뜻한다.

1. 보조 인덱스의 특정 범위 리프노드를 순차 READ 한다. (여기까진 index range scan과 동일)
2. 읽어들인 모든 리프노드에 대해 본 데이터 읽기를 하지 않고, **특정 요건을 충족한 리프노드를 한정하여 PK를 활용한 실 데이터 접근 및 가져오기를 시행**한다.

## (1) 사용 예시
- 보조 인덱스에서 실 데이터 접근이 필요한 PK, 아닌 PK 구분이 가능한 경우
  (`GROUP BY`, `MAX`, `MIN` 활용 시 사용 - 더 자세하게 알게되면 후술하겠음)

# 5. 인덱스 스킵 스캔 (Index skip scan)
**특정 조건을 만족한 경우**, 복합 컬럼 인덱스의 왼쪽 멤버부터 순차적으로 조건문에 활용하지 않더라도, 인덱스 활용이 가능한데, 이 경우를 인덱스 스킵 스캔이라 한다. 

## (1) 복합 컬럼 인덱스가 활용되지 않는 경우
복합 컬럼 인덱스가 존재해도 이것이 전혀 쓰이지 않는 쿼리문이 무엇이였는지 복습해보자. 

복합컬럼 인덱스는 인덱스 멤버 중 제일 왼쪽 컬럼을 기준으로 B+tree가 짜여진다. 왼쪽 컬럼 값이 같은 리프노드 간의 순서는 두 번째 멤버 컬럼 값을 활용해 정하고, 여기서도 판가름이 안나면 세 번째 컬럼 값을 활용해 정한다. 이와 같은 이유 떄문에, **복합 컬럼 인덱스의 왼쪽 멤버부터 순차적으로 조건을 걸지 않은 조건문에 대해서는 복합컬럼 인덱스 활용이 안된다.**

**예시**
  사원에 대해 (성별, 고용일) 복합 인덱스가 있다고 가정해보자.
```sql
-- 예제 1 (조건문을 순차 적용했을 시, 보조 인덱스로도 범위 특정 가능 - 복합 인덱스 활용)
select * from employees
	where gender is "M"
 AND hire_date >= '2022-04-18'

-- 예제 2 (조건문의 내용만 가지고는 복합 인덱스에서 범위 특정 불가 - 풀 스캔 탐)
select * from employees
where hire_date >= '2022-04-18'
```

**예제 1번의 경우,**
![image.png](https://raw.githubusercontent.com/dalcheonroadhead/img-cloud/main/2025-06/20250624222822.png)
성별이 M인 리프노드 범위가 먼저 확정 가능하다. 이후 해당 노드들 중에서 고용일이 2022년 4월 18일 이후인 녀석들을 다시 찾으면 된다. 
예제 1에서 복합 컬럼 인덱스를 활용할 수 있는 이유는 왼쪽 멤버부터 조건 필터링을 했기 때문에 복합 컬럼 인덱스의 정렬 순서와 일치하여 필요로 하는 값들의 위치를 예측할 수 있기 때문이다. 

**예제 2번의 경우**
인덱스의 첫 번째 멤버에 대한 정보를 알 수 없으므로, 값의 위치를 특정할 수 없다. 따라서, 인덱스를 만약에 활용하더라도 리프노드를 처음부터 쭉 읽어야 한다. 그럴 바에 그냥 테이블 풀 스캔 때리는 게 낫다.

## (2) 예제 2에서 복합 컬럼 인덱스를 활용하는 방법
1. 인덱스의 제일 왼쪽 변수에서 나올 수 있는 모든 경우를 조건 필터링으로 넣은 쿼리문을 만든다.
2. 이렇게 되면 각 쿼리문은 모두 복합 컬럼 인덱스를 활용할 수 있는 쿼리문이 되었다. 이 들을 각각 계산한 후에 합친다. 

### A. 예시
2번을 예로 들어보면,
```sql
select * from employees
where 
hire_date >= '2022-04-18'
```

여기서는 첫 번째 멤버인 성별에서 나올 수 있는 모든 경우의 수 별로 쿼리문을 짠다.
```sql
select * from employees
where
gender = 'M'
and hire_date >= '2022-04-18'
```

```sql
select * from employees
where
gender = 'W'
and hire_date >= '2022-04-18'
```

이렇게 되면, 각 쿼리문 별로 인덱스를 활용할 수 있다. 해당 결과를 하나의 결과 VIEW 합치기만 하면 된다.

## (3) 옵티마이저가 인덱스 스킵을 고려하는 기준
1. **생략된 복합 컬럼 인덱스의 왼쪽 멤버 컬럼의 카디널리티가 낮아야 한다.** 
   카디널리티가 높을수록, 짜야하는 쿼리문 경우가 늘어나게 되고, 어느 임계치를 넘어가면, Table full scan 타느니만 못하게 되기 때문이다.
   
2. **커버링 인덱스여야 한다.**
   커버링 인덱스가 아니면 다시 원본 클러스터링 인덱스를 다시 타야 하는데, *쿼리문 경우의 수 별로 짜기* + *클러스터링 랜덤 접근* 을 다 할거면 이는 table full scan 타느니만 못하게 된다. 

# 6. 최종 요약
- B-Tree 기반 데이터 읽기 종류에는 테이블 풀 스캔, 인덱스 풀 스캔, 인덱스 레인지 스캔, 인덱스 루즈 스캔, 인덱스 스킵 스캔이 있다.
	- `테이블 풀 스캔`은 보조 인덱스 다 건너뛰고 클러스터형 인덱스의 리프노드를 전부 읽는 방식이다.
	- `인덱스 풀 스캔`은 보조 인덱스의 리프노드를 전부 읽는 방식이다. (클러스터형 재 탐색 안함) 
	- `인덱스 레인지 스캔`은 보조 인덱스 특정 범위의 리프노드 순차 리드 -> 각 리프노드 별로 클러스형 랜덤 접근 후 데이터를 가져오는 방식이다. 
	- `인덱스 루스 스캔`은 인덱스 레인지와 큰 틀은 같으나, 보조 인덱스의 모든 리프노드에 대해 본 테이블 재 탐색 과정을 진행하지 않고, 질의문상 필요한 리프노드만 재 탐색한다.
	- `인덱스 스킵 스캔`은 복합 컬럼 인덱스를 그것의 왼쪽 멤버 컬럼부터 필터링 안 했을 떄도 사용하는 방법으로 누락된 멤버 컬럼에서 나올 수 있는 모든 경우의 수 별로  쿼리를 나누어, *복합 컬럼을 쓸 수 있는 상태*로 만들어 다 인덱스 써서 구하고 결과값들을 합치는 방식이다.

---

# Metadata

### A. 모르는 단어 정리 
- `카디널리티 (Cardinality)`
  : 특정 데이터 집합에서 유니크(unique)한 값의 개수 
  
  ex) 회원 테이블의 성별 컬럼이 남(M), 여(F)로만 나뉠 경우, 해당 컬럼의 Cardinality는 2이다.
  회원 테이블에서 주민번호 컬럼이 있을 경우, 해당 컬럼의 Cardinality는 레코드의 수만큼이다. 

- `선택도 (Selectivity)`
  :

$$
 선택도 \; (Selectivity) = \frac{카디널리티\; (Cardinality)}{전체\;레코드\; 수} 
$$

  특정 카디널리티를 가진 데이터 집합을 조건으로 걸면, 얼마나 많은 데이터를 거를 수 있는지 확인하기 위한 지표

###  B. 참고 문서
- [MySQL 공식문서: full table scan 피하기](https://dev.mysql.com/doc/refman/8.4/en/table-scan-avoidance.html)
- [옵티마이저의 영구 통계 파라미터 설정하기](https://dev.mysql.com/doc/refman/8.4/en/innodb-persistent-stats.html)
- [ 옵티마이저의 임시 통계 파라미터 설정하기](https://dev.mysql.com/doc/refman/8.4/en/innodb-statistics-estimation.html)
- [MySQL에서 데이터를 scan하는 대표적인 방법들 (feat. InnoDB 클러스터링 인덱스)](https://jofestudio.tistory.com/127)

