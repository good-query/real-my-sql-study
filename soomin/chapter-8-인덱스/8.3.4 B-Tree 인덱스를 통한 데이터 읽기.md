---
type: study
source:
  - real-my-sql
tags:
  - 데이터베이스
  - cs
created: 2025-05-28
---

### Relevace Framing 🧩

**`부모 글` : [[B-Tree 인덱스]]**

# 0. 학습 목적

- MySQL이 어떻게 인덱스를 경유해서 필요한 데이터를 읽는지 확실히 이해한다.
- 이를 이해해야지만 어떤 경우에 옵티마이저의 index 활용을 유도할지, 유도하지 않을지 판단할 수 있다.

# 1. 인덱스 레인지 스캔 (Index Range Scan)

## (1) 동작 과정

#### 1단계: Index Seek (인덱스 탐색)

- **루트 노드 접근**: 검색 조건값으로 B-Tree 루트에서 탐색 시작
- **브랜치 노드 탐색**: 조건에 맞는 방향으로 트리를 내려감
- **리프 노드 도달**: 시작 조건에 해당하는 리프 노드 위치 식별

#### 2단계: Index Scan (인덱스 스캔)

- **시작 지점 확인**: 리프 노드에서 조건에 맞는 첫 번째 키값 찾기
- **순차 스캔**: 리프 노드의 Linked List를 따라 끝 조건까지 순차 읽기
- **페이지 이동**: 현재 리프 페이지 끝에 도달하면 다음 리프 페이지로 이동

#### 3단계: 레코드 읽기

- **포인터 활용**: 각 인덱스 키의 레코드 주소(포인터)로 데이터 페이지 접근
- **실제 레코드 읽기**: 데이터 페이지에서 최종 레코드 읽어오기

### I/O 패턴 및 성능 특성

```java
인덱스 접근: 랜덤 I/O (탐색) + 순차 I/O (스캔)
데이터 접근: 랜덤 I/O (레코드 한 건당)
성능 임계점: 전체 테이블의 20-25% 이상 읽으면 테이블 풀 스캔이 더 효율적
```

### 실행 계획 확인

```sql
EXPLAIN SELECT * FROM employees
WHERE first_name BETWEEN 'Ebbe' AND 'Gad';

-- type: range 로 표시됨
```

### 예시 쿼리

```sql
-- 인덱스: ix_firstname (first_name)
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';

-- 과정: first_name='Ebbe' 탐색 → 'Gad'까지 리프노드 순회 → 각 레코드 랜덤 I/O
```

---

## 2. 인덱스 풀 스캔 (Index Full Scan)

### 동작 과정

#### 1단계: 시작점 접근

- **최소값 리프 노드**: B-Tree의 가장 왼쪽 리프 노드부터 시작

#### 2단계: 전체 인덱스 순회

- **연속 스캔**: 모든 리프 노드를 연결 리스트를 따라 끝까지 순회
- **조건 처리**: 인덱스 레벨에서 필터링 및 정렬 수행

#### 3단계: 선택적 데이터 접근

- **커버링 인덱스**: 인덱스만으로 쿼리 처리 시 데이터 페이지 접근 생략
- **일반 경우**: 필요시에만 데이터 페이지 접근

### 사용 조건

- 쿼리 조건절이 **인덱스의 첫 번째 컬럼이 아닌 경우**
- **커버링 인덱스 상황**에서만 효율적 사용
- 인덱스 + 데이터 레코드를 모두 읽어야 하면 사용되지 않음

### I/O 패턴

```java
인덱스 접근: 순차 I/O 위주 (전체 리프 노드 순회)
데이터 접근: 커버링 인덱스면 없음, 아니면 랜덤 I/O
성능: 테이블 풀 스캔 > 인덱스 풀 스캔 > 인덱스 레인지 스캔
```

### 실행 계획 확인

```sql
-- 인덱스: ix_name_country_phone (name, country, phone)
EXPLAIN SELECT phone FROM employee WHERE country = 'South Korea';

-- type: index (인덱스 풀 스캔)
-- Extra: Using index (커버링 인덱스)
```

### 예시 쿼리

```sql
-- 커버링 인덱스 예시
SELECT first_name, last_name FROM employees ORDER BY first_name;

-- 비효율적인 경우 (테이블 풀 스캔으로 전환)
SELECT gender FROM employee WHERE country = 'South Korea'; -- type: ALL
```

---

## 3. 루스 인덱스 스캔 (Loose Index Scan)

### 동작 과정

#### 1단계: 그룹 키 탐색

- **첫 번째 그룹**: 복합 인덱스에서 각 그룹의 첫 번째 값 찾기

#### 2단계: 집계 처리

- **집합 함수 적용**: MIN, MAX, COUNT 등 필요한 연산 수행
- **그룹별 최적화**: 해당 그룹에서 필요한 값만 추출

#### 3단계: SKIP 이동

- **불필요한 레코드 건너뛰기**: 현재 그룹의 나머지 레코드들 생략
- **다음 그룹으로 점프**: 다음 그룹의 첫 번째 키로 직접 이동

#### 4단계: 반복

- **모든 그룹 처리**: 전체 그룹을 처리할 때까지 2-3단계 반복

### 최적화 대상

- **GROUP BY + 집합함수** 조합
- **MIN(), MAX()** 함수 최적화
- **DISTINCT** 처리

### I/O 패턴

```java
인덱스 접근: 랜덤 I/O (그룹별 점프로 불연속 접근)
데이터 접근: 집계 함수 특성상 대부분 불필요
성능: 효율적 (필요한 레코드만 선택적 접근)
```

### 실행 계획 확인

```sql
-- 인덱스: ix_dep_no_emp_no (dep_no, emp_no)
EXPLAIN SELECT dep_no, MIN(emp_no) FROM employee
WHERE dep_no BETWEEN 2 AND 4 GROUP BY dep_no;

-- type: range
-- Extra: Using index for group-by (루스 인덱스 스캔 적용)
```

### 예시 쿼리

```sql
SELECT dept_no, MIN(emp_no) FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;

-- 각 dept_no별로 첫 번째 emp_no만 읽고 나머지는 SKIP
```

---

## 4. 인덱스 스킵 스캔 (Index Skip Scan)

### 동작 과정 (MySQL 8.0+ 이상에만 존재!)

#### 1단계: 선행 컬럼 분석

- **통계 정보 조회**: 복합 인덱스 첫 번째 컬럼의 고유값들 파악
- **유니크 값 확인**: 선행 컬럼이 가질 수 있는 모든 값 식별

#### 2단계: 가상 쿼리 생성

- **조건 추가**: 각 고유값별로 선행 컬럼 조건을 쿼리에 추가
- **개별 쿼리 변환**: 하나의 쿼리를 여러 개의 개별 쿼리로 분할

#### 3단계: 개별 레인지 스캔

- **병렬 처리**: 생성된 각 조건으로 별도의 레인지 스캔 실행
- **최적화된 접근**: 각 스캔이 인덱스 레인지 스캔으로 효율적 처리

#### 4단계: 결과 병합

- **UNION 처리**: 각 스캔 결과를 합쳐서 최종 결과 생성

### 제약 조건 (중요!) ⭐

#### 1. 선행 컬럼 고유값 제한

```sql
-- 좋은 예: gender (M, F 두 값만 존재)
SELECT gender, birth_date FROM employees WHERE birth_date > '1998-01-01';

-- 나쁜 예: emp_no (수천, 수만 개의 고유값)
SELECT emp_no FROM employee WHERE birth_date > '1998-01-01';
```

#### 2. 커버링 인덱스 필수

```sql
-- 가능: 인덱스 컬럼만 사용
SELECT gender FROM employee WHERE birth_date > '1998-01-01';

-- 불가능: 인덱스에 없는 컬럼 사용
SELECT phone FROM employee WHERE birth_date > '1998-01-01'; -- type: ALL
```

### I/O 패턴

```java
인덱스 접근: 랜덤 I/O (여러 시작점에서 개별 스캔)
데이터 접근: 커버링 인덱스가 아니면 랜덤 I/O
성능: 선행 컬럼 고유값 개수에 따라 변동
```

### 실행 계획 확인

```sql
-- 인덱스: ix_gender_birthdate (gender, birth_date)
EXPLAIN SELECT gender FROM employee WHERE birth_date > '1998-01-01';

-- Extra: Using index for skip scan (스킵 스캔 적용)
```

### 내부 최적화 예시

```sql
-- 원본 쿼리
SELECT gender FROM employee WHERE birth_date > '1998-01-01';

-- MySQL 8.0 내부 최적화 후
SELECT gender FROM employee WHERE gender='M' AND birth_date > '1998-01-01'
UNION ALL
SELECT gender FROM employee WHERE gender='F' AND birth_date > '1998-01-01';
```

---

# 핵심 요약

MySQL B-Tree 인덱스의 각 스캔 방식은 쿼리 패턴과 데이터 특성에 따라 자동으로 선택됩니다. 효율적인 쿼리 성능을 위해서는:

1. **커버링 인덱스** 적극 활용
2. **랜덤 I/O 최소화**를 위한 인덱스 설계
3. **작업 범위 결정 조건**을 최대한 많이 포함
4. **실행 계획 분석**을 통한 지속적인 최적화

이를 통해 MySQL 데이터베이스의 쿼리 성능을 극대화할 수 있습니다.

---

# Metadata

### A. 모르는 단어 정리 to Layman's term

### B. 참고 문서

### C. 자식 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
