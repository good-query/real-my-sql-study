---
tags:
  - 데이터베이스
  - cs
parent: "[[유니크 인덱스]]"
related: 
created: 2025-06-17
---

# 0. 학습 목적
- 유니크 인덱스와 유니크 하지 않은 인덱스의 읽기, 쓰기 성능 차이를 확인하자. 

> [!question] Q. 둘은 구조상 차이가 있는가? 
> - 없음. 둘 다 B-tree 구조로 동일

# 1. 인덱스 읽기 관점에서의 성능 차이
**`결론`: 성능차이 없다시피 함**

- 두 인덱스는 구조 상 동일
- 성능 차이가 벌어지는 지점은 유니크 인덱스가 레코드 한 건 읽으면 될 것을 비 유니크 인덱스는 키 컬럼 값이 중복된 레코드를 다 읽어서 비교 후, 원하는 레코드를 찾아야 한다는 것임
- 위의 과정에서 시간 차이가 많이 날 것 같지만, 중복된 레코드 읽어서 비교는 CPU에서 맡아 하는 작업이라 성능에 영향을 거의 주지 않는다. (CPU는 컴퓨터 내에서 가장 빠른 부분, 거의 0.1초 vs 0.2 초 수준)

# 2. 인덱스 쓰기 관점에서의 성능 차이
**`결론`: 유니크 인덱스가 쓰기에서 비교적 느리다.**

`이유`:  유니크라는 특성을 지키기 위해, 매번 데이터 삽입 전에  테이블 전체 읽으며 **그와 중복된 데이터는 없는지 확인 해야함.**

## (1) 쓰기 동작 과정 
1. 레코드 단위 S-Lock을 걸며 쓰려는 데이터와 중복되는 데이터 있는지 확인
2. 원하는 값을 삽입, 삭제, 변경한다.
	- 삽입의 경우: 새로운 레코드를 생성하고 거기에 X-Lock을 건다.
	- 변경, 삭제의 경우: 작업해야할 레코드에 X-Lock 걸고, 작업 시작

## (2) 유니크 인덱스 쓰기 시, 중복 여부 확인으로 인한 파급 효과
1. 데드락 발생 확률이 높아진다. 
   : 위에서 살펴 보았듯이, 선 읽기 SLOCK, 후 쓰기 X-LOCK이 필요함. 
   이때 각 트랜잭션이 서로가 S-Lock 걸고 있는 대상에 대해 X-Lock을 걸려고 대기하는 상황이 벌어지면 데드락이 발생한다.
   
2. 체인지 버퍼를 활용하지 못한다.
   : 랜덤 접근이 많은 인덱스 쓰기 작업을 효율적으로 하기 위해 innoDB에서는 체인지버퍼에 변경,신규 인덱스를 모아놓고, 지연 일괄 쓰기를 한다.
   하지만 유니크 인덱스의 경우, 실시간 중복 여부 확인이 필수라서 이 `체인지 버퍼`를 활용하지 못한다.

# 3. 핵심 요약
- 유니크 인덱스와 비유니크 인덱스는 읽기 관점에서 성능차이가 미비하다.
- 쓰기 관점에서는 유니크 인덱스가 쓰기 전 중복 여부 체크 과정이 필요하기에 비 유니크 인덱스보다 느리다.

---

# Metadata

### A. 모르는 단어 정리 
- `데드락`
  : 서로가 서로에게 필요한 자원을 점유하며, 남의 것을 원하는 상태
	- 엄마: 숙제 안하면 밥 안 줄거야.
	- 아들: 밥 안 주면 숙제 안 할거야.
	(서로 밥과 숙제를 점유하며 상대방 것을 원하고 있음) 

###  B. 참고 문서

### C. 관련 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
