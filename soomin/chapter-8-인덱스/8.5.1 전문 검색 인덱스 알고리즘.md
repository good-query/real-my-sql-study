---
tags:
  - cs
  - 데이터베이스
parent: "[[전문 검색 인덱스]]"
related: 
created: 2025-06-04
---

# 0. 학습 목적
- 전문 검색 인덱스의 대략적인 작동 원리를 파악한다.
- 한 번에 모든 것을 알려고 하지 않는다.

# 1. 어근 분석 알고리즘
**형태소 단위**로 글자 분해 해서, 유효한 단어들만 인덱싱 -> 추후 전문 검색에 활용

## (0) 알고리즘의 언어 별 차이
어근 분석 알고리즘은 영어와 한국어에서 서로 다르게 작동한다. 
영어는 Stemming(뿌리, 원형)이 존재한다. 즉 running, runner, ran 등의 Stemming은 'run' 이다.

반면 한국어는 파생된 단어를 만들 때, 원형 단어 자체에서 변형을 줘서 만들지 않는다. 대신 다른 '형태소'를 조합해서 만든다. 
(ex - 개발 -> 개발자 (개발 + 자(person)), 개발했다. (개발 + 했다.(과거시제)))

따라서 같은 어근 분석 알고리즘이라도, 언어에 따라 그 내부 작동 원리가 다름을 인지하자.
뒤에 제시될 설명에서도 영어 중심의 '어근' 보다, 한국어 중심의 '형태소'로 설명하겠다.

## (1) MySQL에서 어근 분석 알고리즘 세팅 

- `mecab`
- `언어에 대한 사전`
- `활용 예시에 대한 샘플`

MySQL에 내장된 어근 분석 알고리즘은 없다. 따라서 **`meCab`** 이라는 플러그인을 깔아서 어근 분석 알고리즘을 세팅해야한다.
플러그인을 까는 것에서 끝나면 안되고, meCab이 문장에 대한 형태소 분석 시 기준 삼을 수 있게, `단어 사전`도 세팅 해줘야 한다.
마지막으로, meCab이 실제 문장을 해체해서, 품사 별로 문장 구조를 인식할 수 있도록 `활용 예시에 대한 샘플`을 전해줘야 하며, 이를 이용해 해당 언어를 학습시키는 과정도 필요하다.

## (2) 어근 분석 알고리즘 활용 인덱싱의 과정

1. 형태소 단위로 글을 나누기
2. 불용어 제거
3. 살아남은 녀석들만 인덱싱 

### 1. 형태소 단위로 글을 나누기 
"개발자들이었습니다" 라는 문장이 들어오면:

- Step 1: 사전에서 가능한 모든 조합 찾기
	- "개발" (명사) + "자" (접미사) + "들" (복수) + "이" (조사) + "었" (과거) + "습니다" (어미)
	- "개" (명사) + "발자" (???) → 사전에 없음, 점수 낮음
- Step 2: 가장 적절한 조합 선택
	- "개발" + "자" + "들" + "이" + "었" + "습니다"

#### 어떻게 '가장 적절한 조합'임을 알까? 
이것은 내부 알고리즘이나, 샘플을 통한 학습으로 `확률 기반`으로 정해진다.
```bash
"한국어" 분석 시:
- "한국" + "어" (언어) → 확률 높음 ✓
- "한" + "국어" → 확률 낮음 ✗
```

### 2. 불용어 제거
불용어란 키워드 검색에서 별 다른 가치가 없는 단어들을 의미한다. 조사나 복수형 ('들') 같은 것들이 속할 수 있겠다. 
해당 불용어는 상수로 MySQL에 정의되어 있다. 이것은 개발자가 입맛에 맞게 추가 및 삭제 가능하다.

## (3) Pros and Cons
**장점**
-  단순한 n-gram에 비해 노이즈가 적다. (노이즈: 가치 없는 단어가 검색되는 상황)
```bash
ngram: "한국사람" → "한국", "국사", "사람"
→ "국사" 검색시 "한국사람" 나옴 (원하지 않는 결과)

MeCab: "한국사람" → "한국"(지명) + "사람"(명사)  
→ "국사" 검색 시 "한국사람"은 매칭 안됨 (정확한 결과)
```

**단점**
- 저것이 가능하려면 어근을 정확히 찾아서 인덱싱하는 작업이 필수이다. 이를 위해서 meCab 플러그인을 학습시키는 작업에 많은 시간과 노력이 필요하다.

# 2. n-gram 알고리즘

본문을 무조건 몇 글자씩 잘라서 인덱싱하는 알고리즘이다. n-gram의 n은 변수 즉 자를 글자의 개수를 의미한다. 여기서는 제일 많이 쓰이는 2글자로 산정하고 진행하겠다. (2-gram 인덱싱)

## (1) 과정

- 문서 내 모든 단어를 2글자로 잘라서 토큰으로 저장 (인덱스가 될 수 있는 후보군)
- 불용어 제거 (불용어랑 일치하거나, 불용어를 포함하는 토큰들은 후보군에서 전부 제거)
- 살아남은 녀석들만 인덱스로 등록

### A. 2글자 잘라 저장하기
```bash
To be or not to be. That is a question
```
위 문장은 다음과 같이 저장된다.

![img](https://velog.velcdn.com/images/rg970604/post/be6fa551-efb8-4ad6-8bbb-755e28b8874e/image.png)

## (2) Pros and Cons
**장점**
- 세팅 작업이 따로 존재하지 않고, 러닝 커브가 낮다.
	- 단어 사전 따로 받아서 설정할 필요 x 
	- 각 언어의 특색을 이용해서 그에 맞는 어근 분석 알고리즘을 짤 필요가 없다.
	- 어근 분석기를 학습시키기 위한 노력과 시간이 따로 필요 없다. (단순히 글자를 나눠 인덱싱 하므로)

**단점**
- 검색 시 노이즈 발생이 어근 분석 알고리즘에 비해 잦다. (검색 정확도 떨어짐)
- 인덱스 크기가 어근 분석 알고리즘에 비해 기하 급수적으로 커진다.

# 3. 불용어 관리

## (1) MySQL의 불용어 활용
- 불용어가 기입된 `information_schema.innodb_ft_default_stopword` 를 활용해, 간추려진 후보군 중에서 불용어와 일치하거나 불용어를 포함하는 단어들을 거른다.

## (2) 불용어 추가 삭제, 전체 무시
불용어로 인덱싱을 거르는 작업 자체가 오히려 검색 정확도를 떨어트리고, 사용자들을 혼란에 빠트릴 수 있다. 따라서 개발자가 적절히 추가, 삭제, 때로는 불용어 활용 자체를 무시해서 성능을 높여야 한다.

- 스토리지 엔진에 관계없이 MySQL의 모든 전문 인덱스에 대하여 불용어 추가, 삭제, 전체 무시 방법
  : 시스템 변수 중 `ft_stopword_file` 을 활용
	- 해당 변수가 가리키는 파일의 내용물이 바로 불용어 목록임. 
	- 여기 추가 혹은 삭제하면 불용어 최신화됨.
	- 아에 안 쓰고 싶다면 `ft_stopword_file` = ''으로 바꾸자. 
	  
- InnoDB를 사용하는 테이블에 대한 전문 검색 인덱스에서만 불용어를 추가, 삭제, 전체 무시 방법
  : `innodb_ft_server_stopword_table` 시스템 변수에 불용어 테이블을 설정하면 됨.
	- **불용어 목록을 변경한 이후에 전문 검색 인덱스가 생성되어야만** 최신화된 불용어가 적용됨!
	- `innodb_ft_user_stopword_table`은 특정 인덱스에만 타겟 적용할 수 있는 불용어 테이블이다.

# 핵심 요약
- 전문 검색 인덱스의 알고리즘은 크게 두 가지가 있는데, `어근 분석 알고리즘` 과 `n-gram 알고리즘`이 있다.
- 어근 분석 알고리즘은 형태소를 분석하여, 파생 단어의 원형들을 저장한다. 이를 통해 검색의 정확도는 높이지만, 언어에 대한 이해가 필요하고, 사전 및 문맥 인식을 위한 샘플 등 정확도를 높이기 위해 많은 시간과 노력이 든다.
- 반면 n-gram 알고리즘은 무식하게 n개의 글자씩 잘라 전부 인덱싱한다. 러닝커브가 없다시피하지만, 검색 정확도가 낮아지고, 인덱스의 크기가 어근 분석 알고리즘에 비해 기하급수적으로 커진다.

---

# Metadata

### A. 모르는 단어 정리 to Layman's term
- `어근 (Stemming)`
  : 단어의 '기본 형태'를 지칭한다. 
	- running, runs, ran -> (어근) run
	- better, good -> good
	- cats, cat's -> cat
	  
- `형태소`
  : 의미를 가지는 가장 작은 글자 단위
	- "개발자들이" -> (형태소로 분해) "개발" (만들다, 발전시키다.), "자"(사람), "들" (복수), "이" (조사)
	- "예뻤었는데" -> "예쁘" (예쁘다.), "었" (과거 시제), "었"(과거 완료), "는데" (연결 어미)
	  
- `불용어` 
  : 검색에서 별 다른 가치가 없는 단어

###  B. 참고 문서
- real my sql 1권 8.5

### C. 자식 글

```dataview
TABLE without id file.inlinks AS "BackLink"
WHERE file.path = this.file.path
```
