# 7.5 바이너리 로그 암호화

- 테이블 암호화 적용되도, 바이너리 로그와 릴레이 로그는 평문으로 저장됨
- 바이너리 로그의 경우, 의도적으로 긴 시간동안 보관되는 경우 존재
- 증분 백업(Incremental Backup)을 위해 바이너리 로그 보관하기도 함

### 바이너리 로그와 릴레이 로그 파일 암호화 기능
- 디스크에 저장된 로그 파일에 대한 암호화만 담당
- MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터 암호화는 x
    - 네트워크 구간 암호화 -> SSL 설정

## 7.5.1 바이너리 로그 암호화 키 관리

<img src="../images/7.5_바이너리%20로그%20암호화/2025-04-23-12-01-20.png" style="width: 70%; max-width: 500px; height: auto;" />

- 2단계 암호화 키 관리 방식 사용
- 파일 키로 바이너리 로그와 릴레이 로그 암호화 -> 디스크로 저장
- 파일 키는 바이너리 로그 암호화 키로 암호화 -> 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장

## 7.5.2 바이너리 로그 암호화 키 변경
```sql
ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```

### 바이너리 로그 암호화 키 변경 후 과정
1. 증가된 시퀀스 번호와 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션)
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키 생성
    - 파일키는 바이너리 로그 파일키(마스터 키)로 암호화 해서 각 로그 파일에 저장
4. 기존 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장
    - 암호화되지 않은 로그 파일은 무시
5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거

<br>

### 시퀀스 번호 필요한 이유
- 4번 과정에서 특히 시퀀스 번호를 읽어서 “이 로그 파일이 구버전(key#n-1)으로 암호화된 것이니, 새버전(key#n)으로 다시 암호화 대상”인지 판단하는 데 사용

## 7.5.3 mysqlbinlog 도구 활용

<br>

# 7.5 추가 내용

## 증분 백업
- 전체 백업 이후 변경된(추가·수정·삭제된) 데이터만 별도로 보관하는 방식
### 장점
- 백업 시간·공간 크게 절약
- 네트워크 부담 경감 (클라우드 백업 시 유리)
- 자주 촬영하면 RPO(복구 시점 목표) 단축 가능

### 단점
- 복구 절차 복잡: 전체 백업 + 다수 증분 적용
- 증분 파일 분실 시 해당 시점 이후 복구 불가
- 관리 포인트(메타데이터·로그) 증가
