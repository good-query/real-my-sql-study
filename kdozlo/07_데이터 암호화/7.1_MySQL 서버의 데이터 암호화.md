# 7.1 MySQL 서버의 데이터 암호화

- MySQL 서버(InnoDB 스토리지 엔진)의 I/O 레이어에서만 데이터 암호화, 복호화 실행
    - 데이터베이스 서버와 디스크 사이의 IO 과정
    - -> 사용자 쿼리 처리 과정에서 테이블 암호화 여부 식별할 필요 X
- TDE(Transparent Data Encryption) 방식

### TDE(Transparent Data Encryption)
- Data at Rest Encryption
    - Data at Rest 의 뜻
        - 메모리(In-Process)나 네트워크 전송(In-Transit) 단계가 아닌 디스크에 저장(At-Rest)된 단계에서
- MySQL 서버의 TDE는 AES 256 암호화 알고리즘만 지원

## 7.1.1 2단계 키 관리
- 키링(KeyRing) 플러그인으로 MySQL 서버의 TDE의 암호화 키 관리
- 키링 플러그인은 2단계(2-Tier) 키 관리 방식 사용
- 2단계 암호화 사용 이유 : 암호화 키 변경으로 인한 과도한 시스템 부하 방지를 위해

### 2단계 암호화 아키텍처
<img src="../images/7.1_MySQL%20서버의%20데이터%20암호화/2025-04-22-18-40-09.png" style="width: 70%; max-width: 500px; height: auto;" />

- 마스터 키, 테이블스페이스 키 두 가지 종류의 키 있음
    - 테이블 스페이스 키 : 비밀키
- 외부 키 관리 솔루션(KMS, Key Management Service) or 디스크의 파일(keyring_file 같은 플러그인 사용 시)에서 마스터 키 가져옴
- 암호화된 테이블 생성될 때마다 해당 테이블의 테이블스페이스 키 발급
- 마스터 키로 테이블스페이스 키 암호화 -> 테이블의 데이터 파일 헤더에 저장
- 테이블스페이스 키 -> 테이블 삭제되지 않는 이상 변경 X
    - MySQL 서버 외부로 노출 X -> 주기적 변경 안해도 보안상 취약점 X
- 마스터 키 -> 외부의 파일 이용 -> 노출 가능성 존재 -> 주기적으로 변경해야함
    - `ALTER INSTANCE POTATE INNODB MASTER KEY;``
- 마스터 키 변경 -> 각 테이블의 테이블스페이스 키 복호화 -> 새로운 마스터 키로 다시 테이블스페이스 키 암호화
    - 마스터 키 변경 동안, 테이블페스이스 키 자체와 데이터 파일의 데이터 변경 X

## 7.1.2 암호화와 
### MySQL TDE 암호화 동작 흐름과 성능 영향
- 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼 풀에 적재
    - TDE 방식이기 때문
    - 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성동
- InnoDB 버퍼 풀에 없는 데이터 페이지 읽는 경우
    - 디스그에서 읽어온 데이터의 복호화 -> 처리 지연
- 암호화된 테이블 변경된 경우
    - 다시 디스크로 동기화(저장)활 때 암호화 과정 -> 추가 시간 필요
    - 하지만 이 경우 MySQL 서버의 백그라운드 스레드가 수행 -> 실제 사용자 쿼리가 지연되는 것 아님
- `SELECT`, `UPDATE`, `DELETE` -> 레코드를 InnoDB 버퍼풀로 읽어오는 작업 필요
    - 복호화 지연 발생

### AES 기반 TDE: 고정 페이지 크기와 버퍼 풀 효율
- AES 암호화 알고리즘 기준, 데이터 페이지는 암호문과 평문이 동일한 크기
    - 데이터 페이지가 암호화 키보다 훨씬 크기 때문에
        - AES 암호화 알고리즘에서 평문의 길이가 짧은 경우 암호화 키의 크기에 따라 암호화된 결과의 용량이 커질 수 있음.
    - -> 암호화 전후로 InnoDB 버퍼 풀의 효율이나 메모리 사용량이 전혀 달라지지 않음

### MySQL 테이블에 암호화와 압축 동시 적용 상황
- 이 경우 압축 먼저 실행된다.
- 암호화된 결과문은 랜덤한 바이트 배열을 가짐 -> 압축률을 떨어뜨린다.
- InnoDB는 “COMPRESSED row format” 사용 시, 압축된 페이지를 버퍼 풀에 올리는 경우 있음
    - 따라서 암호화 후 압축하는 상황이라면 버퍼 풀에 암호화된 페이지가 올라가는 경우가 발생함 -> InnoDB에서 페이지 꺼낼 때도 복호화 오버해드가 발생하게 됨.

## 7.1.3 암호화와 복제
- TDE를 이용한 암호화 사용 시, 레플리카 서버와 소스 서버의 데이터 파일 동일 X
    - MySQL에서는 각 서버마다 다른 마스터 키와 테이블스페이스 키를 가지고 있기 때문

<br>

# 7.1 추가 내용

### MySQL은 TDE 방식이기 때문 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼 풀에 적재된다. 이경우 보안상 안좋은거 아닌가?
- 맞다. 하지만 TDE 방식의 목적은 "데이터 at rest(디스크 상의 데이터) 탈취에 대한 방어"이다. 즉, 실행 중(in‑use)의 메모리를 보호하는 것은 아니다.
- 따라서 메모리 단계의 보안이 필요한 경우 추가적으로 따로 해줘야 함.
    1. OS/하드웨어 메모리 암호화
        - Linux 커널의 MKTME(Transparent Memory Encryption)
        - CPU 기반 보안 기술(Intel TDX, AMD SEV 등)

    2. 스왑 및 코어 덤프 비활성화
        - 스왑에 평문이 기록되지 않도록 비활성화하거나 암호화
        - 코어 덤프 생성을 막아 민감 정보 유출 방지

    3. 컬럼 레벨 암호화
        - 애플리케이션 레벨에서 AES_ENCRYPT/AES_DECRYPT 함수를 사용해 특정 컬럼만 암호화
        - 메모리·디스크 모두에서 평문 노출 리스크를 줄임

