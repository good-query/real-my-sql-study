# 8.3 B-Tree 인덱스
- DBMS는 주로 B+-Tree, B*-Tree 사용
- Balanced-Tree

## 8.3.1 B-Tree 구조 및 특성
- 루트 노드 : 최상위 노드, 하나 존재
- 자식 노드 : 루트 노드 하위 노드들
- 리프 노드 : 자식이 없는 가장 말단의 노드들
- 브랜치 노드 : 루트 노드, 리프 노드 외 노드들

<img src="../images/8.3_B-Tree%20인덱스/2025-04-30-14-53-13.png" style="width: 70%; max-width: 500px; height: auto;" />


- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아기기 위한 주소값 존재
- 인덱스의 키값은 정렬된 상태
    - 데이터 파일의 레코드는 정렬 X
- 데이터 파일의 레코드 항상 INSERT된 순서대로 저장되는 것 X
    - 레코드 삭제로 빈 공간이 생긴 경우 -> 다음 INSERT가 빈 공간 사용
- 인덱스는 테이블의 키 칼럼만 가지고 있음
    - 나머지 칼럼은 데이터 파일에서 해당 레코드를 찾아서 읽어야함


### MyISAM 테이블의 인덱스와 데이터 파일의 관계

<img src="../images/8.3_B-Tree%20인덱스/2025-04-30-15-10-28.png" style="width: 70%; max-width: 500px; height: auto;" />

- MyISAM 테이블 생성 옵션에 따라 레코드 주소 2가지로 나뉨
    1. ROWID 고정 포맷
        - 레코드가 테이블에 INSERT된 순번
    2. ROWID 가변 포맷
        - 데이터 파일 내의 위치

<br>

### InnoDB 테이블의 인덱스와 데이터 파일의 관계

<img src="../images/8.3_B-Tree%20인덱스/2025-04-30-15-10-58.png" style="width: 70%; max-width: 500px; height: auto;" />

- 프라이머리 키가 ROWID 역할
- 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 프라이머리 키를 저장하는 B-Tree 과정이 추가됨.
    - 프라이머리 키 인덱스 검색 -> 프라이머리 키 인덱스의 리프 페이지에 저장된 레코드 일기 과정이 추가됨.

### MyISAM 인덱스와 InnoDB 인덱스의 차이
- 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방식이 다름
- MyISAM 테이블 : 세컨더리 인덱스가 물리적인 주소를 가짐
- InnoDB 테이블 : 프라이머리 키를 주소처럼 사용 -> 논리적인 주소를 가짐

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 B-Tree 인덱스 키 추가
- B-Tree에 키를 추가할 때
    - 루트에서 리프까지 탐색하여 저장 위치를 찾는다.
    - 리프 노드에 키 값 + 레코드(또는 페이지) 주소를 기록한다.
    - 리프가 가득 차면 분할하고, 필요하면 부모 노드도 연쇄적으로 분할해 루트 높이가 늘어날 수 있다.
- B-Tree 쓰기 작업에 비용 많이 발생
- 쓰기 비용 산정 요소
    - 인덱스 키 길이, 페이지 크기, fan-out, 트리 높이, fill-factor, 버퍼 캐시 적중률 등
    - 추가 I/O(읽기 + 쓰기)와 WAL·락 경합이 주요 비용이며, CPU 연산은 상대적으로 작다.
- 간단한 비용 모델 예시
    - 테이블 행 1건 INSERT = 1 (기준)
    - B-Tree 인덱스 1개 유지 비용 ≈ 1.5 (예시값)
    - 인덱스 3개라면 총 ≈ 1 + 1.5 × 3 = 5.5 
        - (시스템·데이터에 따라 배수는 크게 달라질 수 있음)

### INSERT시 키 값 B-Tree에 반영하는 방법
- MyISAM, MEMORY 스토리지 엔진
    - INSERT 문장 실행 즉시 새로운 키 값 B-Tree 인덱스에 반영
- InnoDB 스토리지 엔진 
    - 필요한 경우 인덱스 키 추가 작업 지연 -> 나중에 처리
    - 프라이머리 키, 유니크 인게스의 경우 중복 체크 때문에 즉시 처리

### 8.3.2.2 B-Tree 인덱스 키 삭제
- 해당 키 값이 저장된 B-Tree의 리프 노드 찾아서 삭제 마크
- 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용 함.
- 삭제 마킹 작업 -> 디스크 쓰기 작업
    - 디스크 I/O 발생
    - MySQL 5.5 이상 InnoDB에서 버퍼링을 통해 지연 처리 가능
    - MyISAM, MEMORY는 체인지 버퍼와 같은 기능 없어서 즉시 처리

### 8.3.2.3 B-Tree 인덱스 키 변경
- 인덱스 키 값에 따라 저장될 리프 노드의 위치 결정됨
- InnoDB의 경우 해당 작업 체인지 버퍼를 활용해 지연 처리 가능
1. 키 값 삭제
2. 새로운 키 값 추가

### 8.3.2.4 B-Tree 인덱스 키 검색
- 인덱스를 통한 빠른 검색
    - INSERT, UPDATE, DELETE 작업 시 인덱스 관리에 따른 추가 비용 감당
- 인덱스 트리 탐색
    - 인덱스 검색을 위한 B-Tree 탐색
    - SELECT, UPDATE, DELETE, INSERT시 모두 탐색함.
- 인덱스 활용 가능 상황
    - 인덱스 값 전체나 앞부분만 일치하는 경우
    - 키 값의 부등호 비교하는 경우
- 인덱스 활용 불가능 상황
    - 키 값의 뒷부분만 검색하는 경우 
    - 인덱스 키 값에 변형이 생긴 경우
        - 변형된 값은 B-Tree에 존재 X
        - 함수나 연산 수행의 결과로 정렬하거나 검색하는 작업
- InnoDB에서 인덱스 활용 상황
    - 레코드 잠금, 넥슽트 키락 사용시 인덱스를 이용해 락을 건다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
- 인덱스를 구성하는 칼럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수가 검색이나 변경 작업의 성능에 영향을 미침

### 8.3.3.1 B-Tree 인덱스 키 값의 크기
- 페이지 : InnoDB에서 디스크에 데이터를 저장하는 기본 단위
    - InnoDB에서 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
    - InnoDB의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
- B-Tree 자식 노드의 개수는 가변적인 구조
- 인덱스 키 값 크기 커지면
    1. 디스크로부터 읽어야 하는 횟수 증가 -> 느려짐
    2. 인덱스 크기가 커질수록 메모리에 캐시할 수 있는 레코드 수 감소 -> 메모리 효율 감소

### MySQL의 B-Tree 자식 노드 개수
- 인덱스의 페이지 크기와 키 값의 크기에 따라 결정
- InnoDB 스토리지 엔진의 페이지 크기 기본값: 16KB
- 인덱스의 키 크기 16 바이트라고 가정
    - 자식 노드 주소 영역: 12 바이트로 구성된다고 가정
    - => 16 * 1024 / (16 + 12) = 585개 저장 가능
    - 따라서 585개 이상의 레코드 조회시 최소 2번 이상 디스크로부터 읽어와야 함

### 8.3.3.2 B-Tree 깊이
- B-Tree 인덱스 깊이를 제어할 방법 X
- 값 검색시 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 관련되어 있음
- 인덱스 키 값 크기 증가 
<br> -> 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값 개수 작아짐
<br> -> B-Tree 깊이 깊어짐
    - -> **디스크 읽기 증가**
- 실제론 B-Tree 깊이가 5단계 이상으로 깊어지는 경우는 잘 없음

### 8.3.3.3 선택도(기수성)
- 모든 인덱스 키 값 가중데 유니크한 값의 수를 의미
- 인덱스 키 값 중 중복된 값이 많아질수록 기수성은 낮아짐
    - 동시에 선택도도 떨어짐
- 선택도가 높을수록 검색 대상이 줄어듬 -> 빠르게 처리됨

### 8.3.3.4 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업

- 일반적으로 옵티마이저
    - 인덱스를 통한 레코드 1건 읽기 = 테이블에서 직접 레코드 1건 읽기 * 4
- 전체 테이블 레코드의 20 ~ 25%를 넘으면 인덱스 비효율적
- “많이 읽고, 적게 쓰며, 좁게 걸러내는” 컬럼 -> 인덱싱
- “많이 쓰고, 넓게 읽거나, 값 종류가 적은” 컬럼 -> 인덱싱 X

### 인덱스 스캔
1. B-Tree(보통 3~4 층) 를 뿌리 → 잎(leaf)으로 내려가며 조건에 맞는 키(예: id=123)가 있는 리프 페이지를 찾음
    - 랜덤 I/O 1회
2. 리프 페이지 안에서 키가 가리키는 “테이블 행의 주소(ROWID, 페이지번호+슬롯)” 를 읽음
3. 그 주소를 이용해 다시 테이블(데이터 페이지)을 랜덤 I/O로 읽음
    - 랜덤 I/O 1회
4. 필요한 열(column)을 가져옴
    
### 풀 테이블 스캔
- 테이블을 물리 순서대로 연속(Sequential) 읽기

- 8 KB 블록이라면 한 블록에 수십~수백 행이 들어 있어서,
디스크 한 번 돌릴 때마다 여러 행을 ‘묶음’으로 가져옴

- 현대 스토리지는 순차 읽기 속도가 랜덤 읽기보다 수십 배 빠름
(SSD도 마찬가지로 순차 읽기가 훨씬 효율적)
