# 8.3 B-Tree 인덱스
- DBMS는 주로 B+-Tree, B*-Tree 사용
- Balanced-Tree

## 8.3.1 B-Tree 구조 및 특성
- 루트 노드 : 최상위 노드, 하나 존재
- 자식 노드 : 루트 노드 하위 노드들
- 리프 노드 : 자식이 없는 가장 말단의 노드들
- 브랜치 노드 : 루트 노드, 리프 노드 외 노드들

<img src="../images/8.3_B-Tree%20인덱스/2025-04-30-14-53-13.png" style="width: 70%; max-width: 500px; height: auto;" />


- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아기기 위한 주소값 존재
- 인덱스의 키값은 정렬된 상태
    - 데이터 파일의 레코드는 정렬 X
- 데이터 파일의 레코드 항상 INSERT된 순서대로 저장되는 것 X
    - 레코드 삭제로 빈 공간이 생긴 경우 -> 다음 INSERT가 빈 공간 사용
- 인덱스는 테이블의 키 칼럼만 가지고 있음
    - 나머지 칼럼은 데이터 파일에서 해당 레코드를 찾아서 읽어야함


### MyISAM 테이블의 인덱스와 데이터 파일의 관계

<img src="../images/8.3_B-Tree%20인덱스/2025-04-30-15-10-28.png" style="width: 70%; max-width: 500px; height: auto;" />

- MyISAM 테이블 생성 옵션에 따라 레코드 주소 2가지로 나뉨
    1. ROWID 고정 포맷
        - 레코드가 테이블에 INSERT된 순번
    2. ROWID 가변 포맷
        - 데이터 파일 내의 위치

<br>

### InnoDB 테이블의 인덱스와 데이터 파일의 관계

<img src="../images/8.3_B-Tree%20인덱스/2025-04-30-15-10-58.png" style="width: 70%; max-width: 500px; height: auto;" />

- 프라이머리 키가 ROWID 역할
- 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 프라이머리 키를 저장하는 B-Tree 과정이 추가됨.
    - 프라이머리 키 인덱스 검색 -> 프라이머리 키 인덱스의 리프 페이지에 저장된 레코드 일기 과정이 추가됨.

### MyISAM 인덱스와 InnoDB 인덱스의 차이
- 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방식이 다름
- MyISAM 테이블 : 세컨더리 인덱스가 물리적인 주소를 가짐
- InnoDB 테이블 : 프라이머리 키를 주소처럼 사용 -> 논리적인 주소를 가짐

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 B-Tree 인덱스 키 추가
- B-Tree에 키를 추가할 때
    - 루트에서 리프까지 탐색하여 저장 위치를 찾는다.
    - 리프 노드에 키 값 + 레코드(또는 페이지) 주소를 기록한다.
    - 리프가 가득 차면 분할하고, 필요하면 부모 노드도 연쇄적으로 분할해 루트 높이가 늘어날 수 있다.
- B-Tree 쓰기 작업에 비용 많이 발생
- 쓰기 비용 산정 요소
    - 인덱스 키 길이, 페이지 크기, fan-out, 트리 높이, fill-factor, 버퍼 캐시 적중률 등
    - 추가 I/O(읽기 + 쓰기)와 WAL·락 경합이 주요 비용이며, CPU 연산은 상대적으로 작다.
- 간단한 비용 모델 예시
    - 테이블 행 1건 INSERT = 1 (기준)
    - B-Tree 인덱스 1개 유지 비용 ≈ 1.5 (예시값)
    - 인덱스 3개라면 총 ≈ 1 + 1.5 × 3 = 5.5 
        - (시스템·데이터에 따라 배수는 크게 달라질 수 있음)

### INSERT시 키 값 B-Treee에 반영하는 방법
- MyISAM, MEMORY 스토리지 엔진
    - INSERT 문장 실행 즉시 새로운 키 값 B-Tree 인덱스에 반영
- InnoDB 스토리지 엔진 
    - 필요한 경우 인덱스 키 추가 작업 지연 -> 나중에 처리
    - 프라이머리 키, 유니크 인게스의 경우 중복 체크 때문에 즉시 처리

### 8.3.2.2 B-Tree 인덱스 키 삭제
- 해당 키 값이 저장된 B-Tree의 리프 노드 찾아서 삭제 마크
- 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용 함.
- 삭제 마킹 작업 -> 디스크 쓰기 작업
    - 디스크 I/O 발생
    - MySQL 5.5 이상 InnoDB에서 버퍼링을 통해 지연 처리 가능
    - MyISAM, MEMORY는 체인지 버퍼와 같은 기능 없어서 즉시 처리

### 8.3.2.3 B-Tree 인덱스 키 변경
- 인덱스 키 값에 따라 저장될 리프 노드의 위치 결정됨
- InnoDB의 경우 해당 작업 체인지 버퍼를 활용해 지연 처리 가능
1. 키 값 삭제
2. 새로운 키 값 추가

### 8.3.2.4 B-Tree 인덱스 키 검색
- 인덱스를 통한 빠른 검색
    - INSERT, UPDATE, DELETE 작업 시 인덱스 관리에 따른 추가 비용 감당
- 인덱스 트리 탐색
    - 인덱스 검색을 위한 B-Tree 탐색
    - SELECT, UPDATE, DELETE, INSERT시 모두 탐색함.
- 인덱스 활용 가능 상황
    - 인덱스 값 전체나 앞부분만 일치하는 경우
    - 키 값의 부등호 비교하는 경우
- 인덱스 활용 불가능 상황
    - 키 값의 뒷부분만 검색하는 경우 
    - 인덱스 키 값에 변형이 생긴 경우
        - 변형된 값은 B-Tree에 존재 X
        - 함수나 연산 수행의 결과로 정렬하거나 검색하는 작업
- InnoDB에서 인덱스 활용 상황
    - 레코드 잠금, 넥슽트 키락 사용시 인덱스를 이용해 락을 건다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
- 인덱스를 구성하는 칼럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수가 검색이나 변경 작업의 성능에 영향을 미침

### 8.3.3.1 B-Tree 인덱스 키 값의 크기
- 페이지 : InnoDB에서 디스크에 데이터를 저장하는 기본 단위
    - InnoDB에서 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
    - InnoDB의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
- B-Tree 자식 노드의 개수는 가변적인 구조
- 인덱스 키 값 크기 커지면
    1. 디스크로부터 읽어야 하는 횟수 증가 -> 느려짐
    2. 인덱스 크기가 커질수록 메모리에 캐시할 수 있는 레코드 수 감소 -> 메모리 효율 감소

### MySQL의 B-Tree 자식 노드 개수
- 인덱스의 페이지 크기와 키 값의 크기에 따라 결정
- InnoDB 스토리지 엔진의 페이지 크기 기본값: 16KB
- 인덱스의 키 크기 16 바이트라고 가정
    - 자식 노드 주소 영역: 12 바이트로 구성된다고 가정
    - => 16 * 1024 / (16 + 12) = 585개 저장 가능
    - 따라서 585개 이상의 레코드 조회시 최소 2번 이상 디스크로부터 읽어와야 함

### 8.3.3.2 B-Tree 깊이
- B-Tree 인덱스 깊이를 제어할 방법 X
- 값 검색시 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 관련되어 있음
- 인덱스 키 값 크기 증가 
<br> -> 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값 개수 작아짐
<br> -> B-Tree 깊이 깊어짐
    - -> **디스크 읽기 증가**
- 실제론 B-Tree 깊이가 5단계 이상으로 깊어지는 경우는 잘 없음

### 8.3.3.3 선택도(기수성)
- 모든 인덱스 키 값 가중데 유니크하 값의 수를 의미
- 인덱스 키 값 중 중복된 값이 많아질수록 기수성은 낮아짐
    - 동시에 선택도도 떨어짐
- 선택도가 높을수록 검색 대상이 줄어듬 -> 빠르게 처리됨

### 8.3.3.4 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업

- 일반적으로 옵티마이저
    - 인덱스를 통한 레코드 1건 읽기 = 테이블에서 직접 레코드 1건 읽기 * 4
- 전체 테이블 레코드의 20 ~ 25%를 넘으면 인덱스 비효율적
- “많이 읽고, 적게 쓰며, 좁게 걸러내는” 컬럼 -> 인덱싱
- “많이 쓰고, 넓게 읽거나, 값 종류가 적은” 컬럼 -> 인덱싱 X

### 인덱스 스캔
1. B-Tree(보통 3~4 층) 를 뿌리 → 잎(leaf)으로 내려가며 조건에 맞는 키(예: id=123)가 있는 리프 페이지를 찾음
    - 랜덤 I/O 1회
2. 리프 페이지 안에서 키가 가리키는 “테이블 행의 주소(ROWID, 페이지번호+슬롯)” 를 읽음
3. 그 주소를 이용해 다시 테이블(데이터 페이지)을 랜덤 I/O로 읽음
    - 랜덤 I/O 1회
4. 필요한 열(column)을 가져옴
    
### 풀 테이블 스캔
- 테이블을 물리 순서대로 연속(Sequential) 읽기

- 8 KB 블록이라면 한 블록에 수십~수백 행이 들어 있어서,
디스크 한 번 돌릴 때마다 여러 행을 ‘묶음’으로 가져옴

- 현대 스토리지는 순차 읽기 속도가 랜덤 읽기보다 수십 배 빠름
(SSD도 마찬가지로 순차 읽기가 훨씬 효율적)

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔
- 검색해야 할 인덱스의 범위가 결정됐을 때 사용
- 인덱스 레인지 스캔 3단계
    1. 인덱스 탐색
        - 인덱스에서 조건을 만족하는 값이 저장된 위치 찾기
    2. 인덱스 스캔
        - 탐색한 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽음
    3. 필요한 인덱스 키와 레코드 주소로 레코드가 저장된 페이지 가져와 읽음
- 커버링 인덱스로 처리되는 경우 3번 과정 불필요
    - 커버링 인덱스: 쿼리가 요청한 모든 컬럼을 담고 있어, 테이블(데이터 페이지)을 추가로 읽지 않고도 결과를 만들 수 있는 인덱스
- 1, 2번 단계의 작업 수행 횟수 확인 방법
    ```sql
    SHOW STATUS LIKE 'Handler_%';
    ```
    
    <img src="../images/8.3_B-Tree%20인덱스/2025-05-06-23-38-16.png" style="width: 70%; max-width: 500px; height: auto;" />

    - `Handler_read_key`: 1단계 실행 횟수
    - `Handler_read_next`(정순), `Handler_read_prev`(역순): 2단계 읽은 레코드 건수
    - `Handler_read_first`, `Handler_read_last`: 인덱스의 첫번째 레코드와 마지막 레코드를 읽은 횟수
        - MIN(), MAX()와 같이 가장 큰 값/작은 값 읽는 경우 증가하는 상태 값
        - 읽은 레코드 건수 의미(인덱스만 읽었는지, 테이블 레코드를 읽었는지는 구분 X)

<img src="../images/8.3_B-Tree%20인덱스/2025-05-06-22-03-04.png" style="width: 70%; max-width: 500px; height: auto;" />

- 리프노드에서 시작 지점 찾기 -> 끝 지점까지 순서대로 스캔
    - 리프 노드 진입 전 과정: 비교를 통해 시작 지점의 리프 노드를 찾는 과정
- 리프 노드의 끝까지 읽었지만 끝 지점이 아닌 경우
    - 리프 노드 간의 링크를 이용해 다음 리프 노드 찾아 스캔 계속 진행
- 위 과정은 인덱스만 읽는 예시

<img src="../images/8.3_B-Tree%20인덱스/2025-05-06-22-21-51.png" style="width: 70%; max-width: 500px; height: auto;" />

- 인덱스 레인지 스캔을 통한 데이터 레코드 읽기 예시
    - 리프 노드 스캔 과정에서 실제 데이터 파일의 레코드를 읽어 오는 과정
- 레코드 한 건 단위로 랜덤 I/O가 발생
    - 인덱스를 통해 읽어야 할 데이터 레코드가 20 ~ 25%를 넘으면 인덱스를 통한 읽기 추천 X -> 테이블의 데이터를 직접 읽는 것이 더욱 효율적인 처리 방식 

### 8.3.4.2 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 인덱스 레인지 스캔보다 느림
- 테이블 풀 스캔보다 효율적
    - 인덱스에 포함된 칼럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문

<img src="../images/8.3_B-Tree%20인덱스/2025-05-07-12-52-59.png" style="width: 70%; max-width: 500px; height: auto;" />

### 8.3.4.3 루스 인덱스 스캔
- Loose Index Scan
- 오라클의 인덱스 스킵 스캔과 비슷
- 느슨하게 인덱스를 읽는 방식
- GROUP BY 또는 MAX(), MIN() 함수에 대해 최적화 하는 경우 사용

<img src="../images/8.3_B-Tree%20인덱스/2025-05-07-13-17-49.png" style="width: 70%; max-width: 500px; height: auto;" />

```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no
```

### 8.3.4.4 인덱스 스킵 스캔
- 인덱스의 값이 정렬된 상태임을 활용하여 불필요한 부분은 스킵하는 스캔 방식
- MySQL 8.0 이상에서 `SET optimizer_switch='skip_scan=off/on'`로 설정 가능
- 단점
    1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야함
    2. 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야함(커버링 인덱스)

### 인덱스 스킵 스캔 예시
- `employees` 테이블에 ix_gender_birthdate(gender, birth_date) 인덱스를 건 상황
- `SELECT * FROM employeess WHERE birth_date >= '1965-02-01'` 실행
- MySQL 8.0 이전 버전
    - gender에 대한 조건이 없으므로, `인덱스 풀 스캔`
- MySQL 8.0 이후 버전
    - gender가 남성인 경우에서 birth_date 조건 만족하는 범위까지 스캔
    - gender가 여성인 경우에서 birth_date 조건 만족하는 범위까지 스캔
    - `인덱스 스킵 스캔`

    <img src="../images/8.3_B-Tree%20인덱스/2025-05-07-14-16-39.png" style="width: 70%; max-width: 500px; height: auto;" />


## 8.3.5 다중 칼럼 인덱스
- multi-column index
- 두개 이상의 칼럼으로 구성된 인덱스
- 인덱스 내에서 각 칼럼의 위치(순서) 중요함

<img src="../images/8.3_B-Tree%20인덱스/2025-05-07-14-30-17.png" style="width: 70%; max-width: 500px; height: auto;" />

- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬된다.

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

### 8.3.6.1 인덱스의 정렬
- 인덱스 생성 시점에 정렬 방식 설정 가능
    - 내림차순, 오름차순

### 8.3.6.1.1 인덱스 스캔 방향
- 인덱스가 오름차순으로 정렬되 있더라도, 조건에 따라 내림차순으로 읽으면서 값을 가져올 수 있음

<img src="../images/8.3_B-Tree%20인덱스/2025-05-07-14-37-05.png" style="width: 70%; max-width: 500px; height: auto;" />

- ```sql
  SELECT * FROM employees WHERE fisrt_name >= 'Anneke'
  ORDER BY first_name ASC LIMIT 4;
  ```
- ```sql
  SELECT * FROM employees
  ORDER BY first_name DASC LIMIT 5;
  ```

### 8.3.6.1.2 내림차순 인덱스
- 오름차순 인덱스: 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- 내림차순 인덱스: 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- 인덱스 정순 스캔: 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- 인덱스 역순 스캔: 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
- 대부분의 쿼리가 인덱스의 앞쪽 또는 뒤쪽만 집중적으로 읽는 경우
    - 특정 페이지 잠금이 병목될 것으로 예상
    - 자주 사용되는 정렬 순서대로 인덱스 생성 -> 잠금 병목 현상 완화
    - 예시.
        - `SELECT * FROM orders ORDER BY created_at DESC LIMIT 10;`
        - `CREATE INDEX idx_orders_created_at_desc ON orders (created_at DESC);` 생성
        - 쿼리 A(최근 주문 조회)는 바로 이 인덱스의 맨 앞(leaf) 페이지만 뒤져서 결과를 꺼내므로, 전체 트리 스캔이 필요 없고, 락도 이 인덱스의 일부 페이지에만 걸림

### InnoDB 스토리지 엔진에서는 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느린 이유
1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조이기 때문
2. 페이지 내에 인덱스 레코드가 단방향으로만 연결된 구조이기 때문
    <img src="../images/8.3_B-Tree%20인덱스/2025-05-07-15-01-53.png" style="width: 70%; max-width: 500px; height: auto;" />
    - 실제 InnoDB 페이지는 힙처럼 사용 됨 -> 물리적으로 저장이 순서대로 배치되지 않는다.
    - 프라이머리 키의 리프 노드 데이터 = 실제 레코드 칼럼 값
    - 세컨더리 인덱스 페이지의 리프노드 데이터 = 프라이머리 키 값

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

### 8.3.7.1 비교 조건의 종류와 효율성
- `SELECT * FROM dept_emp WHERE dept_no='d002' AND emp_no >= 1101`
    1. INDEX(dept_no, emp_no)
        - 작업 범위 축소 + 필터링
    2. INDEX(emp_no, dept_no)
        - 필터링
    - 따라서 1번이 더욱 효율적

### 8.3.7.2 인덱스의 가용성
- B-Tree 인덱스의 특징: 왼쪽 값을 기준으로 오른쪽 값이 정렬되어 있음
- 따라서 INDEX(name)인 상황에서 `name Like '%em'` 조회는 인덱스 효과 X
- 따라서 INDEX(dept_no, emp_no)인 상황에서 `dept_no 조건이 포함 안된 emp_no >= 111` 조회는 인덱스 효과 X

### 8.3.7.3 가용성과 효율성 판단
### 작업 범위 결정 조건으로 인덱스를 사용할 수 없는 경우
1. NOt-EQUAL로 비교된 경우(<>, NOT IN, NOT BETWEEN, IS NOT NULL)
2. LIKE '%??'(뒷 부분 일치) 형태의 문자열 패턴 비교
3. 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
5. 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
6. 문자열 데이터 타입의 콜레이션이 다른 경우
    - 콜레이션: 문자 비교·정렬 방식이나 대소문자 구분·발음 구분 여부 등의 규칙
7. 다중 칼럼 인덱스에서, 첫번째 칼럼에 대한 조건이 없는 경우
8. 다중 칼럼 인덱스에서, 첫번째 칼럼에 대한 조건이 1 ~ 6 조건인 경우
- 참고
    - NULL값이 인덱스에 저장 하지 않는 DBMS -> 작업 범위 결정 조건으로 인덱스를 사용 X
    - MySQL의 경우 NULL값이 인덱스에 저장가능하여 작업 범위 결정 조건으로 가능

<br>

# 8.3 추가 내용

### 옵티마이저가 인덱스 Range Scan을 고르는 상황
1.  “= … = … <범위>” 패턴 (복합 인덱스 선두 =, 마지막 범위)
2. LIKE 'prefix%', IN(…리스트)는 일반적으로 range scan
   - col IS NULL 단독 조건은 type = range 로 분류된다.
   -  “값 또는 NULL” 을 동시에 찾으면 드물게 ref_or_null 로 표기
        - `ref_or_null`: ref(단일 키 룩업) + “NULL 행 한 번 더 찾아보기”
        - Null 구간과 특정 값 구간이 떨어져 있으면 두 구간을 따로 꺼내는 편이 훨씬 싸다.
3. 파티션 프루닝 후 남은 파티션에서 범위 조건
4. 통계·히스토그램이 정확해 선택도가 충분히 높을 때

### 옵티마이저가 인덱스 Full Scan을 고르는 상황
1. “인덱스가 커버링(Using index)일 때”, WHERE가 없거나 대부분 행이 살아남을 때
2. (커버링인덱스 + 정렬열 일치) → ORDER BY / GROUP BY 정렬 회피
3. MIN·MAX, ORDER BY … LIMIT N(주로 1) 처럼 “맨 앞/뒤 N 건”만 필요할 때
    - 선행 컬럼 조건이 없거나 상수인 경우에만 해당
        - WHERE a = 10 같이 조건이 상수인 경우 -> 단일 키 룩업(const/ref)으로 값 대체 후 즉시 반환
    - 실제 I/O는 극소지만 Access type = index
    - type = index = “순차 읽기 방식” 이라는 뜻일 뿐,
“인덱스 전체를 다 읽었다” 는 의미는 아님
