# 8.8 클러스터링 인덱스

## 8.8.1 클러스터링 인덱스
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용됨
- 레코드 저장 방식
    - 프라이머리 키값에 의해 레코드의 저장 위치가 결정되기 때문
    - 클러스터링 인덱스 == 클러스터링 테이블
- 프라이머리 키 기반의 검색 빠름
- 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느림

<img src="../images/8.8_클러스터링%20인덱스/2025-06-10-08-26-44.png" style="width: 70%; max-width: 500px; height: auto;" />

- 클러스터링 테이블 구조와 B-Tree 구조는 비슷
- 클러스터링 인덱스의 리프 노드 -> 레코드의 모든 칼럼이 저장되어 있음
    - 세컨더리 인덱스 B-Tree의 리프 노드 -> 프라이머리 키 칼럼, 인덱싱된 칼럼 

### 프라이머리 키 변경에 따른 레코드 위치
- 클러스터링 테이블(InnoDB)의 경우, 프라이머리 키 변경에 따라 레코드 위치가 변경됨.
- MyISAM 테이블의 경우, 프라이머리 키가 변경된다고 레코드 위치가 변경되는것 아님.

### 프라이머리 키가 없는 InnoDB 테이블의 클러스터링 테이블 구성
- 아래 우선순위대로 프라이머리 키 대체 칼럼 선택
    1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
    2. Not NULL 옵션의 유니크 인덱스중에서 첫번째 인덱스를 클러스터링 키로 선택
    3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가 -> 클러스터링 키로 선택
- 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 클러스터링 키의 경우
    - 사용자에게 노출 X
    - 쿼리 문장에 명시적으로 사용 X
    - 클러스터링 인덱스의 장점 사용 X

## 8.8.2 세컨더리 인덱스에 미치는 영향
- MyISAM, MEMORY 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 차이 X
    - ROWID를 이용해서 실제 데이터 레코드를 찾기 때문
- InnoDB 테이블의 세컨더리 인덱스에서 리프노드는 ROWID가 아닌 프라이머리키가 들어있다.
    - ROWID가 들어있을 경우, 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 함.
    - 프라이머리 키 값을 저장하게 되면, 바꾼 키값의 레코드에 해당하는 인덱스만 변경하면 됨.

## 8.8.3 클러스터링 인덱스의 장점과 단점
- 장점: 빠른 읽기(SELECT)
- 단점: 느린 쓰기(INSERT, UPDATE, DELETE)
- 일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경에서는 읽기의 비율이 높기 때문에 클러스터링 인덱스가 유리

## 8.8.4 클러스터링 테이블 사용 시 주의사항

### 8.8.4.1 클러스터링 인덱스 키의 크기 고려
- 프라이머리 키의 크기가 커지면 세컨더리 인덱스 크기는 급격히 증가한다.
    - 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키) 값을 포함하기 때문에 

### 8.8.4.2 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)
- 프라이머리 키 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면, 그 칼럼을 프라이머리 키로 설정하는 것이 좋다.
    - 프라이머리 키를 검색에서 빈번하게 사용되기 때문에, 클러스터링 테이블의 경우 성능 차이가 많이 발생할 수 있기 
- 하지만 신중히 선택하는게 중요
    -  프라이머리 키 칼럼의 크기가 크면 클러스터드 인덱스가 무거워지고, 대규모 테이블일수록 불리함
    - 예상치 못한 상황에서 고유성이 깨질수 있기 때문

### 프라이머리 키는 가능한 한 작고 불변(immutable)한 컬럼으로 생성  
- InnoDB의 클러스터드 인덱스 성능을 위해서는,  
  - 키 크기가 작고(예: 4~8바이트 정수),  
  - 변경될 가능성이 거의 없는 컬럼을 PK로 삼는 것이 좋다.  
- 일반적으로 AUTO-INCREMENT 정수 키를 사용하고,  
  업무 로직상 중요한 컬럼에는 `UNIQUE` 제약을 걸어 자연 키로 활용하라.

### 업무 키 vs AUTO-INCREMENT 키
- 업무 키(natural key)
    - 정말 “절대 바뀌지 않는” 데다가,
    - 크기가 작고(예: ISO-8601 날짜 같은 8바이트 이하),
    - 고유성이 완벽히 보장되는 경우에만 PK로 삼는 것을 고려.
    - 그렇지 않으면 키 변경·크기 문제로 성능 저하·운영 복잡도가 커짐.

- AUTO-INCREMENT 키
    - 4바이트 또는 8바이트 정수로 매우 작고,
    - 삽입 순서가 “늘 증가”하므로 클러스터드 인덱스에 적합하고,
    - 변경될 일이 거의 없으므로 운영상 안전.
    - 따라서 일반적으로 InnoDB 테이블의 PK로 AUTO-INCREMENT를 사용하는 게 더 나은 선택.

### 프라이머리 키 설계 원칙
1. **불변성(Immutable)이 최우선**  
   - PK가 변경되면 페이지 재배치·인덱스 갱신 오버헤드 발생  
2. **키 크기는 작을수록 유리**  
   - B-Tree 높이·페이지 밀도에 직접 영향  
3. **업무 키(natural key) 활용 조건**  
   - 절대 변경되지 않고, 고유성·크기 요건 충족 시에만 고려  
4. **AUTO-INCREMENT 키 권장**  
   - 4~8바이트 정수, 삽입 순서 보장, 변경 불필요  

### 8.8.4.3 프라이머리 키는 반드시 명시할 것
- InnoDB 테이블에 명시적 PRIMARY KEY 또는 널을 허용하지 않는 UNIQUE 인덱스가 없으면,  
  내부적으로 6바이트 숨은 컬럼(`GEN_CLUST_INDEX`)을 만들고 이를 클러스터드 키로 사용한다.  
- 이 숨은 키는  
  - 사용자에게 보이지 않고,  
  - SQL에서 참조할 수 없으며,  
  - 비즈니스 로직에 맞춘 범위 조회·정렬·조인 최적화에 전혀 활용되지 못한다.  
- 따라서 **반드시** 업무에 의미 있는(예: 조회·조인에 쓰일) 컬럼을 `PRIMARY KEY`로 **명시적으로** 정의해야 한다.

### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
- 세컨더리 인덱스가 필요하고, 프라이머리 키의 크기도 길다면
    - AUTO-INCREMENT 칼럼 추가 후, 이를 프라이머리 키로 설정하기
- 인조 식별자: 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키


