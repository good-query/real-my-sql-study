# 5.3 InnoDB 스토리지 엔진 잠금

1. `information_schema`의 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블 조인으로 현재 트랜잭션이 어떤 잠금을 대기하고 있는지, 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인 가능 
2. `Performance Schema`를 이용해 InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법도 가능

## 5.3.1 InnoDB 스토리지 엔진의 잠금
<img src="../images/5.3_InnoDB%20스토리지%20엔진%20잠금/2025-04-09-11-17-33.png" style="width: 70%; max-width: 500px; height: auto;" />

- 레코드 기반의 잠금 기능 제공
- 레코드 락이 페이지 락이나 테이블 락으로 레벨업 되는 경우 X
    - == 락 에스컬레이션 X
    - 잠금 정보가 작은 공간으로 관리되기 때문에!
- 레코드와 레코드 사이의 간견을 잠그는 `Gap Lock` 존재

### 5.3.1.1 레코드 락
- 레코드 자체만 잠그는 락
- 다른 상용 DBMS의 레코드 락과 동일
- 인덱스의 레코드를 잠근다.
    - 레코드 자체 잠금 X
    - InnoDB만의 차이점
    - 인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정함
- 보조 인덱스를 이용한 변경 작업 -> 네스트 키 락 or 갭 락 사용
- 프라이머리 키 or 유니크 인덱스에 의한 변경 작업 -> 갭 락 x, 레코드 자체에만 락
    - 프라이머리 키에 락을 거는 경우, 사실상 해당 인덱스 레코드(즉, 레코드 자체)에 락이 걸리는 것과 동일하게 동작

### 5.3.1.2 갭 락
- InnoDB만의 차이점
- 레코드와 인접한 레코드 사이의 간견만 잠그는 것
- 레코드와 레코드 사이의 간격에 새로운 레코드가 `INSERT`되는 것을 제어
- 주로 넥스트 키 락의 일부로 자주 사용

### 5.3.1.3 넥스트 키 락
- 레코드 락 + 갭 락 형태의 잠금
- 한 레코드(데이터 행)에 대한 락과, 그 레코드 뒤의 "빈 공간(갭)"에 대한 락을 동시에 설정하는 락
- InnoDB는 기본 격리 수준(REPEATABLE READ)에서 팬텀 리드를 방지하기 위해 넥스트 키 락을 사용

### 넥스트 키 락 사용 예시
- `MySQL이 STATEMENT` 포맷의 바이너리 로그를 사용할 때,
- `REPEATABLE READ` 격리 수준 하에서,
    - 실행된 쿼리가 소스 서버와 동일한 결과를 레플리카(복제 서버)에서 재현할 수 있도록 보장해야 함
- 변경 작업 시, 넥스트 키 락을 사용하여 다른 트랜잭션이 해당 레코드와 인접한 갭에 접근하지 못하도록 막는 역할
    - `innodb_locks_unsafe_for_binlog` = 0(비활성화) 설정 시, 바이너리 로그 일관성 보장
        - 변경을 위한 검색 레코드에 넥스트 키 락으로 잠금이 걸리기 때문

### 예시 상황에서의 넥스트 키 락 및 갭 락 문제점
- 데드락(서로 락을 기다리는 상황)이 발생할 수 있음.
- 다른 트랜잭션이 대기하는 상황이 자주 발생할 수 있음.

### 예시 상황 해결책
- MySQL 8.0부터 기본 바이너리 로그 포맷이 `ROW` 방식으로 변경됨.
    - `ROW` 포맷은 실제 변경된 행 데이터를 기록하기 때문에,
    - 넥스트 키 락이나 갭 락 사용을 줄여 데드락 등의 문제를 완화
        <details>
            <summary>넥스트 키 락이나 갭 락 사용을 줄어드는 이유</summary>
            
            1. 실행 쿼리 재현성
                - MySQL 복제에서는 소스 서버(마스터)와 레플리카(슬레이브)에서 동일한 결과를 얻어야 합니다.

                - STATEMENT 기반 복제에서는 실행된 쿼리를 그대로 기록하고, 동일한 쿼리가 복제 서버에서 실행될 때 같은 결과를 내도록 해야 합니다.

                - 이를 보장하기 위해, 쿼리를 실행할 때 해당 쿼리의 결과에 영향을 줄 수 있는 범위(데이터 행과 그 사이의 간격)를 잠그는 Next-Key 락과 갭 락을 사용합니다.

            2. ROW 방식의 복제

                - ROW 기반 복제는 쿼리 실행 결과 대신 실제 변경된 행의 데이터를 기록합니다.

                - 이 경우, 복제 서버는 쿼리를 다시 실행하는 것이 아니라 변경된 데이터를 그대로 적용하므로, 실행 쿼리의 결과를 재현하기 위해 범위 락에 의존할 필요가 없습니다.

            3. 데드락 및 락 대기 문제 완화

                - STATEMENT 기반 복제에서는 범위 락을 사용하여 데이터 일관성을 보장하는 과정에서, 다른 트랜잭션과의 충돌로 인한 데드락(서로 락을 기다리는 상황)이나 불필요한 락 대기 문제가 발생할 수 있습니다.

                - ROW 방식으로 전환되면, 이러한 범위 락 사용이 줄어들어 잠금 경합(lock contention)이 감소하게 됩니다.

            결과적으로 데드락이 발생할 가능성이 낮아지고, 다른 트랜잭션들이 락 때문에 대기하는 시간이 줄어들게 되어 전체적인 시스템 성능과 안정성이 개선됩니다.


        </details>

### 5.3.1.4 자동 증가 락
- `AUTO_INCREMENT` 레코드 중복을 막고 순서대로 증가시키기 위한 락
- 여러 세션이나 트랜잭션이 동시에 AUTO_INCREMENT 값을 생성하려 할 때, 동일한 값이 중복으로 할당되는 것을 막아줌
- `AUTO_INCREMENT` 값이 순서대로 증가하도록 보장
    -  순차적인 값 부여와 중복 방지를 처리
- `INSERT`, `REPLACE` 쿼리 문장처럼 새로운 레코드 저장 쿼리에서만 필요
- `UPDATE`, `DELETE` 쿼리에서 안걸림
- 트랜잭션과 관계없이, `INSERT`, `REPLACE` 문장에서 `AUTO_INCREMENT`값을 가져오는 순간만 락이 걸렸다가 즉시 해제
- MySQL에서는 한 테이블에 단 하나의 AUTO_INCREMENT 칼럼만 지정할 수 있음.
    
    <img src="../images/5.3_InnoDB%20스토리지%20엔진%20잠금/2025-04-09-13-49-36.png" style="width: 70%; max-width: 500px; height: auto;" />

    - 따라서 두 개의 `INSERT` 쿼리가 동시에 실행되는 경우, 하나의 쿼리가 자동 증가 락을 건 경우, 다른 쿼리는 해당 락을 기다려야 함.
- 자동 증가 락을 명시적으로 획득하고 해제하는 방법 X
- 자동 증가 값이 항상 증가만 하는 이유
    - `AUTO_INCREMENT`잠금 최소화를 위해
- MySQL 5.1 이상
    - `innodb_autoinc_lock_mode`를 통해 자동 증가 락 작동 방식 변경 가능
        - `innodb_autoinc_lock_mode=0`
            - 기존 방식과 동일
            - 모든 `INSERT` 문장에 자동 증가 락 사용
        - `innodb_autoinc_lock_mode=1`
            - 단순히 레코드를 `INSERT`하는 경우에는 서버가 레코드 건수 정확히 예측 가능하므로 자동 증가 락 사용 X -> 대신 가볍고 빠른 래치(뮤텍스) 이용
            - 다중 레코드 INSERT 시에도 한 번의 락(자동 증가 락)으로 처리하여 순차적인 값 할당을 보장 -> 연속 모드(consecutive)
            - 하지만 할당 받은 자동 증가 값이 사용되지 않으면 연속된 값 안될 수 있음.
        - `innodb_autoinc_lock_mode=2`
            - 자동 증가 락 안걸고 **경량화된 래치(뮤텍스)**를 사용
            - 연속된 자동 증가 값은 보장 X -> 인터리빙 모드
            - 동시 처리 성능 높아짐
                - 한 커넥션에서 `INSERT` 수행시, 다른 커넥션에서도 `INSERT` 가능하므로
            - 자동 증가 값이 유니크인 것만 보장
- MySQL5.7 버전까지 `innodb_autoinc_lock_mode=1`가 기본값
- MySQL8.0 부터 `innodb_autoinc_lock_mode=2`가 기본값
    - 바이너리 로그 포맷 기본값이 `ROW`가 됬기 때문

<br>

## 5.3.2 인덱스와 잠금
### UPDATE 쿼리문에서 인덱스 사용 시
- 인덱스를 활용해 조건 검색을 진행하는 경우, 해당 인덱스의 레코드뿐 아니라 인접한 갭에도 락(next-key lock)을 걸어 조건 범위 전체를 보호

### UPDATE 쿼리문에서 인덱스 부재 시
- 인덱스가 없으면 전체 테이블 스캔을 통해 조건에 해당하는 모든 레코드와 그 갭에 대해 락을 획득하게 되며, 때로는 테이블 락이 적용됨

### UPDATE 쿼리문에서 팬텀 리드 방지
- 조건을 만족하는 기존 레코드만 락을 거는 것이 아니라 범위 전체에 락을 걸어, 조건 범위 내에 새로 삽입되는 레코드를 방지
- 팬텀 리드를 막기 위한 락 방식은 데이터베이스 격리 수준에 따라 달라지며, 낮은 격리 수준에서는 제한적으로 적용되지만, 높은 격리 수준에서는 조건 범위 전체를 락으로 보호

### 5.3.3 레코드 수준의 잠금 확인 및 해제
- 잠금된 레코드가 자주 사용 안되는 경우 
    - -> 오랫동안 잠겨진 상태로 남고, 발견하기 어려움
- MySQL5.1부터 레코드 잠금과 잠금 대기에 대한 조회 가능
    - `KILL`: 강제 잠그 해제 명령어
    - `performance_schema`의 `data_lock`과 `data_lock_waits` 조인을 통해 잠금 대기 순서 확인
        ```sql
        SELECT
            r.trx_id wating_trx_id,
            r.trx_mysql_thread_id waiting_thread,
            r.trx_query waiting_query,
            b.trx_id blocking_trx_id,
            b.trx_mysql_thread_id blocking_thread,
            b.trx_query blocking_query
            FROM performance_schema.data_lock_waits w
            INNER JOIN information_schema.innodb_trx b
            ON b.trx_id = w.blocking_engine_transaction_id
            INNER JOIN information_schema.innodb_trx r
            ON r.trx_id = w.requesting_engine_transaction_id;
        ```
    - `performance_schema`의 `data_locks` 테이블을 통해 특정 스레드가 가진 잠금 확인 가능
        ```sql
        SELECT * FROM performance_schema.data_locks
        ```

<br>

# 5.3 추가 내용

### 궁금증
1. MySQL이 STATEMENT 포맷의 바이너리 로그를 사용하다가 넥스트 키 락 및 갭 락의 문제점 때문에 MySQL8.0부터 ROW 포맷의 바이너리 로그를 기본 설정으로 변경된 건가?
- 맞다.
- 기본적으로 MySQL 8.0부터 기본 바이너리 로그 포맷이 ROW 방식으로 변경된 이유는, STATEMENT 포맷을 사용할 때 넥스트 키 락과 갭 락 때문에 발생할 수 있는 데드락이나 불필요한 트랜잭션 대기 문제 등 여러 부작용을 줄이기 위함. 다만 이 변경은 넥스트 키 락 문제뿐만 아니라,
    - 비결정적(Non-deterministic) 쿼리 문제를 줄이고
    - 레플리케이션 일관성을 보장하는 등의 여러 이유가 복합적으로 작용한 결과

2. 자동 증가 락이 새로운 레코드 저장 쿼리에서만 동작하고, `UPDATE`, `DELETE` 쿼리에서는 걸지 않는 이유는?
- AUTO_INCREMENT 락은 MySQL에서 새로운 AUTO_INCREMENT 값이 필요할 때, 즉 INSERT나 REPLACE 같은 쿼리에서 자동으로 증가된 값을 할당받기 위해 사용되는 락이기 때문
- 업데이트(UPDATE)나 삭제(DELETE) 쿼리에서는 AUTO_INCREMENT 값이 새로 생성되지 않으므로 AUTO_INCREMENT 락이 필요가 없다.
- 그럼 프라이머리 키에 AUTO_INCREMENT가 걸린 상황에서 프라이머리 키 업데이트 시에는?
    - 마찬가지로 순차적인 키 증가와는 관련이 없음
    - 하지만 중복 방지와는 관련이 있으나 이는 AUTO_INCREMENT에 대한 중복이 아니고 프라이머리 키 자체에 대한 중복이기 때문에 `자동 증가 락`과는 관련이 없다.

3. `innodb_autoinc_lock_mode = 0 or 1` 설정 시 경량화된 래치(뮤텍스)를 사용하는 이유
- 자동 증가 값이 유니크를 만족해야 하기 때문에 한 자원은 한 커넥션만 접근 할 수 있도록 해야함.
- 따라서 세마포어를 사용해 여러 커넥션이 사용하도록 X

4. 3번에서 단일 세마포어의 경우 경량화된 래치(뮤텍스)와 같이 한 자원은 한 커넥션만 접근 가능하도록 할 수 있는데 뮤텍스인 이유는?
- 경량화된 래치에 비해 비용이 크기 때문에
    - 세마포어는 커널에서 관리되는 락 오브젝트라서 획득/해제 시 컨텍스트 스위칭이 발생하고, 커널 콜 → 유저 스페이스 복귀 오버헤드가 상대적 크기 때문에
    - 경량 래치는 커널 진입 없이 유저 스페이스에서 동작하기 때문에 락 획득/해제 비용이 적고, 컨텍스트 스위칭이 거의 없음

### 바이너리 포그 포맷: `STATEMENT` 포맷과 `ROW` 포맷
- STATEMENT 포맷은 실행된 SQL 문장(쿼리) 자체를 기록
    - 즉, 어떤 명령문이 수행되었는지를 로그에 남깁니다.
    - 로그 공간을 절약하고 단순한 환경에서 효율적
    - 재현성 문제와 범위 락 관련 문제(데드락, 락 대기)가 발생
- ROW 포맷은 실제 변경된 각 행의 데이터를 기록
    - 예를 들어, 어느 행의 어떤 컬럼 값이 어떻게 변경되었는지를 상세히 남깁니다.
    - 복제 시 높은 일관성과 정확성을 보장
    - 로그 용량과 처리 부하가 증가

### 자동 증가 락과 경량화된 래치 고찰
- 자동 증가 락(전통적인 락, 예: innodb_autoinc_lock_mode=0 또는 다중 레코드 INSERT 시 모드 1)
여러 레코드를 한 번에 INSERT하는 경우, 해당 INSERT 문 전체의 실행 기간 동안 락을 걸어서, 그 작업이 모두 끝난 후에야 락이 해제됩니다.
그래서 만약 한 커넥션에서 다중 INSERT 문이 진행 중이면, 그 동안 다른 커넥션에서 INSERT를 요청해도 자동 증가 락이 해제될 때까지 대기하게 됩니다.

- 경량화된 래치(뮤텍스, 예: innodb_autoinc_lock_mode=2)
이 경우에는 각 INSERT 연산 시점에서만 짧게 락을 걸어 AUTO_INCREMENT 값을 증가시키고, 즉시 락을 해제합니다.
그래서 여러 INSERT가 동시에 진행되더라도 각 INSERT마다 짧은 임계 구역에서만 잠금을 사용하고, 락이 해제되는 타이밍에 따라 다른 커넥션의 INSERT도 빠르게 접근할 수 있어, 전체 동시 처리 성능이 높아집니다.

- 즉, 첫 번째 경우(자동 증가 락이 적용되는 모드)는 한 커넥션의 다중 INSERT 문이 진행 중일 때 그 작업이 완전히 끝날 때까지 새로운 커넥션의 INSERT가 대기하게 됩니다.

- 두 번째 경우(경량화된 래치를 사용하는 모드)는 각 INSERT가 짧은 시간 동안만 락을 사용하므로, 중간에 락이 해제되는 순간 다른 커넥션의 INSERT가 실행될 수 있습니다.
