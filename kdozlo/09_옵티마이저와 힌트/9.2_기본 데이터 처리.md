# 9.2 기본 데이터 처리

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

### 풀 테이블 스캔
- 인덱스를 사용하지 않고, 테이블의 데이터를 **처음부터 끝까지** 읽어서 요청된 작업을 처리하는 작업
    - 주의) 클러스터링 인덱스를 통해 테이블의 모든 데이터를 스캔하는 경우도 포함
- 대부분 DBMS는 풀 테이블 스캔시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능이 있음
    - 테이블의 전체 크기가 크기 때문에 디스크 읽기 작업이 많이 필요하기 때문에
- 옵티마이저의 풀 테이블 스캔 조건
    1. 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
        - 보통 테이블 페이지 1개로 구성된 경우
    2. WHERE절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
        - 인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준

### 풀 인덱스 스캔
- 특정 세컨더리 인덱스의 **모든 엔트리(인덱스 레코드)**를 처음부터 끝까지 순차적으로 읽는 경우
- 인덱스 자체가 쿼리에서 필요로 하는 모든 컬럼을 포함하고 있을 때 (즉, 인덱스가 커버링 인덱스일 때) 발생

### MySQL의 풀 테이블 스캔 
- 풀 테이블 스캔 실행 시 한꺼번에 몇 개의 페이지를 읽어올지 설정하는 시스템 변수 없음
- MyISAM의 경우, 풀 테이블 스캔시 디스크로부터 페이지 하나씩 읽어옴
- InnoDB의 경우,
    - 특정 테이블의 연속된 데이터 페이지 읽는 경우, 백그라운드 스레드에 의해 Read ahead 작업 자동으로 시작
    1. 풀 테이블 스캔 실행시, 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행
    2. 특정 시점부터 백그라운드로 읽기 작업이 넘어감
    3. 백그라운드로 넘어간 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 그 수를 증가시킴.
    4. 한 번에 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둠.

### Read ahead
- 어떤 영역의 데이터 앞으로 필요해지리라는 것을 예측하여 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 작업
- 풀 테이블 스캔, 풀 인덱스 스캔에서 사용
- `innodb_read_ahead_threshold`: InnoDB가 언제 리드 어헤드를 시작할지 임계값 설정하는 시스템 변수
- 포그라운드 스레드에 의해 `innodb_read_ahead_threshold` 변수에 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 InnoDB가 백그라운드 스레드를 이용해 대량으로 그다음 페이지들을 읽어서 버퍼 풀로 적재

### `SELECT COUNT(*) FROM employees;` 스캔 방식
- 풀 인덱스 스캔을 할 확률이 높다.
- 단순히 레코드의 건수만 필요로 하는 쿼리이기 때문에
- 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있음.
    - **세컨더리 인덱스**의 경우, 보통 2~3개의 칼럼만으로 구성되기 때문

### `SELECT * FROM employees;` 스캔 방식
- 풀 테이블 스캔
    - InnoDB의 경우 기본적으로 클러스터링 인덱스를 사용하기 때문에 내부적으로 풀 인덱스 스캔을 함.
    - 하지만 풀 테이블 스캔이라고 불리는 이유는 **테이블의 모든 데이터를 읽기 때문**
- 레코드에만 있는 칼럼이 필요한 쿼리이기 때문

## 9.2.2 병렬 처리
- **하나의 쿼리**를 여러 스레드가 작업을 나누어 동시에 처리하는 것을 의미
- MySQL 8.0부터 쿼리 병렬 처리 가능
    - 용도는 한정되어 있음
- `innodb_parallel_read_threads`: 하나의 쿼리 당 최대 몇개의 스레드를 이용해서 처리할지 정하는 시스템 변수
- 병렬 처리는 내부적으로만 수행
    - MySQL에서는 사용자가 병렬 쿼리를 제어하는 힌트/옵션을 제공하지 않음
- 주의) 병렬 처리용 스레드 개수를 아무리 늘리더라도 서버의 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능 저하 발생

## 9.2.3 ORDER BY 처리(Using filesort)
- 실행 계획의 Extra 칼럼에 Using filesort 표시 여부
    - 인덱스 이용하지 않고 별도의 정렬 처리 수행 여부 판단할 수 있음

### 인덱스 이용 정렬 방법
- 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되기 때문에 빠름
- 부가적인 인덱스 추가/삭제 작업이 필요하기 때문에 느림
- 인덱스 저장 디스크 공간이 더 필요함
- 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리 많이 필요

### Filesort 이용 정렬 방법
- 인덱스를 생성하지 않아도 되기 때문에 추가적인 디스크 공간이나 메모리가 필요 없다.
- 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되어 충분히 빠름
- 정렬 작업이 쿼리 실행 시 처리되기 때문에 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느림

### 인덱스를 이용한 튜닝이 불가능한 경우
- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

### 9.2.3.1 소트 버퍼
- MySQL에서 정렬을 수행하기 위해 할당 받은 별도의 메모리 공간
- 정렬이 필요한 경우에만 할당
- 크기는 레코드의 크기에 따라 가변적으로 증가
- `sort_buffer_size`: 최대 사용 가능한 소트 버퍼 공간
- 쿼리 실행 완료 시 즉시 시스템에 반납

### 정렬해야 할 레코드 수가 할당된 소트 버퍼보다 클 경우
- 정렬해야 할 레코드 수를 나눠서 처리
    - 이 과정에서 임시 저장을 위해 디스크 사용
- 멀티 머지 작업 필요
    - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬 수행해야 함.
- 디스크 쓰기, 읽기 작업 유발
- 레코드 수가 많을수록 디스크 쓰기, 읽기 작업 증가

### 9.2.3.2 정렬 알고리즘
- <sort_key, rowid>
    - 정렬 키와 레코드의 row id만 가져와서 정렬하는 방식
    - 추가 I/O 발생 가능
- <sort_key, additional_fields>
    - 정렬 키와 select 대상 칼럼들을 함께 메모리에 저장하며, 이때 각 필드는 정렬 버퍼 내에서 고정 크기 포맷으로 처리
- <sort_key, packed_additional_fields>
    - 정렬 키와 select에 선택된 칼럼 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 가변 사이즈로 메모리 저장
    - MySQL 8.0 이상

### 9.2.3.2.1 싱글 패스 정렬 방식
- <sort_key, additional_fields>, <sort_key, packed_additional_fields>

<br>

<img src="../images/9.2_기본%20데이터%20처리/2025-06-24-21-33-38.png" style="width: 70%; max-width: 500px; height: auto;" />

```sql
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```

- 정렬에 필요없는 조회한 모든 칼럼까지 전부 읽어서 소트 버퍼에 담고 정렬 수행
- 정렬 완료시 버퍼의 내용을 그대로 클라이언트로 넘겨줌
- 정렬 대상 레코드의 크기나 건수가 작은 경우 효율적

### 9.2.3.2.2 투 패스 정렬 방식 
- <sort_key, rowid>

<br>

<img src="../images/9.2_기본%20데이터%20처리/2025-06-24-21-58-52.png" style="width: 70%; max-width: 500px; height: auto;" />

- 정렬 대상 칼럼(first_name)과 프라이머리 키(emp_no) 값만 소트 버퍼에 담아서 정렬을 수행
- 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select한 칼럼을 가져옴
- 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적

### MySQL에서 투 패스 정렬을 사용하는 경우
- 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함될 때

### 9.2.3.3 정렬 처리 방법
- 쿼리에 `ORDER BY` 사용 시, 3가지 처리 방법 중 하나로 정렬 처리됨.

    | 정렬 처리 방법 | 실행 계획의 Extra 칼럼 내용|
    | ---------- | ---------- |
    | 인덱스를 사용한 정렬 | 별도 표기 없음 |
    | 조인에서 드라이빙 테이블만 정렬 | "Using filesort" 메시지가 표시됨 |
    | 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "Using temporary; Using filesort" 메시지가 표시됨 |

- 아래로 갈수록 처리 속도 down

### 9.2.3.3.1 인덱스를 이용한 정렬

<img src="../images/9.2_기본%20데이터%20처리/2025-06-25-13-51-40.png" style="width: 70%; max-width: 500px; height: auto;" />

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.emp_no;

-- emp_no 칼럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동으로 정렬됨.
-- 그래도 ORDER BY e.emp_no를 제거하지 않는게 좋다.
-- ORDER BY가 있다고 해서 불필요한 정렬 작업을 한번더 하지 않음.
-- 오히려 자동으로 정렬안되는 상황을 막아줌.
```

- `ORDER BY`에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, `ORDER BY`의 순서대로 생성된 인덱스가 있어야 함.
- `WHERE`절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 `ORDER BY`는 같은 인덱스를 사용할 수 있어야 함.
- B-TREE 계열 인덱스만 가능
    - 해시 인덱스나 전문 검색 인덱스 등은 인덱스 이용 정렬 불가능
    - R-TREE는 B-TREE 계열이지만 사용 불가능
- 여러 테이블이 조인되는 경우에는 Nested-loop 방식의 조인에서만 사용 가능
    - Nested-loop의 경우 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않음

### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
- 조인 실행 전, 첫 번째 테이블의 레코드를 먼저 정렬 -> 조인 실행
    - 드라이빙 테이블의 칼럼만으로 `ORDER BY`절 작성해야함
    - 조인 수행 시 레코드 수가 몇 배로 늘어나고, 레코드 크기도 증가하기 때문에

<img src="../images/9.2_기본%20데이터%20처리/2025-06-25-13-52-01.png" style="width: 70%; max-width: 500px; height: auto;" />

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.last_name;
```

- `e.emp_no BETWEEN 100002 AND 100020`은 employees 테이블의 프라이머리 키를 이용해 작업량 줄이기
- 드리븐 테이블(salaries)의 조인 칼럼인 emp_no 칼럼에 인덱스가 있음

1. 인덱스 이용해 `e.emp_no BETWEEN 100002 AND 100020` 조건을 만족하는 값 구하기
2. 검색 결과를 last_name으로 정렬하기(Filesort)
3. 정렬된 켤과를 순서대로 읽으면서 salaries 테이블과 조인 수행

### 9.2.3.3.3 임시 테이블을 이용한 정렬

<img src="../images/9.2_기본%20데이터%20처리/2025-06-25-14-14-18.png" style="width: 70%; max-width: 500px; height: auto;" />

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY s.salary;
```

- `ORDER BY`의 정렬 기준 칼럼이 드리븐 테이블에 있는 칼럼
    - 정렬 수행 전, salaries 테이블을 읽어야 한다. 
    - 조인을 정렬보다 먼저 해야함.
- 쿼리 실행 계획의 Extra 칼럼에 "Using temporary: Using filesort" 표시됨

### 9.2.3.3.4 정렬 처리 방법의 성능 비교
- 웹 서비스용 쿼리에서는 `ORDER BY`, `LIMIT` 거의 필수로 사용됨
- `LIMIT` 테이블이나 처리 결과의 일부만 가져옴 
    - -> MySQL 서버의 작업량 줄여줌
- `ORDER BY`, `GROUP BY`의 경우, WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서 처리 불가능
    - 조건 만족하는 모든 레코드 가져와, 정렬 수행하거나 그루핑 작업 선행됨.
- 스트리밍 처리, 버퍼링 처리 방법이 있다.

### 9.2.3.3.4.1 스트리밍 방식

<img src="../images/9.2_기본%20데이터%20처리/2025-06-25-14-45-45.png" style="width: 70%; max-width: 500px; height: auto;" />

- 서버 쪽에서 처리할 데이터가 얼마인지 관게없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식

### 9.2.3.3.4.2 버퍼링 방식

<img src="../images/9.2_기본%20데이터%20처리/2025-06-25-14-48-57.png" style="width: 70%; max-width: 500px; height: auto;" />

- `ORDER BY`, `GROUP BY` 방식은 스트리밍 방식 불가능
- `WHERE` 조건절에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그루핑해서 차례대로 보내야 하기 때문
- 응답 속도 느려짐
- `LIMIT`처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 도움 X
    - 네트워크 전송 레코드 수는 줄일수 있지만
    - MySQL 서버 작업량에는 도움 X

### 정렬 처리 방법의 성능 비교 예시

```sql
SELECT *
FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1 = t2.col1
ORDER BY t1.col2
LIMIT 10;
```

- tb_test1 레코드 수 100건
- tb_test2 레코드 수 1000건
    - tb_test1 레코드 1건당 tb_test2 fpzhem 10건씩 존재 가정
- 두 테이블 조인 결과는 전체 1000건

    <img src="../images/9.2_기본%20데이터%20처리/2025-06-25-15-15-44.png" style="width: 70%; max-width: 500px; height: auto;" />

    <img src="../images/9.2_기본%20데이터%20처리/2025-06-25-15-16-00.png" style="width: 70%; max-width: 500px; height: auto;" />

- 어떤 정렬 방식으로 처리되는지에 따라 더 큰 성능 차이를 보임
    - 어떤 테이블이 먼저 드라이빙 되어 조인되는지도 중요
- 인덱스 사용한 정렬 유도
    - 안되면 최소한 드라이빙 테이블만 정렬하는 수준까지 유도하기

### 9.2.3.4 정렬 관련 상태 변수

```sql
SHOW STATUS LIKE 'Sort%';
```

<img src="../images/9.2_기본%20데이터%20처리/2025-06-25-15-32-02.png" style="width: 70%; max-width: 500px; height: auto;" />

- `Sort_merge_passes`: 멀티 머지 처리 횟수
- `Sort_range`: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
    - 작업 횟수 누적하는 상태 값
- `Sort_rows`: 지금까지 정렬한 전체 레코드 건수
- `Sort_scan`: 풀 데이터 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
    - 작업 횟수 누적하는 상태 값

<br>

# 9.2 추가 내용

## 클러스터링 인덱스의 리프노드 위치
- 버퍼 풀에 있을 수도 있고, 디스크에 있을 수도 있다.
- 즉 디스크 I/O 작업이 발생할 수도 있고, 아닐 수도 있다.
- 참고) **세컨더리 인덱스** 또한 마찬가지다.

## 풀 테이블 스캔에 대한 오해
- [제 블로그 내용 참고](https://kdozlo.tistory.com/87)
