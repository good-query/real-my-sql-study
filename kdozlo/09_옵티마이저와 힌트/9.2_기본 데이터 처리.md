# 9.2 기본 데이터 처리

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

### 풀 테이블 스캔
- 인덱스를 사용하지 않고, 테이블의 데이터를 **처음부터 끝까지** 읽어서 요청된 작업을 처리하는 작업
    - 주의) 클러스터링 인덱스를 통해 테이블의 모든 데이터를 스캔하는 경우도 포함
- 대부분 DBMS는 풀 테이블 스캔시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능이 있음
    - 테이블의 전체 크기가 크기 때문에 디스크 읽기 작업이 많이 필요하기 때문에
- 옵티마이저의 풀 테이블 스캔 조건
    1. 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
        - 보통 테이블 페이지 1개로 구성된 경우
    2. WHERE절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
        - 인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준

### 풀 인덱스 스캔
- 특정 세컨더리 인덱스의 **모든 엔트리(인덱스 레코드)**를 처음부터 끝까지 순차적으로 읽는 경우
- 인덱스 자체가 쿼리에서 필요로 하는 모든 컬럼을 포함하고 있을 때 (즉, 인덱스가 커버링 인덱스일 때) 발생

### MySQL의 풀 테이블 스캔 
- 풀 테이블 스캔 실행 시 한꺼번에 몇 개의 페이지를 읽어올지 설정하는 시스템 변수 없음
- MyISAM의 경우, 풀 테이블 스캔시 디스크로부터 페이지 하나씩 읽어옴
- InnoDB의 경우,
    - 특정 테이블의 연속된 데이터 페이지 읽는 경우, 백그라운드 스레드에 의해 Read ahead 작업 자동으로 시작
    1. 풀 테이블 스캔 실행시, 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행
    2. 특정 시점부터 백그라운드로 읽기 작업이 넘어감
    3. 백그라운드로 넘어간 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 그 수를 증가시킴.
    4. 한 번에 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둠.

### Read ahead
- 어떤 영역의 데이터 앞으로 필요해지리라는 것을 예측하여 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 작업
- 풀 테이블 스캔, 풀 인덱스 스캔에서 사용
- `innodb_read_ahead_threshold`: InnoDB가 언제 리드 어헤드를 시작할지 임계값 설정하는 시스템 변수
- 포그라운드 스레드에 의해 `innodb_read_ahead_threshold` 변수에 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 InnoDB가 백그라운드 스레드를 이용해 대량으로 그다음 페이지들을 읽어서 버퍼 풀로 적재

### `SELECT COUNT(*) FROM employees;` 스캔 방식
- 풀 인덱스 스캔을 할 확률이 높다.
- 단순히 레코드의 건수만 필요로 하는 쿼리이기 때문에
- 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있음.
    - **세컨더리 인덱스**의 경우, 보통 2~3개의 칼럼만으로 구성되기 때문

### `SELECT * FROM employees;` 스캔 방식
- 풀 테이블 스캔
    - InnoDB의 경우 기본적으로 클러스터링 인덱스를 사용하기 때문에 내부적으로 풀 인덱스 스캔을 함.
    - 하지만 풀 테이블 스캔이라고 불리는 이유는 **테이블의 모든 데이터를 읽기 때문**
- 레코드에만 있는 칼럼이 필요한 쿼리이기 때문

## 9.2.2 병렬 처리
- **하나의 쿼리**를 여러 스레드가 작업을 나누어 동시에 처리하는 것을 의미
- MySQL 8.0부터 쿼리 병렬 처리 가능
    - 용도는 한정되어 있음
- `innodb_parallel_read_threads`: 하나의 쿼리 당 최대 몇개의 스레드를 이용해서 처리할지 정하는 시스템 변수
- 병렬 처리는 내부적으로만 수행
    - MySQL에서는 사용자가 병렬 쿼리를 제어하는 힌트/옵션을 제공하지 않음
- 주의) 병렬 처리용 스레드 개수를 아무리 늘리더라도 서버의 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능 저하 발생

## 9.2.3 ORDER BY 처리(Using filesort)


<br>

# 9.2 추가 내용

## 클러스터링 인덱스의 리프노드 위치
- 버퍼 풀에 있을 수도 있고, 디스크에 있을 수도 있다.
- 즉 디스크 I/O 작업이 발생할 수도 있고, 아닐 수도 있다.
- 참고) **세컨더리 인덱스** 또한 마찬가지다.

## 풀 테이블 스캔에 대한 오해
- [제 블로그 내용 참고](https://kdozlo.tistory.com/87)
