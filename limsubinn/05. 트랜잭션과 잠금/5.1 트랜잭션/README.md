## 5.1 트랜잭션

### 5.1.1 MySQL에서의 트랜잭션
> 트랜잭션은 하나의 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT) 아무것도 적용되지 않는 것(ROLLBACK)을 보장한다.

<br>

테스트용 테이블을 생성하고 각 테이블에 레코드를 1건씩 저장한다. <br>

<img width="600" alt="image" src="https://github.com/user-attachments/assets/452e3f38-8d45-483c-aff3-6eafe2bfb331" />
<img width="603" alt="image" src="https://github.com/user-attachments/assets/b2b92287-d638-4c08-b91d-9e18fd18529d" />

이후 AUTO-COMMIT 모드에서 중복된 레코드를 삽입해보자. <br>

<img width="485" alt="image" src="https://github.com/user-attachments/assets/a50d3e05-e1f4-4101-8edf-f6968c67466e" />

두 쿼리 모두 오류가 발생했지만 테이블 조회 결과는 다르다. <br>

<img width="236" alt="image" src="https://github.com/user-attachments/assets/570d86fa-30b3-4052-8cd0-c616736d6c90" />

<br>

**InnoDB**는 쿼리 중 일부라도 오류가 발생하면 트랜잭션의 원칙대로 INSERT 문장을 실행하기 전 상태로 복구한다. <br>

**MyISAM**은 INSERT 문장이 실행되면서 차례대로 '1', '2'를 저장하고, '3'을 저장하면서 오류가 발생했지만, 이미 추가된 레코드를 두고 쿼리 실행을 종료해버린다.
MyISAM 테이블에서 발생하는 이러한 현상을 부분 업데이트(Partitial Update)라고 표현한다.

<br>

### 5.1.2 주의사항
프로그램 코드에서 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션의 범위를 최소화하는 것이 좋다.

- 일반적으로 데이터베이스 커넥션은 개수가 제한적이어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수가 줄어든다.
  그리고 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있다.
- 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.
- 성격이 다른 작업은 별도의 트랜잭션으로 분리하는 것이 좋다.
  또한, 단순 조회 작업은 별도로 트랜잭션을 사용하지 않아도 된다.

<br>

```
e.g.

[BEFORE]
1. 처리 시작
   => 💙 데이터베이스 커넥션 생성
   => 💚 트랜잭션 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장
   <= 💚 트랜잭션 종료(COMMIT)
   <= 💙 데이터베이스 커넥션 반납
10. 처리 완료

[AFTER]
1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 발생 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
   => 💙 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
   => 💚 트랜잭션 시작
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
   <= 💚 트랜잭션 종료(COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
   => 💛 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장
   <= 💛 트랜잭션 종료(COMMIT)
   <= 💙 데이터베이스 커넥션 반납(또는 커넥션 풀에 반납)
```
