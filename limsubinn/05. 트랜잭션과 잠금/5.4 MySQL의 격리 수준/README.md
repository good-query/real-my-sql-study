## 5.4 MySQL의 격리 수준
트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 <br>
특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

- `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`
  - READ UNCOMMITTED는 일반적인 데이터베이스에서 거의 사용하지 않는다. (DIRTY READ)
  - SERIALIZABLE은 동시성이 중요한 데이터베이스에서는 거의 사용하지 않는다.
  - 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지며, 동시 처리 성능이 떨어진다.
- 데이터 부정합의 문제는 격리 수준의 레벨에 따라 발생 여부가 달라진다.
  
   ㅤ | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ
    :--- | :--- | :--- | :---
    READ UNCOMMITTED | O | O | O
    READ COMMITTED | X | O | O
    REPEATABLE READ | X | X | O (InnoDB는 X)
    SERIALIZABLE | X | X | X

<br>

### 5.4.1 READ UNCOMMITTED
각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다. <br>

어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 **DIRTY READ**라 하고, <br>
더티 리드가 허용되는 격리 수준이 **READ UNCOMMITTED**이다. <br>
이 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래하므로 정합성에 문제가 많다. <br>
따라서 MySQL을 사용한다면 최소한 **READ COMMITTED** 이상의 격리 수준을 사용할 것을 권장한다.

<br>

### 5.4.2 READ COMMITTED
오라클 DBMS에서 기본으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. <br>

이 레벨에서는 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다. <br>
따라서 더티 리드와 같은 현상은 발생하지 않는다. <br>

사용자 A가 어떤 레코드에 대해 UPDATE 쿼리를 수행하고 커밋을 수행하기 전에 다른 사용자 B가 SELECT 쿼리를 수행한다면 <br>
해당 쿼리 결과는 테이블이 아니라 언두 영역에 백업된 레코드를 가져와 기존 데이터를 조회할 것이다. <br>
이때 사용자 A가 변경된 내용을 커밋하면 그때부터는 다른 트랜잭션에서도 새로 변경된 값을 참조할 수 있게 된다. <br>

이 격리 수준에서도 **NON-REPEATABLE READ**라는 부정합의 문제가 있다. <br>
처음 사용자 B가 BEGIN 명령으로 트랜잭션을 시작하고 어떤 레코드를 검색했을 때 일치하는 결과가 없었지만, <br>
사용자 A가 변경된 레코드에 대한 커밋을 실행한 후 사용자 B가 똑같은 SELECT 쿼리로 다시 조회했을 때 이번에는 결과가 조회될 것이다. <br>
이는 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 **REPEATABLE READ** 정합성에 어긋난다. <br>

**READ COMMITTED** 격리 수준에서는 트랜잭션 내에서 실행되는 SELECT 문장과 외부에서 실행되는 SELECT 문장의 차이가 별로 없다.

<br>

### 5.4.3 REPEATABLE READ
MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. <br>
바이너리 로그를 가진 MySQL 서버에서는 최소 해당 격리 수준 이상을 사용해야 한다. <br>

InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경한다. <br>
이러한 변경 방식을 MVCC라고 한다. (4.2.3절 참고) <br>

**REPEATABLE READ**는 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여준다. <br>
모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, <br>
언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다. <br>
그리고 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다. <br>
**REPEATABLE READ**에서는 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다. <br>

이 격리 수준에서도 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상인 **PHANTOM READ**가 발생할 수 있다. <br>
`SELECT ... FOR UPDATE` 쿼리는 SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다. <br>
그래서 `SELECT ... FOR UPDATE`나 `SELECT ... LOCK IN SHARE MODE`로 조회되는 레코드는 <br>
언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 된다.

<br>

### 5.4.4 SERIALIZABLE
가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다. <br>
그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다. <br>

**SERIALIZABLE**은 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다. <br>
한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다. <br>

이 격리 수준에서는 일반적인 DBMS에서 일어나는 **PHANTOM READ** 문제가 발생하지 않지만, <br>
InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 **REPEATABLE READ** 격리 수준에서도 **PHANTOM READ**가 발생하지 않기 때문에, <br>
굳이 **SERIALIZABLE**을 사용하지 않아도 될 것 같다.
