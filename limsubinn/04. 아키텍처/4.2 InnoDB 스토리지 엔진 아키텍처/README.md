## 4.2 InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, <br>
그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다. <br>

<img width="600" alt="image" src="https://github.com/user-attachments/assets/e11ac2af-33b3-474d-be05-bdf507288038"> <br>

<br>

### 4.2.1 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. <br>
즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, <br>
모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.

- 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다. <br>
  결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.
- MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않기 때문에 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다. <br>
  또한, 프라이머리 키를 포함한 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)을 가진다.

<br>

### 4.2.2 외래 키 지원
부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, <br>
변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하다.

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.
- 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 외래 키의 존재에 주의하는 것이 좋다.
- `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다. <br>
  하지만 반드시 부모 테이블과 자식 테이블의 일관성을 맞춰준 후 다시 외래 키 체크 기능을 활성화하도록 하자.

<br>

### 4.2.3 MVCC(Multi Version Concurrency Control)
일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, 잠금을 사용하지 않는 일관된 읽기를 제공한다. <br>
InnoDB는 **Undo Log**를 이용해 이 기능을 구현한다. <br>

<br>

```
e.g.

데이터 insert 작업 후 commit O, update 작업 후 commit X
update 문장이 실행되면 InnoDB의 버퍼 풀은 새로운 값을 가지게 되고, 변경 전 값은 언두 로그로 복사한다.
이때 데이터를 조회하면? => 트랜잭션 격리 수준에 따라 결과가 달라진다.

`READ_UNCOMMITTED`인 경우에는 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.
`READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE` 인 경우에는 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.

이 상태에서 commit을 실행하면 InnoDB는 지금의 상태를 영구적인 데이터로 만든다.
하지만 rollback을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다. 
```

<br>

#### 💡 참고

트랜잭션 격리 수준 | 설명
:--- | :---
READ_UNCOMMITTED | 커밋되지 않은 데이터를 읽는다.
READ_COMMITTED | 커밋된 데이터만 읽을 수 있다.
REPEATABLE_READ | 동일 트랜잭션 내에서 동일한 데이터의 결과를 보장한다.
SERIALIZABLE | 트랜잭션을 직렬화된 순서로 실행한다. SELECT 문도 공유 잠금을 획득한다.

- 격리 수준이 높을수록 데이터 일관성은 높아지지만 성능 저하가 발생할 수 있다.

<br>

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent READ)
InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다. <br>
특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다. <br>
InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.

<br>

### 4.2.5 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다. <br>
데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아 그 중 하나를 강제 종료한다. <br>

- 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 언두 로그 양이다. 일반적으로 언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상이 된다.
- `innodb_table_locks` 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있다.
- `innodb_deadlock_detect` 시스템 변수를 `OFF`로 설정하면 데드락 감지 스레드는 작동하지 않는다.
- `innodb_lock_wait_timeout` 시스템 변수는 초 단위로 설정하며, 잠금을 설정한 시간 동안 획득하지 못하면 쿼리는 실패하고 에러를 반환한다.

<br>

### 4.2.6 자동화된 장애 복구
InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다.

- 이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버가 종료된다. <br>
  이때는 MySQL 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 시작해야 한다. <br>
  값이 커질수록 복구 가능성이 적어진다.
  - `1`: 로그 파일 복구만 수행 (기본 복구 수준)
  - `2`: 버퍼 풀에서 수정된 페이지 무시
  - `3`: 일관성 검사 중단 (테이블스페이스 스캔 무시)
  - `4`: 언두 로그 적용 건너뛰기 (롤백 수행 안함)
  - `5`: 복구 시 언두 로그 삭제 (일관성 무시)
  - `6`: 모든 복구 작업 중단 -> 강제 마운트 (읽기 전용)
- 마지막 풀 백업 시점으로부터 장애 시점까지의 바이너리 로그가 있다면 <br>
  InnoDB의 복구를 이용하는 것보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 더 적을 수도 있다.

<br>

### 4.2.7 InnoDB 버퍼 풀 ⭐️
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간 + 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할 

<br>

**1️⃣ 버퍼 풀의 크기 설정**
- MySQL 5.7부터 InnoDB 버퍼 풀의 크기를 동적으로 조절 가능
- 가능하면 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 것이 최적이다.
  - 운영체제의 전체 메모리 공간이 8GB 미만일 경우 전체 메모리의 50% 정도로 설정한다.
  - 8GB 이상이라면 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해서 조금씩 올려가며 최적점을 찾는다.
  - 50GB 이상이라면, 대략 15GB ~ 30GB 정도를 운영체제와 다른 응용 프로그램을 위해 남겨두고 나머지를 버퍼 풀로 할당한다.
- `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있다.
- 버퍼 풀의 크기 변경은 크리티컬하므로 가능하면 MySQL 서버가 한가한 시점을 골라서 진행하는 것이 좋다.
  - 버퍼 풀을 더 크게 변경하는 작업은 시스템 영향도가 크지 않지만, 줄이는 작업은 영향이 매우 크니 주의하자.
- InnoDB 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되는데, 이는 버퍼 풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용된다.
- [버퍼 풀 크기 설정 매뉴얼](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool-resize.html)

<br>

**2️⃣ 버퍼 풀의 구조** 
<br>

InnoDB 스토리지 엔진은 버퍼 풀의 메모리 공간을 페이지 크기(`innodb_page_size`)의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다. 버퍼 풀의 페이지 크기 조각을 관리하기 위해 3개의 자료 구조를 관리한다.

1. **LRU**(Least Recently Used) 리스트: 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 유지해서 디스크 읽기를 최소화 <br>

   <img width="400" alt="image" src="https://github.com/user-attachments/assets/23c50b4b-d1bd-4ec9-a618-90345689aadb"> <br>

   'Old 서브리스트' 영역은 Least Recently Used 형태, 'New 서브리스트' 영역은 Most Recently Used 형태 <br>

    ```
   <InnoDB 스토리지 엔진에서 데이터를 찾는 과정>

   1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
       A. InnoDB 어댑티브 해시 인덱스(자주 사용되는 값을 해시로 사용) 이용
          [참고] https://tech.kakao.com/posts/319
       B. 해당 테이블의 인덱스(B-Tree) 이용
       C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
   2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
   3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
   4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(age)가 부여되며,
       버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고(aging) 결국 해당 페이지는 버퍼 풀에서 제거된다.
       버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.
   5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

   => 처음 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 MRU 영역에서 계속 살아남게 되고,
      반대로 거의 사용되지 않는다면 LRU의 끝으로 밀려나 결국은 InnoDB 버퍼 풀에서 제거될 것이다.
   ```
  
2. **플러시(Flush)** 리스트: 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리

   - 디스크에서 읽은 상태 그대로 전혀 변경이 없다면 플러시 리스트에 관리되지 않는다.
   - 한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록되어야 한다.
   - 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
   - InnoDB 스토리지 엔진은 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화하게 된다.

3. **프리(Free)** 리스트: 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록

   - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
  
<br>

**3️⃣ 버퍼 풀과 리두 로그** 
<br>

InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있다. <br>
이때 버퍼 풀의 메모리 공간을 늘리는 것은 데이터 캐시 기능을 향상시키는 것이고, <br>
쓰기 버퍼링 기능까지 향상시키려면 InnoDB 버퍼 풀과 리두 로그와의 관계를 이해해야 한다. 

![image](https://github.com/user-attachments/assets/25422882-13e7-432a-bfe3-1f3a94629a65) <br>

- InnoDB 버퍼 풀은 클린 페이지(디스크에서 읽은 상태로 전혀 변경되지 않음)와 더티 페이지(변경된 데이터를 가짐)를 가지고 있다.
- 더티페이지는 디스크와 데이터 상태가 다르기 때문에 언젠가는 디스크로 기록되어야 한다. 하지만 무한정 버퍼 풀에 머무를 수는 없다.
- InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 불가능한 공간을 구분해서 관리한다.
  재사용 불가능한 공간을 활성 리두 로그(Active Redo Log)라고 한다. (그림에서 화살표를 가진 엔트리들)
- 리두 로그 파일의 공간은 계속 순환되면서 재사용되고, 매번 기록될 때마다 로그 포지션은 계속 증가된 값인 LSN(Log Sequence Number)을 갖게 된다.
- InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화하는데,
  이렇게 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다.
- 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 체크포인트 에이지(Checkpoint Age)라고 한다.
  즉, 체크포인트 에이지는 활성 리두 로그 공간의 크기를 일컫는다.
- InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고,
  체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화되어야 한다.

```
e.g

1. InnoDB 버퍼 풀 100GB, 리두 로그 파일의 전체 크기 100MB
=> 리두 로그 파일의 크기가 100MB이기 때문에 체크포인트 에이지도 최대 100MB 허용.
   평균 리두 로그 엔트리가 4KB라면 25600개(100MB/4KB) 정도의 더티 페이지만 버퍼 풀에 보관 가능.
   데이터 페이지가 16KB라면 허용 가능한 더티 페이지의 크기는 400MB(25600*16KB).
   따라서 버퍼 풀의 크기가 매우 크지만 쓰기 버퍼링을 위한 효과는 거의 못 보는 상황.

2. InnoDB 버퍼 풀 100MB, 리두 로그 파일의 전체 크기 100GB
=> 리두 로그 파일의 크기가 100GB이기 떄문에 체크포인트 에이지는 최대 100GB 허용.
   1번과 같은 방식으로 계산하면 400GB의 더티 페이지를 가질 수 있지만,
   버퍼 풀의 크기가 100MB이기 때문에 최대 허용 가능한 더티 페이지는 100MB.

둘 다 좋지 않은 설정이다.

처음부터 리두 로그 파일의 크기를 적절히 선택하기 어렵다면
버퍼 풀의 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체 크기를 대략 5~10GB 수준으로 선택하고
필요할 때마다 조금씩 늘려가면서 최적값을 선택하자.
```

<br>

**4️⃣ 버퍼 풀 플러시(Buffer Pool Flush)**
<br>

InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행한다.

1. **플러시 리스트(Flush_list) 플러시**
   <br>
   
   InnoDB 버퍼 풀의 더티 페이지를 디스크로 동기화하기 위해 InnoDB 스토리지 엔진은 주기적으로 플러시 리스트 플러시 함수를 호출해서
   플러시 리스트에서 오래전에 변경된 데이터 페이지를 순서대로 디스크에 동기화하는 작업을 수행한다.

   - `innodb_page_cleaners`: 클리너 스레드(더티 페이지를 디스크로 동기화하는 스레드)의 개수를 조정
   - `innodb_max_dirty_pages_pct_lwn`: 일정 수준 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록
   - `innodb_max_dirty_pages_pct`: 더티 페이지의 비율 조정
   - `innodb_io_capacity`: 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준의 값
   - `innodb_io_capacity_max`: 디스크가 최대의 성능을 발휘할 때 어느 정도의 디스크 읽고 쓰기가 가능한지 설정
   - `innodb_flush_neighbors`: 더티 페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중 더티 페이지가 있다면
                               InnoDB 스토리지 엔진이 함께 묶어서 디스크로 기록하게 해주는 기능을 활성화할지 결정
   - `innodb_adaptive_flushing`: 어댑티브 플러시(Adaptive flush) 기능 ON/OFF. 기본값은 ON <br>
     💡 데이터 변경이 많아져 버퍼 풀에서 디스크로 써야 할 페이지가 많아지면, InnoDB가 이를 감지하고 플러시 비율을 자동 조정
   - `innodb_adaptive_flushing_lwm`: 어댑티브 플러시 알고리즘이 작동하는 활성 리두 로그 공간의 값 기준. 기본값은 10%

2. **LRU 리스트(LRU_list) 플러시**
   <br>

   InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데,
   이를 위해 LRU 리스트 플러시 함수가 사용된다.

   - InnoDB 스토리지 엔진은 LRU 리스트의 끝부분부터 시작해서 최대 `innodb_lru_scan_depth`에 설정된 개수만큼의 페이지들을 스캔한다.
   - 스캔하면서 더티 페이지는 디스크에 동기화하고, 클린 페이지는 즉시 프리(Free) 리스트로 페이지를 옮긴다.
   - InnoDB 버퍼 풀 인스턴스별로 스캔한다.

<br>

**5️⃣ 버퍼 풀 상태 백업 및 복구**
<br>

워밍업(Warming Up): 디스크의 데이터가 버퍼 풀에 적재되어 있는 상태 <br>
버퍼 풀이 잘 워밍업된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보이는 것이 일반적이다.

MySQL 서버를 재시작해야 하는 경우 MySQL 서버를 셧다운하기 전에 `innodb_dump_now`를 `ON`으로 설정하여 현재 InnoDB 버퍼 풀의 상태를 백업할 수 있다.
그리고 MySQL 서버를 다시 시작하면 `innodb_buffer_pool_load_now`를 `ON`으로 설정하여 백업된 버퍼 풀의 상태를 다시 복구할 수 있다.

- InnoDB 버퍼 풀의 백업은 데이터 디렉터리에 `ib_buffer_pool`이라는 이름의 파일로 생성되는데,
  InnoDB 스토리지 엔진이 버퍼 풀의 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장한다.
  따라서 버퍼 풀의 백업은 매우 빠르지만 복구하는 과정은 상당한 시간이 걸릴 수도 있다.
- 버퍼 풀을 다시 복구하는 과정이 어느 정도 진행됐는지 확인
  ```sql
  mysql> SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'\G
  ```
  💡 참고 <br>
  ![image](https://github.com/user-attachments/assets/a46af9d4-ee29-4b11-bc63-af303dd89219)
- `innodb_buffer_pool_load_abort`를 `ON`으로 설정하여 버퍼 풀 적재 작업을 중간에 멈출 수 있다.
- 버퍼 풀의 백업과 복구를 자동화하려면 `innodb_buffer_pool_dump_at_shutdown`과 `innodb_buffer_pool_load_at_startup` 설정을
  MySQL 서버의 설정 파일에 넣어두면 된다.

<br>

**6️⃣ 버퍼 풀의 적재 내용 확인**
<br>

MySQL 5.6부터 MySQL 서버의 `information_schema` 데이터베이스의 `innodb_buffer_page` 테이블을 이용해 <br>
InnoDB 버퍼 풀의 메모리에 어떤 테이블의 페이지들이 적재되어 있는지 확인할 수 있었다.

MySQL 8.0에서는 InnoDB 버퍼 풀이 큰 경우 이 테이블 조회가 상당히 큰 부하를 일으키면서 서비스 쿼리가 느려지는 문제를 해결하기 위해 <br>
`information_schema` 데이터베이스에 `innodb_cached_indexes` 테이블이 새로 추가됐다. <br>
이 테이블을 이용하면 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재되어 있는지 확인할 수 있다. 
<br>

```sql
mysql> SELECT
         it.name table_name,
         ii.name index_name,
         ici.n_cached_pages n_cached_pages
       FROM information_schema.innodb_tables it
         INNER JOIN information_schema.innodb_indexes ii ON ii.table_id it.table_id
         INNER JOIN information_schema.innodb_cached_indexes ici ON ici.index_id = ii.index_id
       WHERE it.name = CONCAT(schema_name, '/', table_name);
```

<br>

### 4.2.8 Double Write Buffer
InnoDB 엔진에서는 페이지가 일부만 기록되는 현상(파셜 페이지 or 톤 페이지)을 막기 위해 Double-Write 기법을 이용한다. <br>
DoubleWrite 기능을 사용할지 여부는 `innodb_doublewrite` 시스템 변수로 제어할 수 있다.

<img width="400" alt="image" src="https://github.com/user-attachments/assets/bd61e976-78a6-4001-b687-8cbbda112b13"> <br>

'A' ~ 'E'까지의 더티 페이지를 디스크로 플러시한다고 가정해보자. <br>
InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 'A' ~ 'E' 더티 페이지를 우선 묶어서 <br>
한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다. <br>
그리고 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다. <br>

실제 데이터 파일에 'A' ~ 'E' 더티 페이지가 정상적으로 기록되면 DoubleWrite 버퍼 공간에 기록된 변경 내용은 더이상 필요가 없어진다. <br>
InnoDB 스토리지 엔진은 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해서 <br>
다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다. 

<br>

### 4.2.9 언두 로그
InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한다.
이렇게 백업된 데이터를 **언두 로그(Undo Log)** 라고 한다.

- 트랜잭션 보장
- 격리 수준 보장

<br>

**1️⃣ 언두 로그 모니터링**
<br>

MySQL 5.5까지는 한 번 늘어난 언두 로그의 사용 공간을 다시 줄일 수 없었다. <br>
하지만 언두 로그가 늘어나면 디스크 사용량뿐만 아니라 매번 백업할 때도 그만큼 더 복사를 해야 하는 문제점이 발생한다. <br>

MySQL 5.7부터 언두 로그 공간의 문제점이 해결되었다. <br>
MySQL 8.0에서는 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것도 가능하며, <br>
때로는 MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여 주기도 한다. <br>

하지만 여전히 서비스 중인 MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않다. <br>
그래서 MySQL 서버의 언두 로그가 얼마나 증가했는지 항상 모니터링하는 것이 좋다. <br>

```sql
# MySQL 서버의 모든 버전에서 사용 가능한 명령
mysql> SHOW ENGINE INNODB STATUS \G
```
![image](https://github.com/user-attachments/assets/428d6a87-13eb-427c-b055-bf9a6126b18a)

```sql
# MySQL 8.0 버전에서 사용 가능한 명령
mysql> SELECT count
       FROM information_schema.innodb_metrics
       WHERE SUBSYSTEM = 'transaction' AND NAME = 'trx_rseg_history_len';
```
![image](https://github.com/user-attachments/assets/dc593413-271e-4851-8a2b-1e500cd748a5)

<br>

**2️⃣ 언두 테이블스페이스 관리**
<br>

언두 로그가 저장되는 공간을 언두 테이블스페이스(Undo Tablespace)라고 한다. <br>

- MySQL 5.6 이전에서는 언두 로그가 모두 시스템 테이블스페이스(ibdata.ib)에 저장됐다. <br>
  MySQL 5.6부터는 `innodb_undo_tablespaces` 시스템 변수가 도입됐고, <br>
  해당 변수를 2보다 큰 값으로 설정하면 별도의 언두 로그 파일을 사용했다. (0은 여전히 시스템 테이블스페이스 사용) <br>
  MySQL 8.0부터는 해당 시스템 변수가 Deprecated, **언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선됐다.**

- 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯을 가진다. <br>
  하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나눈 값의 개수만큼의 언두 슬롯을 가진다. <br>
  <img width="400" alt="image" src="https://github.com/user-attachments/assets/daf173c9-edbd-47cf-bedd-bf7c21b89234">

- 하나의 트랜잭션은 INSERT, UPDATE, DELETE 문장의 특성에 따라 최대 4개까지 언두 슬롯을 사용한다. <br>
  일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로 하나의 트랜잭션이 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 된다. <br>
  그래서 최대 동시 처리 가능한 트랜잭션의 개수는 다음 수식으로 예측해볼 수 있다. <br>

  ```
  최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
  ```

- 언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다. <br>
  언두 로그 관련 시스템 변수를 변경할 때 적절히 필요한 동시 트랜잭션 개수에 맞게 <br>
  언두 테이블스페이스와 롤백 세그먼트의 개수를 설정해야 한다. <br>

- MySQL 8.0부터는 새로운 언두 테이블스페이스를 동적으로 추가하고 삭제할 수 있다. <br>
  ```sql
  # 언두 테이블스페이스 추가
  mysql> CREATE UNDO TABLESPACE tablespace_name;

  # 언두 테이블스페이스 삭제
  mysql> DROP UNDO TABLESPACE tablespace_name;
  ```

- 언두 테이블스페이스 공간을 필요한 만큼만 남기고 운영체제로 반납하는 것을 'Undo tablespace truncate'라고 한다. <br>
  언두 테이블스페이스의 불필요한 공간을 잘라내는 방법은 자동과 수동으로 두 가지 방법이 있다. (MySQL 8.0~)
  - 자동 모드: `innodb_undo_log_truncate` 시스템 변수가 `ON`으로 설정되면 퍼지 스레드가 주기적으로 언두 로그 파일에서 사용되지 않는 공간을 잘라내고 운영체제로 반납한다.
  - 수동 모드: `innodb_undo_log_truncate` 시스템 변수가 `OFF`로 설정되거나 예상보다 자동 모드로 언두 테이블스페이스의 공간 반납이 부진한 경우,
             언두 테이블스페이스를 비활성화해서 언두 테이블스페이스가 더이상 사용되지 않도록 설정하면
             퍼지 스레드가 비활성 상태의 언두 테이블 스페이스를 찾아서 불필요한 공간을 잘라내고 운영체제로 해당 공간을 반납한다.
             반납이 완료되면 언두 테이블스페이스를 다시 활성화한다.
    ```sql
    # 언두 테이블스페이스 비활성화
    mysql> ALTER UNDO TABLESPACE tablespace_name SET INACTIVE;
    
    # 퍼지 스레드에 의해 언두 테이블스페이스 공간이 반납되면 다시 활성화
    mysql> ALTER UNDO TABLESPACE tablespace_name SET ACTIVE;
    ```

<br>

### 4.2.10 체인지 버퍼
InnoDB는 변경해야 할 인덱스 페이지가 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 메모리 공간인 **체인지 버퍼(Change Buffer)** 에 저장해두고 바로 사용자에게 결과를 반환한다. 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 되기 때문이다.

- 유니크 인덱스는 체인지 버퍼를 사용할 수 없다. (사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 함)
- 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드인 `체인지 버퍼 머지 스레드(Merge thread)`에 의해 병합된다.
- MySQL 8.0부터는 `INSERT`, `DELETE`, `UPDATE`로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 가능하다. (5.5까지는 `INSERT`만 가능)
- MySQL 5.5부터는 `innodb_change_buffering` 시스템 변수를 통해 작업의 종류별로 체인지 버퍼를 활성화할 수 있다. (기존에는 기본적으로 활성화)
  - `all`: 모든 인덱스 관련 작업을 버퍼링
  - `none`: 버퍼링 안 함
  - `inserts`: 인덱스에 새로운 아이템을 추가하는 작업만 버퍼링
  - `deletes`: 인덱스에 기존 아이템을 삭제하는 작업만 버퍼링
  - `changes`: 인덱스에 추가하고 삭제하는 작업만 버퍼링
  - `purges`: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링(백그라운드 작업)
- 체인지 버퍼는 `innodb_change_buffer_max_size` 시스템 변수를 이용하여 버퍼 풀 사용 공간 비율을 설정할 수 있다. (기본 25%, 최대 50%)

<br>

### 4.2.11 리두 로그 및 로그 버퍼
리두 로그는 MySQL 서버가 비정상적으로 종료됐을 떄 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전 장치다. (영속성) <br>

거의 모든 DBMS에서 데이터 파일은 쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있기 때문에 <br>
데이터베이스 서버는 쓰기 비용이 낮은 자료 구조를 가진 **리두 로그**를 가지고 있으며, <br>
비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다. <br>

데이터베이스 서버는 성능도 중요하기 때문에 데이터 파일뿐만 아니라 <br>
리두 로그를 버퍼링할 수 있는 **InnoDB 버퍼 풀**이나 **로그 버퍼**와 같은 자료 구조도 가지고 있다. <br>

- MySQL 서버가 비정상 종료되는 경우, 다음과 같은 두 가지 종류의 일관되지 않은 데이터를 가질 수 있다.
  - 커밋됐지만 데이터 파일에 기록되지 않은 데이터 <br>
     : 리두 로그에 저장된 데이터를 데이터 파일에 복사한다.
  - 롤백됐지만 데이터 파일에 이미 기록된 데이터 <br>
     : 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 데이터 파일에 복사한다. 리두 로그는 그 변경이 커밋됐는지, 롤백됐는지, 트랜잭션의 실행 중간 상태였는지를 확인하기 위해 필요하다.

- `innodb_flush_log_at_trx_commit` 시스템 변수를 이용하여 리두 로그를 어느 주기로 디스크에 동기화할지를 설정할 수 있다.
  - `0`: 1초에 한 번씩 리두 로그를 디스크로 기록하고 동기화를 실행한다.
  - `1`: 매번 트랜잭션이 커밋될 때마다 디스크로 기록되고 동기화까지 수행한다.
  - `2`: 매번 트랜잭션이 커밋될 때마다 디스크로 기록은 되지만 실질적인 동기화는 1초에 한 번씩 실행된다.

- `innodb_log_file_size` 시스템 변수를 이용하여 리두 로그 파일의 크기를 설정할 수 있다.
- `innodb_log_files_in_group` 시스템 변수를 이용하여 리두 로그 파일의 개수를 설정할 수 있다.

<br>

**1️⃣ 리두 로그 아카이빙** 
<br>

MySQL 서버에 유입되는 데이터 변경이 너무 많으면 리두 로그가 빠르게 증가하고, 새로 추가되는 리두 로그 내용을 복사하기도 전에 덮어쓰일 수도 있다. <br>
이렇게 아직 복사하지 못한 리두 로그가 덮어쓰이면 백업 툴이 리두 로그 엔트리를 복사할 수 없어 백업은 실패하게 된다. <br>
MySQL 8.0부터는 리두 로그를 아카이빙할 수 있는 기능이 추가됐다. 데이터 변경이 많아 리두 로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해준다. <br>

- `innodb_redo_log_archive_dirs` 시스템 변수를 이용하여 MySQL 서버에서 아카이빙된 리두 로그가 저장될 디렉터리를 설정한다. <br>
  이 디렉터리는 운영체제의 MySQL 서버를 실행하는 유저(일반적으로 mysql 유저)만 접근이 가능해야 한다.
- `innodb_redo_log_archive_start` UDF(사용자 정의 함수: User Defined Function)를 실행하여 리두 로그 아카이빙을 시작하도록 한다.
  - 첫 번째 파라미터: 리두 로그를 아카이빙할 디렉터리에 대한 레이블
  - 두 번째 파라미터: 서브디렉터리의 이름 (옵션)
- 리두 로그 아카이빙은 로그 파일이 로테이션될 때 복사되는 것이 아니라 리두 로그 파일에 로그 엔트리가 추가될 때 함께 기록되는 방식을 사용하고 있다. <br>
  따라서 데이터 변경이 발생하면 즉시 아카이빙된 로그 파일의 크기가 조금씩 늘어나는 것을 확인할 수 있다.
- `innodb_redo_log_archive_stop` UDF를 실행하여 리두 로그 아카이빙을 멈추고 아카이빙 파일도 종료한다. 파일 삭제를 하지는 않는다.
- `innodb_redo_log_archive_start` UDF를 실행한 세션이 정상적으로 멈추지 않고 연결이 끊어진다면, 리두 로그 아카이빙을 멈추고 아카이빙 파일도 자동으로 삭제된다.

<br>

**2️⃣ 리두 로그 활성화 및 비활성화**
<br>

리두 로그는 항상 활성화되어 있다. <br>
따라서 MySQL 서버에서 트랜잭션이 커밋되어도 데이터 파일은 즉시 디스크로 동기화되지 않지만, 리두 로그는 항상 디스크로 기록된다. <br>

MySQL 8.0부터 수동으로 리두 로그를 활성화하거나 비활성화할 수 있게 되었다.
```sql
# 리두 로그 비활성화
mysql> ALTER INSTANCE DISABLE INNODB REDO_LOG;

# 리두 로그 활성화
mysql> ALTER INSTANCE ENABLE INNODB REDO_LOG;

# 리두 로그 활성화 상태 확인
mysql> SHOW GLOBAL STATUS LIKE 'Innodb_redo_log_enabled';
```
<br>

리두 로그를 비활성화하고 데이터 적재 작업을 실행했다면 데이터 적재 완료 후 반드시 리두 로그를 다시 활성화하도록 한다. <br>
데이터가 일부 손실되어도 괜찮다면 리두 로그를 비활성화하는 것보다 `innodb_flush_log_at_trx_commit`을 0 또는 2로 설정하는 것을 권장한다.

<br>

### 4.2.12 어댑티브 해시 인덱스
InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스 <br>

B-Tree 인덱스에서 특정 값을 찾기 위해서는 루트 노드를 거쳐 브랜치 노드, 리프 노드까지 찾아가야 원하는 레코드를 읽을 수 있다. <br>
어댑티브 해시 인덱스는 이러한 B-Tree 검색 시간을 줄여주기 위해 도입된 기능이다. <br>
InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, <br>
필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다. <br>

해시 인덱스는 '인덱스 키 값'과 해당 인덱스 키 값이 저장된 '데이터 페이지 주소'의 쌍으로 관리되는데, <br>
인덱스 키 값은 'B-Tree 인덱스의 고유번호(Id)와 B-Tree 인덱스의 실제 키 값' 조합으로 생성된다. <br>
'B-Tree 인덱스의 고유번호'가 포함되는 이유는 InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재하기 때문이다. <br>
'데이터 페이지 주소'는 데이터 페이지의 메모리 주소를 가지는데, 이는 InnoDB 버퍼 풀에 로딩된 페이지의 주소를 의미한다. <br>
따라서 어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리된다. <br>

- `innodb_adaptive_hash_index` 시스템 변수를 이용해서 어댑티브 해시 인덱스 기능 활성화 및 비활성화가 가능하다.
- MySQL 8.0부터는 내부 잠금(세마포어) 경합을 줄이기 위해 어댑티브 해시 인덱스의 파티션 기능을 제공한다. <br>
  `innodb_adaptive_hash_index_parts` 시스템 변수를 이용해 파티션 개수를 설정할 수 있다. (기본값 8개)
  
  > InnoDB는 어댑티브 해시 인덱스에 접근할 때도 내부적으로 세마포어를 사용해서 동기화한다. <br>
  > 하지만 MySQL 8.0 이전에는 어댑티브 해시 인덱스가 하나의 글로벌 구조였기 때문에, <br>
  > 여러 스레드가 어댑티브 해시 인덱스에 동시에 접근하면 하나의 세마포어를 두고 경합이 일어나 병목 현상이 생겼다. <br>
  > 따라서 어댑티브 해시 인덱스를 파티션해서 각각의 파티션에 별도의 세마포어를 할당함으로써 세마포어 경합을 줄인 것!
  
- 어댑티브 해시 인덱스가 성능 향상에 크게 도움이 되지 않는 경우도 있다.
  - 디스크 읽기가 많은 경우
  - 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴 검색)
  - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
- 다음과 같은 경우는 성능 향상에 많은 도움이 된다.
  - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우 (디스크 읽기가 많지 않은 경우)
  - 동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
  - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
- 어댑티브 해시 인덱스는 테이블 변경 및 삭제 작업에 많은 영향을 미친다.
- 어댑티브 해시 인덱스의 효율은 해시 인덱스 히트율, 어댑티브 해시 인덱스가사용 중인 메모리 공간, 서버의 CPU 사용량을 종합해서 판단해야 한다.
  ```sql
  # 어댑티브 해시 인덱스의 메모리 사용량 확인
  mysql> SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
         FROM performance_schema.memory_summary_global_by_event_name
         WHERE EVENT_NAME = 'memory/innodb/adaptive hash index';
  ```

<br>

**💡참고**

- Race Condition이란?
  - 둘 이상의 스레드 또는 프로세스가 동시에 공유 자원에 접근할 때, 그 순서나 타이밍에 따라 결과가 달라지는 상태
  - 예상치 못한 결과를 낳을 수 있고, Deadlock과 같은 문제가 발생할 수 있다. 또한, 스레드의 경쟁 상황으로 인해 성능이 저하된다.

- 세마포어와 뮤텍스는 여러 개의 스레드 또는 프로세스가 공유 자원에 접근할 때 충돌을 방지하기 위해 사용되는 동기화 기법이다.
  - 뮤텍스
    - 한 번에 하나의 스레드만 공유 자원에 접근할 수 있다.
    - 뮤텍스를 획득한 스레드만 획득 가능 (소유 개념 존재)
    - 이진 상태(locked/unlocked)
  - 세마포어
    - 임계 영역에 접근할 수 있는 스레드의 수를 제한한다.
    - 소유 개념이 없다.
    - 이진 세마포어(뮤텍스와 비슷하게 동작) / 카운팅 세마포어

<br>

### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

기존 | MySQL 5.5~ | MySQL 8.0~
:--- | :--- | :---
MyISAM | 기본: InnoDB 스토리지 엔진 / 시스템 테이블: MyISAM | InnoDB 스토리지 엔진
