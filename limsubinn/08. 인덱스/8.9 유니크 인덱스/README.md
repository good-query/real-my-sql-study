## 8.9 유니크 인덱스
유니크는 인덱스라기보다는 제약 조건에 가깝다고 볼 수 있다. <br>
말 그대로 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데, MySQL에서는 인덱스 없이 유니크 제약만 설정할 수 없다. <br>
유니크 인덱스는 NULL을 허용한다. 이는 특정 값이 아니므로 2개 이상 저장될 수 있다. <br>
MySQL의 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여된다.

<br>

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교
#### 1️⃣ 인덱스 읽기
유니크하지 않은 세컨더리 인덱스와 유니크한 인덱스는 성능 차이가 거의 없다. <br>
유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 CPU에서 컬럼값을 비교하는 작업이다. <br>

<br>

💡 참고
> 1. 유니크한 인덱스 <br>
> `WHERE idx_col = X` 조회 시 B-Tree 탐색으로 바로 딱 하나의 리프 노드(단일 엔트리)에 도달한다. <br>
> 추가 비교 연산 없이 그 자리에서 곧바로 레코드를 가져오면 되므로, CPU에서 컬럼값을 비교할 필요가 없다. <br>
>
> 2. 유니크하지 않은 세컨더리 인덱스 <br>
> `WHERE idx_col = X` 조회 시 B-Tree에서 값 X가 처음 등장하는 위치를 찾지만, <br>
> 그 값이 여러 개일 수 있기 때문에 같은 페이지 안에서(혹은 인접 페이지로 이어가며) <br>
> 각각의 인덱스 엔트리에 저장된 키가 실제 X와 일치하는지 확인한다.

<br>

유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이고, 인덱스 자체의 특성 때문에 느린 것이 아니다. <br>
하나의 값을 검색하는 경우, 유니크 인덱스와 일반 세컨더리 인덱스는 사용되는 실행 계획이 다르다. <br>
하지만 이는 인덱스의 성격이 유니크한지 아닌지에 따른 차이일 뿐이다.

<br>

#### 2️⃣ 인덱스 쓰기
유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느리게 작동한다. <br>

1. 새로운 레코드가 INSERT되거나 인덱스 컬럼의 값이 변경되는 경우 인덱스 쓰기 작업이 필요한데, 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다.
2. MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데, 이 과정에서 데드락이 아주 많이 발생한다.
3. InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용되어 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만, 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못한다.

   > InnoDB는 변경해야 할 인덱스 페이지가 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 메모리 공간인 체인지 버퍼(Change Buffer) 에 저장해두고 바로 사용자에게 결과를 반환한다.
   > 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 되기 때문이다.

<br>

### 8.9.2 유니크 인덱스 사용 시 주의사항
꼭 필요한 경우라면 유니크 인덱스를 생성하는 것은 당연하지만, 성능이 더 좋아질 것으로 생각하고 불필요하게 생성하지 않는 것이 좋다. <br>

그리고 하나의 테이블에서 같은 컬럼에 유니크 인덱스와 일반 인덱스를 각각 중복해서 생성하는 경우와 <br>
똑같은 컬럼에 대해 프라이머리 키와 유니크 인덱스를 중복해서 생성하는 경우는 모두 불필요하다.
