## 8.8 클러스터링 인덱스
MySQL 서버에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원한다. <br>

<br>

### 8.8.1 클러스터링 인덱스
**프라이머리 키**에 대해서만 적용된다. 프라이머리 키 값이 비슷한 레코드들끼리 묶어서 저장하는 것을 말한다. <br>
프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다. 따라서 프라이머리 키를 신중하게 결정해야 한다. <br>

일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, <br>
대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다. <br><br>

<img width="600" alt="image" src="https://github.com/user-attachments/assets/28f85c6f-0bfb-4794-aeb5-0b0cd81cdde7"> <br><br>
클러스터링 인덱스의 구조는 B-Tree와 비슷하다. <br>
하지만 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있다. <br>
즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것이다. <br>

한 레코드의 프라이머리 키 값이 변경된다면 실제 데이터 레코드의 위치가 변경될 것이다. <br>
예를 들어, 위의 그림에서 emp_no가 100007인 레코드는 3번 페이지에 저장되어 있는데, <br>
emp_no의 값을 100002로 변경한다면 2번 페이지로 이동할 것이다. <br>
따라서 클러스터링 테이블에서 프라이머리 키 값의 결정이 중요한 것이다. <br>
실제로 프라이머리 키의 값이 변경되는 경우는 거의 없을 것이다. <br>

프라이머리 키가 없는 경우에는 InnoDB 스토리지 엔진이 다음 우선순위대로 프라이머리 키를 대체할 컬럼을 선택한다. <br>
1. 프라이머리 키
2. NOT NULL 옵션의 UNIQUE INDEX 중 첫 번째 인덱스
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가
<br>

InnoDB 스토리지 엔진이 적절한 클러스터링 키 후보를 찾지 못하는 경우 내부적으로 레코드의 일련번호 컬럼을 생성하고, <br>
이러한 프라이머리 키는 사용자에게 노출되지 않고 쿼리 문장에 명시적으로 사용할 수 없다. (아무 의미 없는 값으로 클러스터링되는 것) <br>
가능하다면 프라이머리 키를 명시적으로 생성하도록 하자. <br>
<br>

### 8.8.2 세컨더리 인덱스에 미치는 영향
MyISAM이나 MEMORY 테이블과 같은 경우, 데이터가 INSERT될 때 처음 저장된 공간에서 절대 이동하지 않는다. <br>
데이터 레코드가 저장된 주소는 내부적인 ROWID 역할을 하고, <br>
프라이머리 키나 세컨더리 인덱스의 각 키는 그 주소를 이용하여 실제 데이터 레코드를 찾는다. <br>
그래서 MyISAM이나 MEMORY 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다. <br>

InnoDB 테이블에서의 모든 세컨더리 인덱스는 프라이머리 키 값을 저장한다. <br>
만약 InnoDB에서 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면, 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고, <br>
그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다. <br>
따라서 오버헤드를 제거하기 위해 해당 레코드가 저장된 주소가 아닌 프라이머리 키 값을 저장한다. <br>

인덱스가 설정된 컬럼으로 검색 시 프라이머리 키로 클러스터링된 InnoDB와 그렇지 않은 MyISAM에서 어떤 차이가 있는지 한번 살펴보자.
```sql
mysql> CREATE TABLE employees (
          emp_no INT NOT NULL,
          first_name VARCHAR(20) NOT NULL,
          PRIMARY KEY (emp_no),
          INDEX ix_firstname (first_name)
       );

mysql> SELECT * FROM employees WHERE first_name = 'Aamer';
```
- MyISAM: ix_firstname 인덱스를 검색해 레코드의 주소를 확인한 후, 레코드의 주소를 이용해 최종 레코드를 가져온다.
- InnoDB: ix_firstname 인덱스를 검색해 레코드의 프라이머리 키 값을 확인한 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져온다.

<br>

### 8.8.3 클러스터링 인덱스의 장점과 단점
- 장점: 빠른 읽기(SELECT)
  - 프라이머리 키로 검색할 때 처리 성능이 매우 빠르다. (특히 범위 검색)
  - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다. (커버링 인덱스)
- 단점: 느린 쓰기(INSERT, UPDATE, DELETE)
  - 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다.
  - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느리다.
  - INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느리다.
  - 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느리다.

<br>

일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경에서는 쓰기와 읽기의 비율이 2:8 또는 1:9 정도이기 때문에 <br>
조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것은 매우 중요하다.

<br>

### 8.8.4 클러스터링 테이블 사용 시 주의사항
#### 1️⃣ 클러스터링 인덱스 키의 크기
클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함하기 때문에 <br>
프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다. <br>
또한, 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 더 필요해진다.

<br>

#### 2️⃣ 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 컬럼으로 생성(가능한 경우)
InnoDB의 프라이머리 키는 클러스터링 키로 사용되며, 이 값에 의해 레코드의 위치가 결정된다. <br>
즉, 프라이머리 키로 검색하는 경우 클러스터링되지 않은 테이블에 의해 매우 빠르게 처리될 수 있다. <br>
또한, 프라이머리 키는 대부분 검색에서 상당히 빈번하게 사용되는 것이 일반적이다. <br>
따라서 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 프라이머리 키로 설정하는 것이 좋다.

<br>

#### 3️⃣ 프라이머리 키는 반드시 명시할 것
가능하면 AUTO_INCREMENT 컬럼을 이용해서라도 프라이머리 키는 생성하는 것을 권장한다. <br>
InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 InnoDB 스토리지 엔진이 내부적으로 일련번호 컬럼을 추가한다. <br>
하지만 이렇게 자동으로 추가된 컬럼은 사용자에게 보이지 않기 때문에 사용자가 전혀 접근할 수 없다. <br>
또한, ROW 기반의 복제나 InnoDB Cluster에서는 모든 테이블이 프라이머리 키를 가져야 정상적인 복제 성능을 보장하기도 한다.

<br>

#### 4️⃣ AUTO-INCREMENT 컬럼을 인조 식별자로 사용할 경우
여러 개의 컬럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어질 때가 가끔 있다. <br>
하지만 프라이머리 키의 크기가 길어도 세컨더리 인덱스가 필요하지 않다면 그대로 프라이머리 키를 사용하는 것이 좋다. <br>
세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 컬럼을 추가하고, 이를 프라이머리 키로 설정하면 된다. <br>
이렇게 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 **인조 식별자**라고 한다. <br>
그리고 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 인조 식별자를 이용해 프라이머리 키를 설정하는 것이 성능 향상에 도움이 된다.
