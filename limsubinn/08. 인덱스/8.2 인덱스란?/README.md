## 8.2 인덱스란?
데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. <br>
따라서 컬럼의 값과 해당 레코드가 저장된 주소를 key-value 쌍으로 인덱스를 만들어두는 것이다. <br>
또한, 인덱스는 저장되는 컬럼의 값을 이용해 항상 정렬된 상태를 유지한다. <br>
인덱스가 많은 테이블은 INSERT, UPDATE, DELETE 처리는 느리지만, SELECT는 빠르다.
<br>

테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, <br>
읽기 속도를 얼마나 더 빠르게 만들어야 하는지에 따라 결정해야 한다. <br>
SELECT 쿼리 문장의 WHERE 조건절에 사용되는 컬럼이라고 해서 전부 인덱스로 생성하면 <br>
데이터 저장 성능이 떨어지고 인덱스 크기가 비대해져 오히려 역효과를 불러올 수 있다. 
<br>

인덱스는 여러 기준으로 나눠볼 수 있다.
- 역할별로 구분
  - 프라이머리 키: 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스. NOT NULL, UNIQUE
  - 세컨더리 인덱스: 프라이머리 키를 제외한 인덱스
- 데이터 저장 방식(알고리즘)별로 구분
  - B-Tree: 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱. MySQL에서는 위치 기반 검색을 지원하기 위한 R-Tree(B-Tree의 응용) 알고리즘도 있다.
  - Hash: 컬럼의 값으로 해시값을 계산해서 인덱싱. 매우 빠른 검색. 값의 일부만 검색하거나 범위를 검색할 때는 사용할 수 없다.
- 중복 허용 여부로 구분
  - unique: 유니크 인덱스에 대해 동등 조건으로 검색한다는 것은 항생 1개의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.
  - non-unique
- 기능별로 구분
  - 전문 검색용
  - 공간 검색용
