## 8.3 B-Tree 인덱스
데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로, 가장 먼저 도입된, 가장 범용적인 목적으로 사용되는 알고리즘이다. <br>
일반적으로 DBMS에서는 주로 B+-Tree 또는 B*-Tree 알고리즘이 사용된다.
<br>

컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다.

<br>

### 8.3.1 구조 및 특성
트리 구조의 최상위에 하나의 "루트 노드"가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다. <br>
트리 구조의 가장 하위에 있는 노드를 "리프 노드"라 하고, 트리 노드에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 "브랜치 노드"라고 한다. <br>
데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, <br>
인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다. <br>
<br>

<img width="800" alt="image" src="https://github.com/user-attachments/assets/4d65be2e-8b47-484d-9ff2-6fa8f49a254e"> <br>
<br>

인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있다. <br>

> 대부분의 RDBMS의 데이터 파일에서 레코드는 임의의 순서로 저장된다. <br>
> 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.

인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. <br>
이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다. <br>
<br>

![image](https://github.com/user-attachments/assets/4ccf6224-c4a6-4508-937f-d385d32113a4) <br>
<br>

위의 그림은 **MyISAM 테이블**의 인덱스와 데이터 파일의 관계를 보여준다. <br>
"레코드 주소"는 레코드가 테이블에 INSERT된 순번이거나 데이터 파일 내의 위치(Offset)이다. <br>
세컨더리 인덱스가 **물리적인 주소**를 가진다. <br>

> MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 Heap 공간처럼 활용된다. (INSERT 순서대로 데이터 파일에 저장) <br>
> 그리고 저장되는 레코드는 모두 ROWID라는 물리적인 주솟값을 가지는데, 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가진다.
> - 고정 길이 ROWID: ROWID 값으로 4바이트 정수를 사용하고, 레코드가 INSERT된 순번이 ROWID로 사용된다.
> - 가변 길이 ROWID: 첫 번째 바이트는 ROWID의 길이를 저장하는 용도로 사용하고 나머지 공간은 실제 ROWID를 저장하는 데 사용한다. 데이터 파일에서 레코드의 위치(offset)가 ROWID로 사용된다.

![image](https://github.com/user-attachments/assets/3097c123-5dca-4fed-bb81-34e6fa200577) <br>
<br>

위의 그림은 **InnoDB 테이블**의 인덱스와 데이터 파일의 관계를 보여준다. <br>
프라이머리 키가 ROWID의 역할을 하고, 프라이머리 키를 주소처럼 사용하기 때문에 **논리적인 주소**를 가진다. <br>
인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, <br>
프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다. <br>
즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 <br>
반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

<br>

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
<br>

**1️⃣ 인덱스 키 추가**
<br>

B-Tree에 새로운 키 값이 저장될 때에는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. <br>
저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. <br>
이때 리프 노드가 꽉 차서 더이상 저장할 수 없을 땐 리프 노드가 분리되어야 해서 상위 브랜치 노드까지 처리의 범위가 넓어진다.
<br>

B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다. <br>
대부분의 비용은 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이다.
<br>

MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블은 INSERT 문장 실행 시 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다. <br>
InnoDB 스토리지 엔진은 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제하고, <br>
보조 인덱스에 대해서는 체인지 버퍼를 이용하여 인덱스 키 추가 작업을 지연시킬 수 있다. 

<br>

**2️⃣ 인덱스 키 삭제**
<br>

해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크를 한다. <br>
이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다. <br>
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 디스크 I/O가 필요한 작업이다. <br>
MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연 처리될 수 있다.

<br>

**3️⃣ 인덱스 키 변경**
<br>

인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로, B-Tree의 경우 단순히 인덱스상의 키 값만 변경하는 것이 불가능하다. <br>
먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

<br>

**4️⃣ 인덱스 키 검색**
<br>

B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행한다. => "트리 탐색" <br>
인덱스 트리 탐색은 SELECT뿐만 아니라 UPDATE나 DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용된다. <br>
B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. <br>
부등호 비교 조건에서도 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다. <br>
또한, 인덱스의 키 값에 변형이 가해진 후 비교되는 경우 사용할 수 없다. (함수나 연산을 수행한 결과로 정렬하거나 검색하는 작업) 
<br>

InnoDB 스토리지 엔진에서 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다. <br>
따라서 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

<br>

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
<br>

**1️⃣ 인덱스 키 값의 크기**
<br>

InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 한다. <br>
페이지는 디스크의 모든 읽기 및 쓰기 작업의 최소 단위가 된다. <br>
또한, 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. <br>
인덱스도 페이지 단위로 관리되며, 루트 / 브랜치 / 리프 노드를 구분한 기준이 페이지 단위이다.
<br>

일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. <br>
이때 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 개수가 결정된다. 
<br>

예를 들어, 인덱스의 키가 16바이트, 자식 노드 주소 영역이 평균적으로 12바이트로 구성된다고 가정해보자. <br>
이때 하나의 인덱스 페이지(16KB)에 `16 * 1024 / (16 + 12) = 585`개를 저장할 수 있다. <br>
자식 노드를 585개를 가질 수 있는 B-Tree가 되는 것이다. <br>
인덱스 키 값의 크기가 32바이트(2배)로 늘어났다고 가정하면, 한 페이지에 인덱스 키를 `16 * 1024 / (32 + 12) = 372`개 저장할 수 있다. <br>
레코드 500개를 읽을 때 전자는 인덱스 페이지 한 번으로 해결될 수 있지만, 후자는 최소 2번 이상 디스크로부터 읽어야 한다. <br>
결국 **인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다**는 것을 의미한다.
<br>

인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미한다. <br>
인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 <br>
하나의 레코드를 위한 인덱스 크기가 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다. <br>
이는 결국 메모리의 효율이 떨어지는 결과를 가져온다.

<br>

**2️⃣ B-Tree 깊이**
<br>

인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 키 값의 개수가 적어지고, <br>
때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.
<br>

위의 예시를 다시 한번 살펴보자. <br>
만약 인덱스의 B-Tree 깊이가 3인 경우, 키 값이 16바이트인 경우에는 최대 2억(585^3)개 정도의 키 값을 담을 수 있지만, <br>
키 값이 32바이트로 늘어나면 5천만(372^3)개로 줄어든다. 

<br>

**3️⃣ 선택도(기수성)**
<br>

모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. <br>
인덱스 키 값 가운데 중복된 값이 많아질수록 기수성은 낮아지고, 선택도 또한 떨어진다. <br>
인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다. <br>

> 선택도가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 나은 경우도 있다.

<br>

**4️⃣ 읽어야 하는 레코드의 건수**
<br>

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 읽는 것보다 높은 비용이 드는 작업이다. <br>
인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있다. <br>
일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 <br>
테이블에서 직접 레코드 1건을 읽는 것보다 4-5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다. <br>
즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20-25%를 넘어서면 <br>
인덱스를 이용하지 않고 테이블을 모두 직접 읽어 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

<br>

