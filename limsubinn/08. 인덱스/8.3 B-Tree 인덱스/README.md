## 8.3 B-Tree 인덱스
데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로, 가장 먼저 도입된, 가장 범용적인 목적으로 사용되는 알고리즘이다. <br>
일반적으로 DBMS에서는 주로 B+-Tree 또는 B*-Tree 알고리즘이 사용된다.
<br>

컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다.

<br>

### 8.3.1 구조 및 특성
트리 구조의 최상위에 하나의 "루트 노드"가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다. <br>
트리 구조의 가장 하위에 있는 노드를 "리프 노드"라 하고, 트리 노드에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 "브랜치 노드"라고 한다. <br>
데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, <br>
인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다. <br>
<br>

<img width="800" alt="image" src="https://github.com/user-attachments/assets/4d65be2e-8b47-484d-9ff2-6fa8f49a254e"> <br>
<br>

인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있다. <br>

> 대부분의 RDBMS의 데이터 파일에서 레코드는 임의의 순서로 저장된다. <br>
> 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.

인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. <br>
이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다. <br>
<br>

![image](https://github.com/user-attachments/assets/4ccf6224-c4a6-4508-937f-d385d32113a4) <br>
<br>

위의 그림은 **MyISAM 테이블**의 인덱스와 데이터 파일의 관계를 보여준다. <br>
"레코드 주소"는 레코드가 테이블에 INSERT된 순번이거나 데이터 파일 내의 위치(Offset)이다. <br>
세컨더리 인덱스가 **물리적인 주소**를 가진다. <br>

> MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 Heap 공간처럼 활용된다. (INSERT 순서대로 데이터 파일에 저장) <br>
> 그리고 저장되는 레코드는 모두 ROWID라는 물리적인 주솟값을 가지는데, 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가진다.
> - 고정 길이 ROWID: ROWID 값으로 4바이트 정수를 사용하고, 레코드가 INSERT된 순번이 ROWID로 사용된다.
> - 가변 길이 ROWID: 첫 번째 바이트는 ROWID의 길이를 저장하는 용도로 사용하고 나머지 공간은 실제 ROWID를 저장하는 데 사용한다. 데이터 파일에서 레코드의 위치(offset)가 ROWID로 사용된다.

![image](https://github.com/user-attachments/assets/3097c123-5dca-4fed-bb81-34e6fa200577) <br>
<br>

위의 그림은 **InnoDB 테이블**의 인덱스와 데이터 파일의 관계를 보여준다. <br>
프라이머리 키가 ROWID의 역할을 하고, 프라이머리 키를 주소처럼 사용하기 때문에 **논리적인 주소**를 가진다. <br>
인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, <br>
프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다. <br>
즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 <br>
반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

<br>

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
<br>

**1️⃣ 인덱스 키 추가**
<br>

B-Tree에 새로운 키 값이 저장될 때에는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. <br>
저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. <br>
이때 리프 노드가 꽉 차서 더이상 저장할 수 없을 땐 리프 노드가 분리되어야 해서 상위 브랜치 노드까지 처리의 범위가 넓어진다.
<br>

B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다. <br>
대부분의 비용은 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이다.
<br>

MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블은 INSERT 문장 실행 시 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다. <br>
InnoDB 스토리지 엔진은 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제하고, <br>
보조 인덱스에 대해서는 체인지 버퍼를 이용하여 인덱스 키 추가 작업을 지연시킬 수 있다. 

<br>

**2️⃣ 인덱스 키 삭제**
<br>

해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크를 한다. <br>
이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다. <br>
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 디스크 I/O가 필요한 작업이다. <br>
MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연 처리될 수 있다.

<br>

**3️⃣ 인덱스 키 변경**
<br>

인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로, B-Tree의 경우 단순히 인덱스상의 키 값만 변경하는 것이 불가능하다. <br>
먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

<br>

**4️⃣ 인덱스 키 검색**
<br>

B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행한다. => "트리 탐색" <br>
인덱스 트리 탐색은 SELECT뿐만 아니라 UPDATE나 DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용된다. <br>
B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. <br>
부등호 비교 조건에서도 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다. <br>
또한, 인덱스의 키 값에 변형이 가해진 후 비교되는 경우 사용할 수 없다. (함수나 연산을 수행한 결과로 정렬하거나 검색하는 작업) 
<br>

InnoDB 스토리지 엔진에서 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다. <br>
따라서 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

<br>

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
<br>

**1️⃣ 인덱스 키 값의 크기**
<br>

InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 한다. <br>
페이지는 디스크의 모든 읽기 및 쓰기 작업의 최소 단위가 된다. <br>
또한, 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. <br>
인덱스도 페이지 단위로 관리되며, 루트 / 브랜치 / 리프 노드를 구분한 기준이 페이지 단위이다.
<br>

일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. <br>
이때 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 개수가 결정된다. 
<br>

예를 들어, 인덱스의 키가 16바이트, 자식 노드 주소 영역이 평균적으로 12바이트로 구성된다고 가정해보자. <br>
이때 하나의 인덱스 페이지(16KB)에 `16 * 1024 / (16 + 12) = 585`개를 저장할 수 있다. <br>
자식 노드를 585개를 가질 수 있는 B-Tree가 되는 것이다. <br>
인덱스 키 값의 크기가 32바이트(2배)로 늘어났다고 가정하면, 한 페이지에 인덱스 키를 `16 * 1024 / (32 + 12) = 372`개 저장할 수 있다. <br>
레코드 500개를 읽을 때 전자는 인덱스 페이지 한 번으로 해결될 수 있지만, 후자는 최소 2번 이상 디스크로부터 읽어야 한다. <br>
결국 **인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다**는 것을 의미한다.
<br>

인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미한다. <br>
인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 <br>
하나의 레코드를 위한 인덱스 크기가 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다. <br>
이는 결국 메모리의 효율이 떨어지는 결과를 가져온다.

<br>

**2️⃣ B-Tree 깊이**
<br>

인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 키 값의 개수가 적어지고, <br>
때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.
<br>

위의 예시를 다시 한번 살펴보자. <br>
만약 인덱스의 B-Tree 깊이가 3인 경우, 키 값이 16바이트인 경우에는 최대 2억(585^3)개 정도의 키 값을 담을 수 있지만, <br>
키 값이 32바이트로 늘어나면 5천만(372^3)개로 줄어든다. 

<br>

**3️⃣ 선택도(기수성)**
<br>

모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. <br>
인덱스 키 값 가운데 중복된 값이 많아질수록 기수성은 낮아지고, 선택도 또한 떨어진다. <br>
인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다. <br>

> 선택도가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 나은 경우도 있다.

<br>

**4️⃣ 읽어야 하는 레코드의 건수**
<br>

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 읽는 것보다 높은 비용이 드는 작업이다. <br>
인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있다. <br>
일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 <br>
테이블에서 직접 레코드 1건을 읽는 것보다 4-5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다. <br>
즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20-25%를 넘어서면 <br>
인덱스를 이용하지 않고 테이블을 모두 직접 읽어 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

<br>

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
어떤 경우에 인덱스를 사용하게 유도할지, 또는 사용하지 못하게 할지 판단하려면 
MySQL의 각 스토리지 엔진이 어떻게 인덱스를 이용(경유)해서 실제 레코드를 읽어 내는지 알아야 한다.

<br>

**1️⃣ 인덱스 레인지 스캔**
<br>

대표적인 인덱스의 접근 방식이다. 다른 두 가지 방법에 비해 빠르다.

<br>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/00d37803-3930-43cc-bc11-1c2bb523d610"> <br>
위 그림은 실제 인덱스만을 읽는 경우의 레인지 스캔 과정이다. <br>
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. <br>
검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다. <br>
루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야 필요한 레코드의 시작 지점을 찾을 수 있다. <br>
시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다. <br>
이처럼 차례대로 쭉 읽는 것을 스캔이라고 표현한다. <br>
만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아 다시 스캔한다.

<br>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/42dc9884-667a-4474-ba10-08a60df26c56"> <br>
위 그림은 실제 데이터 파일의 레코드를 읽어와야 하는 경우의 레인지 스캔 과정이다. <br>
B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향(오름차순 또는 내림차순)으로 인덱스를 읽어 나간다. <br>
어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 형태로 레코드를 가져온다. <br>
이는 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다. <br>
또한, 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. <br>
이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다. <br>
그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다. <br>
인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다.

<br>

```
💡 정리
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. => 인덱스 탐색
2. 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. -> 인덱스 스캔
3. 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
```
쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수도 있는데, 이를 커버링 인덱스라고 한다. <br>
커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다. <br>

> 커버링 인덱스? <br>
> 쿼리를 충족시키는데 필요한 모든 데이터를 갖고 있는 인덱스

<br>

```sql
mysql> SHOW STATUS LIKE 'Handler_%';
```
- `Handler_read_key`: 1번 단계가 실행된 횟수
- `Handler_read_next`: 2번 단계로, 인덱스 정순으로 읽은 레코드 건수
- `Handler_read_prev`: 2번 단계로, 인덱스 역순으로 읽은 레코드 건수
- `Handler_read_first`: 인덱스의 첫 번째 레코드를 읽은 횟수
- `Handler_read_last`: 인덱스의 마지막 레코드를 읽은 횟수

<br>

**2️⃣ 인덱스 풀 스캔**
<br>

인덱스의 처음부터 끝까지 모두 읽는 방식이다. <br>
대표적으로 쿼리의 조건절에 사용된 컬럼이 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다. <br>
e.g. 인덱스는 (A, B, C) 컬럼의 순서로 만들어져 있지만 쿼리의 조건절은 B 컬럼이나 C 컬럼으로 검색하는 경우

<br>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/0088401e-31f0-4748-b165-1de711737fb8"> <br>
인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 Linked List를 따라서 처음부터 끝까지 스캔한다. <br>
인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. <br>
인덱스에 포함된 컬럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문이다.

<br>

**3️⃣ 루스 인덱스 스캔**
<br>

말 그대로 느슨하게 또는 듬성듬성하게 레코드를 읽는 것을 의미한다. <br>
인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다. <br>
일반적으로 `GROUP BY` 또는 집합 함수 가운데 `MAX()` 또는 `MIN()` 함수에 대해 최적화를 하는 경우 사용된다.
<br>

e.g.
```sql
mysql> SELECT dept_no, MIN(emp_no)
       FROM dept_emp
       WHERE dept_no BETWEEN 'd002' AND 'd004'
       GROUP BY dept_no;
```
![image](https://github.com/user-attachments/assets/f7dffe30-b0dc-4a7f-b736-6ca8c1ef718d) <br>
dept_emp 테이블은 dept_no와 emp_no라는 두 개의 컬럼으로 인덱스가 생성되어 있다. <br>
또한, 이 인덱스는 (dept_no, emp_no) 조합으로 정렬까지 되어 있어 dept_no 그룹 별로 첫 번째 레코드의 emp_no 값만 읽으면 된다. <br>
즉, 인덱스에서 WHERE 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저가 알고 있기 때문에 <br>
조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 넘어간다.

<br>

**4️⃣ 인덱스 스킵 스캔**
<br>

데이터베이스 서버에서 인덱스는 값이 정렬되어 있으며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요하다. <br>
예를 들어, employees 테이블에 (gender, birth_date) 와 같은 인덱스를 생성했다면, <br>
이 인덱스를 사용하기 위해 WHERE 조건절에 gender 컬럼과 birth_date 컬럼에 대한 비교 조건이 필수적이다.
<br>

MySQL 8.0부터는 옵티마이저가 gender 컬럼을 건너뛰어 birth_date 컬럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입되었다. <br>
이는 WHERE 조건절의 검색을 위해 사용 가능하도록 루스 인덱스 스캔에 비해 용도가 훨씬 넓어졌다.

<br>

```sql
mysql> SELECT gender, birth_date
       FROM employees
       WHERE birth_date >= '1965-02-01';
```
<img width="371" alt="image" src="https://github.com/user-attachments/assets/e412ca4e-3fae-4b71-ac26-ba58805149a0"> <br>
MySQL 옵티마이저는 우선 gender 컬럼에서 유니크한 값을 모두 조회해서 <br>
주어진 쿼리에 gender 컬럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다. <br>
내부적으로 위와 같이 2개의 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행하게 되는 것이다.
```sql
mysql> SELECT gender, birth_date FROM employees WHERE gender = 'M' AND birth_date >= '1965-02-01';
mysql> SELECT gender, birth_date FROM employees WHERE gender = 'F' AND birth_date >= '1965-02-01';
```

<br>

인덱스 스킵 스캔은 새로 도입된 기능이어서 아직 단점이 있다.
- WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함
  - 만약 유니크한 값의 개수가 매우 많다면 MySQL 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다.
    그래서 쿼리의 처리 성능이 오히려 더 느려질 수도 있다.
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)
  - 인덱스에 포함된 컬럼 이의외 나머지 컬럼도 필요로 하기 때문에 인덱스 스킵 스캔을 사용하지 못하고 풀 테이블 스캔으로 실행 계획을 수립한다.
 
<br>

### 8.3.5 다중 칼럼(Multi-column) 인덱스
실제 서비스용 데이터베이스에서는 2개 이상의 컬럼을 포함하는 인덱스가 더 많이 사용된다. <br>
두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스라고 한다. <br>

<img width="440" alt="image" src="https://github.com/user-attachments/assets/7a1ea559-b0f5-4d05-9f8f-24bbc6318364"> <br>
인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다. 즉, 두 번째 컬럼의 정렬은 첫 번째 컬럼이 똑같은 레코드에서만 의미가 있다. <br>
마찬가지로 컬럼이 4개인 인덱스를 생성하면 세 번째 컬럼은 두 번째 컬럼에 의존, 네 번째 컬럼은 세 번째 컬럼에 의존해서 정렬된다. <br>
따라서 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치(순서)가 중요하다.

<br>

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
인덱스를 생성할 때 설정한 정렬 규칙에 따라 인덱스의 키 값은 항상 오름차순 또는 내림차순으로 정렬되어 저장된다. <br>
하지만 어떤 인덱스가 오름차순으로 생성됐다고 해서 그 인덱스를 오름차순으로만 읽을 수 있다는 뜻은 아니다. <br>
인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.

<br>

**1️⃣ 인덱스의 정렬**
<br>

MySQL 8.0부터는 정렬 순서를 혼합한(오름차순 + 내림차순) 인덱스를 생성할 수 있다.
```sql
mysql> CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

<br>

1. 인덱스 스캔 방향
   - 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향(최솟값부터 또는 최댓값부터)에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.
   - e.g. 아래의 쿼리는 인덱스가 오름차순으로 정렬되어 있지만 인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다.
     ```sql
     mysql> SELECT * FROM employees ORDER BY first_name DESC LIMIT 1;
     ```

2. 내림차순 인덱스
   - 오름차순 인덱스: 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스 <br>
     내림차순 인덱스: 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스 <br>
     인덱스 정순 스캔: 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔 <br>
     인덱스 역순 스캔: 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
   - 테이블을 풀 스캔하면서 정렬을 수행하는 쿼리를 실행한 결과, 역순 정렬 쿼리가 정순 정렬 쿼리보다 시간이 더 오래 걸린다. <br>
     페이지 잠금이 인덱스 정순 스캔에 적합한 구조이고, 페이지 내에서 인덱스 레코드가 단방향으로 연결된 구조이기 때문이다. <br>
     <img width="470" alt="image" src="https://github.com/user-attachments/assets/3dc8a5de-a211-43ed-a309-17be9898902b">
   - ```sql
     mysql> SELECT * FROM tab WHERE userid=? ORDER BY score DESC LIMIT 10;
     ```
     위와 같은 쿼리의 경우, 두 가지 인덱스 모두 적절한 선택이 될 수 있다.
     ```
     오름차순 인덱스: INDEX (userid ASC, score ASC)
     내림차순 인덱스: INDEX (userid DESC, score DESC)
     ```
     하지만 위 쿼리가 많은 레코드를 조회하면서 빈번하게 실행된다면 오름차순 인덱스보다는 내림차순 인덱스가 더 효율적일 것이다.

<br>

### 8.3.7 B-Tree 인덱스의 가용성과 효율성
쿼리의 WHERE 조건이나 GROUP BY, 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야
쿼리의 조건을 최적화하거나, 역으로 쿼리에 맞게 인덱스를 최적으로 생성할 수 있다.

<br>

**1️⃣ 비교 조건의 종류와 효율성**
<br>

다중 컬럼 인덱스에서 각 컬럼의 순서와 그 컬럼에 사용된 조건이 동등 비교인지 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태와 효율이 달라진다. 
<br>

e.g.
```sql
mysql> SELECT * FROM dept_emp
       WHERE dept_no = 'd002' AND emp_no >= 10114;
```
<img width="496" alt="image" src="https://github.com/user-attachments/assets/1a6dc7f3-37d2-41cb-bb24-2b0eae69077b"> <br>
- `INDEX (dept_no, emp_no)`
  - "dept_no = 'd002' AND emp_no >= 10114"인 레코드를 찾고, 이후 dept_no가 'd002'가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 된다.
  - 이 경우 읽은 레코드가 모두 사용자가 원하는 결과이다. 상당히 효율적으로 인덱스를 이용한 것이다.
  - 인덱스에서의 조건이 작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'이라 한다.
- `INDEX (emp_no, dept_no)`
  - "emp_no >= 10114 AND dept_no = 'd002'"인 레코드를 찾고, 그 이후 모든 레코드에 대해 dept_no가 'd002'인지 비교하는 과정을 거쳐야 한다.
  - 이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 '필터링'이라고 한다.
  - 인덱스의 조건이 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 '필터링 조건' 또는 '체크 조건'이라고 표현한다.

💡 결론: 작업 범위를 결정하는 조건은 많을수록 쿼리의 처리 성능을 높이지만, 체크 조건은 많다고 해서 쿼리의 성능을 높이지 못한다. 오히려 쿼리 실행을 더 느리게 만들 때가 많다.

<br>

**2️⃣ 인덱스의 가용성**
<br>

B-Tree 인덱스의 특징은 왼쪽 값에 기준해서(Left-most) 오른쪽 값이 정렬되어 있다는 것이다.

<br>

두 개의 인덱스를 생성했다고 가정해보자.
- `INDEX (first_name)`
- `INDEX (dept_no, emp_no)`

위의 두 인덱스는 왼쪽 값을 기준으로 정렬된다. <br>
<img width="400" alt="image" src="https://github.com/user-attachments/assets/c1e3769d-13d6-4530-b8c0-8d599091bf26"> <br>

이때, `SELECT * FROM employees WHERE first_name LIKE '%mer';`과 같은 쿼리를 실행한다면 <br>
이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없다. <br>
왜냐하면 first_name 컬럼에 저장된 값의 왼쪽부터 한 글자씩 비교하면서 일치하는 레코드를 찾아야 하는데, <br>
조건절에 주어진 값('%mer')은 왼쪽 부분이 고정되어 있지 않기 때문이다. <br>
따라서 정렬 우선순위가 낮은 뒷부분의 값만으로는 B-Tree에서 인덱스 효과를 얻을 수 없다.
<br>

또한, `SELECT * FROM dept_emp WHERE emp_no >= 10144;`와 같은 쿼리를 실행한다면 <br>
인덱스의 선행 컬럼인 dept_no 조건 없이 emp_no 값으로만 검색했기 때문에 인덱스를 효율적으로 사용할 수 없다. <br>
두 번째 인덱스는 다중 컬럼으로 구성된 인덱스이므로 dept_no 컬럼에 대해 먼저 정렬한 후, 다시 emp_no 컬럼값으로 정렬되어 있기 때문이다.

<br>

**3️⃣ 가용성과 효율성 판단**
<br>

- B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다. (작업 범위 결정 조건으로)
  - NOT-EQUAL로 비교된 경우("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
  - LIKE '%?' 형태(뒷부분만 일치)로 문자열 패턴이 비교된 경우
  - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
  - 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)
  - 문자열 데이터 타입의 콜레이션이 다른 경우
- 다른 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스에 저장된다.
- 다중 컬럼으로 만들어진 인덱스는 어떤 경우에서는 사용할 수 있고, 어떤 경우에는 사용할 수 없다.
  - 사용할 수 있는 경우
    - column_1 ~ column_(i-1) 컬럼까지 동등 비교 형태 (=, IN)
    - column_i 컬럼에 대해 동등 비교(=, IN), 대소 비교(<, >), LIKE로 좌측 일치 패턴('a%') 중 하나로 비교
  - 사용할 수 없는 경우
    - column_1 컬럼에 대한 조건이 없는 경우
    - column_1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
