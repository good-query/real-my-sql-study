## 7.1 MySQL 서버의 데이터 암호화
- MySQL 서버는 데이터베이스 서버와 디스크 사이의 데이터 읽고 쓰기 지점에서(I/O 레이어) 암호화 또는 복호화를 수행한다.
  ![image](https://github.com/user-attachments/assets/1f3ee634-035c-4b10-9c27-47c2e53e7f45)
- **TDE(Transparent Data Encryption)**: 투명한 데이터 암호화
  - MySQL 서버에서 사용자의 쿼리를 처리하는 과정에서 테이블의 데이터가 암호화되어 있는지 여부를 식별할 필요가 없음
  - **Data at Rest Encryption**: 메모리(In-Process)나 네트워크 전송(In-Transit) 단계가 아닌 디스크에 저장(At Rest)된 단계에서만 암호화된다는 의미

<br>

### 7.1.1 2단계 키 관리
MySQL 서버의 TDE에서 암호화 키는 키링(KeyRing) 플러그인에 의해 관리된다.
- `keyring_file` File-Based 플러그인 (커뮤니티 에디션)
- `keyring_encrypted_file` Keyring 플러그인 (엔터프라이즈 에디션)
- `keyring_okv` KMIP 플러그인 (엔터프라이즈 에디션)
- `keyring_aws` Amazon Web Services Keyring 플러그인 (엔터프라이즈 에디션)

<br>

MySQL 서버의 키링 플러그인은 2단계(2-Tier) 키 관리 방식을 사용한다.
![image](https://github.com/user-attachments/assets/65c800e7-09bc-4642-b523-6af9deb8a220)
- 마스터 키와 테이블스페이스 키를 가지고 있다.
  - 테이블스페이스 키는 프라이빗 키라고도 한다.
- HashiCorp Vault 같은 외부 키 관리 솔루션(KMS) 또는 디스크의 파일(keyring_file 또는 keyring_encrypted_file 플러그인 사용 시)에서 마스터 키를 가져오고,
  암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키를 발급한다.
  그리고 MySQL 서버는 마스터 키를 이용해 테이블스페이스 키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장한다.
- 이렇게 생성된 테이블스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않는다.
  하지만 테이블스페이스 키는 절대 MySQL 서버 외부로 노출되지 않기 때문에 테이블스페이스 키를 주기적으로 변경하지 않아도 보안상 취약점이 되지 않는다.
- 마스터 키는 외부의 파일을 이용하기 때문에 노출될 가능성이 있다.
  그래서 마스터 키는 주기적으로 변경해야 한다.
  ```sql
  mysql> ALTER INSTANCE ROTATE INNODB MASTER KEY;
  ```
- 마스터 키를 변경하면 MySQL 서버는 기존의 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화한다.
- 2단계 암호화 방식을 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위해서다.
  테이블스페이스 키가 변경된다면 MySQL 서버는 데이터 파일의 모든 데이터를 다시 복호화했다가 다시 암호화해야 한다.
- TDE에서 지원되는 알고리즘은 AES 256이다.
  - 테이블스페이스 키: AES-256 ECB
  - 데이터 파일: AES-256 CBC

<br>

### 7.1.2 암호화와 성능
디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB의 버퍼 풀에 적재된다. <br>
그래서 데이터 페이지가 한 번 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능을 보인다.
<br>

InnoDB 버퍼 풀에 존재하지 않는 데이터 페이지를 읽어야 하는 경우에는 복호화 과정을 거치기 때문에 쿼리 처리가 지연될 것이다. <br>
그리고 암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 암호화되어야 하기 때문에 디스크에 저장할 때도 추가로 시간이 더 걸린다. <br>
하지만 데이터 페이지 저장은 MySQL 서버의 백그라운드 스레드가 수행하기 때문에 실제 사용자의 쿼리가 지연되는 것은 아니다. <br>
SELECT뿐만 아니라 UPDATE, DELETE 명령 또한 변경하고자 하는 레코드를 InnoDB 버퍼 풀로 읽어와야 하기 때문에 <br>
새롭게 읽어야 하는 데이터 페이지의 개수에 따라 그만큼의 복호화 지연이 발생한다.
<br>

데이터 페이지는 AES 알고리즘의 암호화 키보다 훨씬 크기 때문에 암호화 결과가 평문의 결과와 동일한 크기의 암호문을 반환한다. <br>
따라서 TDE를 적용한다고 해도 데이터 파일의 크기는 암호화되지 않은 테이블과 동일한 크기를 갖는다. <br>
즉, 암호화한다고 해서 InnoDB 버퍼 풀의 효율이 달라지거나 메모리 사용 효율이 떨어지는 현상은 발생하지 않는다. 
<br>

같은 테이블에 대해 암호화와 압축이 동시에 적용되면 MySQL 서버는 압축을 먼저 실행하고 암호화를 적용한다.
- 일반적으로 암호화된 결과문은 아주 랜덤한 바이트의 배열을 가지게 되는데, 이는 압축률을 상당히 떨어뜨린다.
- 또한, 압축화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만, 압축된 데이터 페이지는 압축/압축해제 상태로 InnoDB 버퍼 풀에 저장될 수 있다.
  따라서 암호화가 먼저 실행된다면 MySQL 서버는 InnoDB 버퍼 풀에 존재하는 데이터 페이지에 대해서도 매번 암복호화 작업을 수행해야 한다.

<br>

암호화된 테이블의 읽고 쓰기 성능을 직접 확인해보고자 한다면 다음 쿼리를 이용하자.
```sql
mysql> SELECT (SUM(SUM_TIMER_READ) / SUM(COUNT_READ))/1000000000 as avg_read_latency_ms,
              (SUM(SUM_TIMER_WRITE) / SUM(COUNT_WRITE))/1000000000 as avg_write_latency_ms
       FROM performance_schema.file_summary_by_instance
       WHERE file_name LIKE '%DB_NAME/TABLE_NAME%';
```

<br>

### 7.1.3 암호화와 복제
소스 서버와 레플리카 서버는 서로 각자의 마스터 키와 테이블스페이스 키를 관리한다. <br>
따라서 복제 멤버들의 데이터 파일은 암호화 되기 전의 값이 동일하더라도 실제 암호화된 데이터가 저장된 데이터 파일의 내용은 완전히 달라진다.
<br>

- 복제 소스 서버의 마스터 키를 변경할 때 `ALTER INSTANCE ROTATE INNODB MASTER KEY` 명령을 실행하는데,
  이때 명령 자체는 레플리카 서버로 복사되지만 실제 소스 서버의 마스터 키 자체가 레플리카 서버로 전달되는 것은 아니다.
- MySQL 서버의 백업에서 TDE의 키링 파일을 백업하지 않는 경우, 키링 파일을 찾지 못하면 데이터 복구를 할 수 없게 된다.
- 키링 파일을 데이터 백업과 별도로 백업한다면 마스터 키 로테이션 명령으로 TDE의 마스터 키가 언제 변경됐는지까지 기억하고 있어야 한다.
