MySQL은 일반 상용 RDBMS와 같이 대부분의 프로그램 언어로 부터 접근 방법을 모두 지원함.

InnoDB vs. MyISAM, 두 가지 스토리지 엔진 비교!
![alt text](image.png)
읽기에서는 MyISAM이 느릴때도 있습니다. 조회는 미친듯이 빠릅니다.

MySQL 서버는
- MySQL 엔진 + Storage 엔진
- 스레드 기반으로 작동한다. (포그라운드, 백그라운드)


MySQL 엔진은
- 커넥션 핸들러, SQL 파서 및 전처리기, 옵티마이저로 이루어져 있다.
- 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 한다.
- Storage 엔진과 달리 하나만 존재한다.

👀 커넥션 핸들러 (Connection Handler)
	•	비유: “레스토랑의 안내원(접객 담당)”
	•	설명: 클라이언트(사용자)와 MySQL 서버 간의 연결을 관리하는 역할을 한다. 사용자의 요청을 받아들이고, 인증 및 세션 관리를 수행한다.

👀 SQL 파서 및 전처리기 (SQL Parser & Preprocessor)
	•	비유: “주방으로 가기 전에 주문서를 정리하는 직원”
	•	설명: 사용자가 입력한 SQL 문장을 분석하고(파싱), 문법 오류를 검사하며, 테이블과 컬럼이 존재하는지 확인하는 역할을 한다.

👀 옵티마이저 (Optimizer)
	•	비유: “요리를 가장 효율적으로 만드는 요리사”
	•	설명: SQL 쿼리를 최적화하여 가장 빠르고 효율적인 실행 계획을 세운다. 인덱스 사용 여부, 조인 순서 등을 결정한다.



Storage 엔진은 
- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 역할을 한다.
- 여러개가 동시에 사용할 수 있다.
- 각 스토리지 엔진은 성능향상을 위해 키캐시나 버퍼풀과 같은 기능을 내장하고 있다. 
- 키캐시를 가졌냐 버퍼풀을 가졌냐에 따라서 MyISAM InnoDB 구분된다.

👀 키 캐시(Key Cache) 🗝
	•	MyISAM 스토리지 엔진에서 인덱스(key) 검색 속도를 높이기 위해 사용하는 캐시. 자주 조회되는 인덱스를 메모리에 저장하여 디스크 접근을 줄인다.
    - 그럼 사용자가 직접 만든 인덱스 같은게 없다면 기본 primarykey 인덱스만 저장됨?
    ㅇㅇ. 사용자가 별도로 인덱스를 생성하지 않으면 MySQL은 기본적으로 PRIMARY KEY 인덱스만 저장

👀 버퍼 풀(Buffer Pool) 🛠
	•	InnoDB 스토리지 엔진에서 데이터와 인덱스를 캐싱하여 성능을 향상시키는 메모리 공간. 디스크 I/O를 최소화하여 속도를 높인다.
    - 버퍼풀은 데이터자체와 인덱스 저장공간인거고 키캐시는 인덱스만 저장된 곳?
    ㅇㅇ. 버퍼 풀(Buffer Pool)은 데이터 자체 + 인덱스를 저장하는 공간이고, 키 캐시(Key Cache)는 인덱스만 저장하는 공간입니다. 

CREATE TABLE test_table(fd1 INT, fd2 INT) ENGINE=INNODB;
-> test_table은 스토리지 엔진을 사용하도록 정의한 것 이제 test_table에 대한 CRUD 작업은 InnoDB 스토리지 엔진이 담당하게됨.


핸들러 API는
- 스토리지 엔진을 일시킬수 있는 명령어.
- MySQL 엔진이 핸들러 API를 호출해서 스토리지 엔진이 일을 수행하는 구조다.

![alt text](image-1.png)

포그라운드 스레드는
- 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재한다.
- 각 클라이언트사용자가 요청하는 Query 문장 처리한다.
- 클라이언트가 커넥션 종료시 다시 스레드 캐시로 돌아간다.
- 데이터를 데이터 버퍼나 캐시로부터 가져오며, 없으면 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업을 처리한다.

백그라운드 스레드는
- MyISAM은 해당사항 별로없지만 InnoDB는 여러가지 작업이 백 그라운드로 처리된다.
- MySQL 서버 설정 내용에 따라 갯수가 가변적으로 변할 수 있다.
- 인서트 버퍼를 병합하는 스레드, 로그를 디스크로 기록하는 스레드, InnoDB 버퍼풀의 데이터를 버퍼로 읽어오는 스레드, 잠금이나 데드락을 모니터링하는 스레드 등등이 있다.
- DAS 와 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 쓰기스레드를 충분히 설정하는 것이 좋다.


👀 인서트 버퍼 병합 스레드 (Insert Buffer Merge Thread)
	•	상황: 인덱스가 없는 테이블에 다량의 INSERT가 발생할 때
	•	역할: 변경된 데이터를 먼저 인서트 버퍼(메모리)에 저장한 후, 나중에 디스크의 실제 인덱스에 병합하여 디스크 I/O 부하를 줄임.

👀 버퍼 풀 플러시 스레드 (Buffer Pool Flush Thread)
	•	상황: 버퍼 풀에 저장된 데이터가 가득 차거나, 트랜잭션이 커밋될 때
	•	역할: 변경된 데이터를 일정 주기마다 디스크에 기록(Flush)하여 데이터 손실을 방지함.

👀 데이터 읽기 스레드 (Read Thread)
	•	상황: 버퍼 풀에 없는 데이터를 조회할 때
	•	역할: 필요한 데이터를 디스크에서 읽어와 버퍼 풀에 로드하여 성능을 향상시킴.

👀 잠금 & 데드락 모니터링 스레드 (Lock Monitor Thread)
	•	상황: 여러 트랜잭션이 동시에 같은 데이터를 수정하면서 충돌이 발생할 때
	•	역할: 트랜잭션 간의 잠금 충돌을 감지하고, 데드락(교착 상태)이 발생하면 특정 트랜잭션을 강제로 롤백하여 문제 해결.


👀 왜 MyISAM은 포그라운드가 주 역할이고, InnoDB는 일부만 포그라운드이고 나머지는 백그라운드인가?

📌 MyISAM은 포그라운드 스레드 중심 (Foreground-Only)

    이유:
	•	MyISAM은 단순한 구조를 가지고 있으며, 트랜잭션(Transactions)이나 복잡한 백그라운드 작업을 처리할 필요가 없음.
	•	모든 작업(SELECT, INSERT, UPDATE 등)은 사용자의 요청이 들어올 때 즉시 처리되므로, 포그라운드 스레드가 주 역할을 담당.
	•	캐시 관리(키 캐시)도 간단하여 별도의 백그라운드 관리 스레드가 필요하지 않음.
    결과:
	•	MyISAM은 포그라운드 스레드만 사용하여 빠르게 데이터를 읽고 저장하지만, 추가적인 최적화나 유지 보수 작업을 하지 않음.
	•	그 대신, MyISAM은 전체 테이블 잠금(Table-Level Locking) 방식을 사용하여 동시성 처리에 한계가 있음.

📌 InnoDB는 일부 포그라운드 + 강력한 백그라운드 스레드 사용

    이유:
	•	InnoDB는 트랜잭션, 데이터 무결성, 동시 처리 최적화 등 복잡한 기능을 지원함.
	•	데이터와 인덱스를 **버퍼 풀(Buffer Pool)**에 저장하여 성능을 높이기 위해 백그라운드 스레드가 필수적임.
	•	변경된 데이터를 백그라운드에서 디스크에 플러시(Flush)하고, 로그 파일을 관리하며, 트랜잭션을 정리하는 작업이 필요함.
    결과:
	•	InnoDB는 사용자 요청(SQL 실행)은 포그라운드 스레드에서 처리,
	•	이후 버퍼 풀 관리, 데이터 저장(플러시), 로그 정리 등의 작업은 백그라운드 스레드에서 실행.
	•	백그라운드 스레드가 병렬로 데이터를 정리하고 관리하므로, 성능과 안정성이 높아짐.

MySQL 에서 사용되는 메모리 공간은?
- 글로벌 메모리 영역 + 로컬 메모리 영역 
- MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.
  
글로벌 메모리 영역은?
- MySQL 서버가 시작되면서 운영체제로부터 할당된다.
- 모든 스레드에게 공유된다.
- 테이블 캐시, InnoDB 버퍼풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼 영역이 있다.

👀 테이블 캐시 (Table Cache) 🗂
	•	역할: 자주 사용되는 테이블의 메타데이터(열 정보, 인덱스 등)를 캐싱하여 테이블을 열고 닫는 비용을 줄임.
	•	사용 상황: 여러 스레드가 동일한 테이블을 자주 접근하는 경우 성능 향상.
	•	설정 변수: table_open_cache
    예시:
	•	SQL 실행 시, 매번 테이블을 열고 닫는 오버헤드를 줄이기 위해 테이블 정보를 캐싱하여 속도 향상.

👀 InnoDB 버퍼 풀 (InnoDB Buffer Pool) 🛠
	•	역할: InnoDB에서 가장 중요한 캐시 공간으로, 디스크에서 읽어온 데이터와 인덱스를 메모리에 저장하여 성능 향상.
	•	사용 상황: 자주 조회되는 데이터나 인덱스를 빠르게 가져오기 위해 활용.
	•	설정 변수: innodb_buffer_pool_size
    예시:
	•	SELECT 실행 시, 디스크에서 데이터를 가져오는 대신 버퍼 풀에서 즉시 읽어 속도 증가.

👀 InnoDB 어댑티브 해시 인덱스 (InnoDB Adaptive Hash Index) ⚡
	•	역할: 자주 사용되는 인덱스를 자동으로 분석하여, 해시 인덱스를 생성하여 검색 속도를 향상.
	•	사용 상황: 특정 패턴의 조회 쿼리가 많을 때 자동으로 적용됨.
	•	설정 변수: innodb_adaptive_hash_index
    예시:
	•	SELECT * FROM users WHERE email = 'test@example.com'; 같은 동일한 쿼리가 반복될 경우 해시 인덱스를 만들어 빠르게 검색.

👀 InnoDB 리두 로그 버퍼 (InnoDB Redo Log Buffer) 📝
	•	역할: 트랜잭션 변경 내용을 임시 저장하여 데이터 무결성을 보장하고, 일정 주기마다 디스크에 기록(Flush)함.
	•	사용 상황: 대량의 INSERT, UPDATE, DELETE 작업이 있을 때, 로그 버퍼에 기록 후 나중에 일괄 저장하여 성능 최적화.
	•	설정 변수: innodb_log_buffer_size
    예시:
	•	UPDATE orders SET status = 'shipped' WHERE id = 10; 실행 시, 디스크에 바로 쓰지 않고 로그 버퍼에 저장한 후 나중에 일괄 기록(Flush).

로컬 메모리 영역은?
- 세션 메모리 영역, 클라이언트 메모리 영역이라고도 표현한다.
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리영역
- 사용자 또는 클라이언트가 접속할때마다 할당해주며 각 사용자끼리는 독립된 로컬메모리영역을 할당받게 되며 공유되지 않는다.
- 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼 등이 있다.

👀 정렬 버퍼 (Sort Buffer) 📊
	•	역할: ORDER BY, GROUP BY 같은 정렬 작업을 수행할 때 사용.

👀 조인 버퍼 (Join Buffer) 🔄
	•	역할: 조인(특히 Nested Loop Join)이 발생할 때 데이터를 캐싱하여 조인 성능을 향상.
	•	사용 상황: 인덱스가 없는 조인을 수행할 때 사용됨.

👀 바이너리 로그 캐시 (Binary Log Cache) 📝
    •	역할: 트랜잭션을 실행하는 동안 **바이너리 로그(Binary Log)**를 메모리에 임시 저장하여 성능을 최적화.
    •	사용 상황: 트랜잭션이 커밋될 때까지 로그를 메모리에 보관 후, 나중에 한 번에 디스크에 기록.

👀 네트워크 버퍼 (Network Buffer) 🌐
	•	역할: 클라이언트와 MySQL 서버 간의 데이터 송수신을 처리하는 버퍼.
	•	사용 상황: 대량의 데이터를 주고받을 때 네트워크 성능을 최적화.

쿼리 실행 구조?
- 사용자 요청 -> 쿼리파서 -> 전처리기 -> 옵티마이저 -> 쿼리실행기 -> 스토리지 엔진

쿼리파서는?
- 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL 이 인식할 수 있는 최소 단위의 어휘나 기호)로 분리해 트리형태의 구조로 만들어내는 작업이다.
- 기본문법 오류가 여기서 발견되고 오류메시지를 전달하게 된다.

전처리기는?
- 파서트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
- 테이블 이름, 칼럼이름 등을 비교해 해당 객체의 존재여부와 객체 접근 권한 등을 확인한다.
- 존재하지않거나 권한상 사용할수 없는 개체의 토큰은 여기서 걸러짐.

옵티마이저는?
- DBMS의 두뇌역할
- 겁나중요함.

핸들러는?
- MySQL 서버의 가장 밑단
- 데이터를 디스크로 저장, 디스크로부터 읽어오는 역할
- 결국 스토리지 엔진임

스레드 풀은?
- 엔터프라이즈에서는 제공
- 커뮤니티에디션에서는 플러그인형태로 Percona Server에서 제공하는 스레드풀 기능 존재
- 내부적으로 사용자의 요청을 처리하는 스레드 갯수를 줄여 서버자원소모를 줄이는것이 목표
- 기본적으로 CPU 코어의 갯수만큼 스레드그룹을 생성 -> CPU 프로세서 친화도를 높일수 있다.
- 선순위,후순위 큐를 이용해 공유되는 데이터 경합을 낮춰 전체적인 처리성능을 향상시키기도 한다.

👀 CPU 프로세서 친화도? 
	•	CPU 프로세서 친화도 = 특정 스레드를 특정 CPU에서만 실행시키는 것
	•	목적 = CPU 캐시를 효율적으로 사용하여 속도를 높이고, 불필요한 CPU 변경을 줄이기 위함

트랜잭션 지원 메타데이터?
- 과거에는 FRM파일 같은데다가 테이블 구조같은걸 저장했었으나 트랜잭션 지원이 되지않아 일관되지 않은 상태로 남는 문제 발생했었음.
- 8.0 에서 이를 InnoDB 테이블에 저장하게끔 만들었으며 사용자가 임의로 수정할수 없게 볼수없게 처리해버림
- 결론은 있다. mysql.ibd 에 있으니 주의하자.
  

