InnoDB 는?
- MySQL 에서 사용할 수 있는 스토리지 엔진중 거의 유일하게 레코드기반의 잠금을 제공함.
- 그 덕에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어남.
  
Primary 키에 의한 클러스터링
- InnoDB의 모든 테이블은 Primary Key 값의 순서대로 디스크에 저장된다.
- Primary Key가 클러스터링 인덱스이기에 Primary Key를 활용한 레인지 스캔은 상당히 빨리 처리된다.

👀 클러스터링 인덱스?
- 테이블생성시 자동으로 생성되는 인덱스
- primary key 로 select 조회시 겁나빠름

외래키 지원
- 외래키의 존재에 주의하지 않을시 수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다.
- foreign_key_checks 시스템 변수를 0으로 설정하면 외래키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.
- SET foregin_key_checks=OFF;
- 이거 하면 ON DELETE CASCADE도 무시된다. 그러니 부모테이블 레코드를 삭제했다면 자식테이블 레코드도 삭제할 것.
  
MVCC
- 일반적으로 레드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- InnoDB는 언두로그를 이용해 이 기능을 구현

👀 레코드 레벨의 트랜잭션이란?
- 레코드 레벨의 트랜잭션은 데이터베이스의 한 개 또는 여러 개의 레코드(행, Row)에 대해 수행되는 단위 작업(Transaction) 을 의미합니다. 이는 레코드 단위로 격리성을 보장하여, 하나의 트랜잭션이 특정 레코드를 수정하는 동안에도 다른 트랜잭션이 동일 테이블의 다른 레코드를 자유롭게 수정할 수 있도록 합니다.
- 이 방식은 데이터베이스의 동시성을 향상시키고, 불필요한 락(Lock)으로 인한 병목 현상을 방지하는 데 중요한 역할을 합니다.
- 만약 작업중인 레코드를 조회하면 MySQL 서버의 시스템 변수 transaction_isolation에 설정된 격리수준 레벨에 따라 반환되는 데이터가 다를 수 있음

👀 언두로그란?
- Undo Log는 트랜잭션이 변경하기 전의 데이터를 저장하는 로그로, MySQL(InnoDB)에서 MVCC(다중 버전 동시성 제어, Multi-Version Concurrency Control) 및 트랜잭션 롤백을 지원하기 위한 핵심 요소
- 간단히 말해, Undo Log는 “되돌릴 수 있는 변경 사항의 기록”을 남겨, 데이터가 변경되기 전 상태를 복원할 수 있도록 합니다.

잠금 없는 일관된 읽기
- isolation 이 Serializable 이 아니라면 insert와 연결되지 않은 select 작업은 잠금대기없이 바로 실행됨 
- 그러므로써 읽기로 인한 잠금상태 를 설정하지 않게되고 성능향상

자동 데드락감지 
- Mysql은 데드락 테이블이 있고 데드락 발생된 트랜잭션 찾아서 강제종료
- 언두로그 양이 적은 트랜잭션을 우선순위로 강제종료

자동화된 장애 복구
- InnoDB는 부팅시 자동복구
- 하드웨어나 디스크 문제로 자동화된 복구를 못할때도 존재
- 이럴땐 innodb_force_recovery 시스템변수 설정으로 mysql 서버 시작하자.
- 단계가 1~6 존재하고 단계가 높을수록 심각한 상태이고 복구가 어려울수 있다.
  - 로그파일 손상 => 6
  - 데이터 파일 손상 => 1
  - 뭔지 모르겠으면 1~6 변경한채로 부팅시도 ㄱ
- 만약 부팅이 성공적으로 되고 innodb 테이블이 인식된다면 데이터 백업 => 백업데이터를 활용해 DB와 테이블을 다시생성 하자.
- InnoDB의 복구를 이용하는거보다 마지막 백업으로 데이터베이스 새로 구축하고 바이너리 로그를 사용해 최대한 장애시점까지의 데이터를 복구해라
  
버퍼풀
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 디스크의 데이터파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼역할도함
- 크기설정 : 
  - 운영체제와 각 클라이언트 스레드가 사용할 메모리 양도 충분히 고려해서 설정해라
  - 8GB라면 50% 그이상이라면 차차 올려보던가식
- 버퍼풀 크기설정 가능 : innodb_buffer_pool_size -> 크리티컬하니까 한가할때 하자.
- 가능하면 버퍼풀의 크기를 줄이는 변경은 하지말자.
- 버퍼풀 인스턴트당 5GB정도가 되게 버퍼풀 인스턴스를 설정하자. 기존 8개
- LRU, MRU 결합된 형태로 데이터 페이지 캐시
- InnoDB 버퍼 풀은 데이터 캐시와 쓰기 버퍼링이라는 두가지 용도가 있는데 버퍼풀의 메모리 공간만 단순히 늘리는건 데이터 캐시 기능만 향상시키는것.


👀 레코드버퍼 
- 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용되는 공간을 말함
- 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수도 있다.
- 레코드 버퍼가 사용할 레코드 버퍼 공간은 별도 설정가능(5.7이상), 커넥션 갯수와 커넥션에서 읽고 쓰는 테이블의 갯수에 따라 정해짐
- 이버퍼 공간은 동적으로 해제되기도 하므로 정확히 필요한 메모리 공간크기를 계산할 수 가 없다.

버퍼풀과 리두로그 관계
- 버퍼풀에는 클린페이지(변경없는)와 더티페이지(변경된)를 갖고 있다.
- 언젠가는 버퍼풀의 더티페이지를 디스크로 써야함
- Log Sequence Number (LSN)은 순환되어 재사용 되는 로그의 번호, 로그포지션은 계속해서 증가된 값을 갖게된다. 
- 최근 엔트리의 LSN과 마지막 LSN의 차이는 결국 활성 리두 로그 공간의 크기

플러시 리스트 플러시
- 백그라운드 동작
- 리두공간의 재활용을 위해 필요함
- 오래된 더티페이지가 디스크로 동기화 되는데 사용
- 더티페이지를 디스크로 동기화 하는 스레드를 클리너 스레드라고 함
- innodb_page_cleaners 시스템 변수를 통해 클리너 스레드의 갯수를 조정할 수 있게 함.

어댑티브 플러시 
- 리두로그의 증가속도를 분석해 적절한 수준의 더티페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기함

LRU 리스트 플러시
- LRU 리스트에서 사용빈도가 낮은 데이터 페이지들을 제거
- LRU 리스트의 끝부분부터 시스템 변수에 설정된 갯수만큼의 페이지 스캔하고 더티페이지는 디스크에 동기화
- 클린 페이지는 프리리스트로 페이지 옮김

버퍼 풀 상태 백업 및 복구
- 버퍼 풀이 성능에 큰영향을 미침
- 버퍼풀 덤프 및 적재 기능 도입됨 (5.6 부터)
- 서버 다시 시작시 버퍼 풀상태 복구함

Double Write Buffer
- 리두로그 공간의 낭비를 막기위해 페이지의 변경된 내용만 기록함
- 이처럼 파셜페이지, 톤페이지와 같은 일부만 기록하는 문제가 발생하면 하드웨어의 오작동이나 시스템 비정상 종료 등의 문제발생
- 더티페이지를 디스크로 플러시 할때 한번의 디스크 쓰기로 테이블 스페이스의 DoubleWrite Buffer에 기록한다

언두 로그 
- InnoDB 스토리지 엔진은 트랜잭션과 격리수준을 보장하기 위해 별도 데이터 백업을 진행함.
- 백업된 데이터를 Undo Log 라고 함 
- 언두로그는 중요한 역할을 담당하지만 관리비용도 많이듦 
- 언두로그의 데이터는 크게 두가지 용도로 사용됨
  - 롤백 대비용
  - 트랜잭션의 격리수준유지 동시성 제공
- 

트랜잭션 보장
- 트랜잭션이 롤백되면 트랜잭션도중 변경된 데이터를 변경전 데이터로 복구하는것

격리수준 보장
- 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리수준에 맞게 변경중인 레코드를 읽지않고 언두 로그에 백업해둔 데이터를 읽어 반환함


언두로그 모니터링
- 언두로그는 5.7 이후 부터 그리고 8.0 들어서 필요없는 로그는 삭제되게끔 최적화 되었지만 활성상태의 트랜잭션이 장시간 유지되는건 성능상 좋지않음
- 그래서 언두로그는 항상 모니터링하는것이 좋다.
- 왜냐면 언두로그가 길어질수록 모든 언두로그를 둘러봐야하기 때문이다. (활성상태의 트랜잭션이 진행중인 데이터를 읽을때 모든 언두체인을 다 둘러보게됨)

언두 테이블스페이스 관리
- 언두 로그가 저장되는 공간
- 언두 테이블 스페이스는 1~128개의 롤백세그먼트로
- 롤백 세그먼트는 1개이상의 언두슬롯을 가짐

👀 롤백 세그먼트 VS 언두 슬롯
- 롤백 세그먼트는 “사물함”이고,
  언두 슬롯은 “그 사물함 안의 작은 칸”,
  하나의 트랜잭션은 “그 칸을 하나 빌려서 기록을 남기고”,
  트랜잭션이 끝나면 “칸을 비우는” 구조입니다.


체인지 버퍼
- 레코드가 Insert 되거나 update 될때는 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요
  인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요해 테이블에 인덱스가 많다면 상당히 많은 자원을 소모하게된다.
  그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 그렇지않고 디스크로부터 읽어와서 업데이트해야한다면
  이를 즉시 실행하지 않고 임시공간에 저장해두고 사용자에게 결과를 바로 반환하는 형태로 성능을 향상시키게되는데 이때 사용하는 임시 메모리 공간을 
  체인지 버퍼라고함.

👀 왜? 왜 굳이 인덱스 바로 업데이트를 하지않고?
- 랜덤 디스크 I/O를 피할수 있다고합니다. 이게 상당히 느리다고함


👀 랜덤 디스크 I/O가 무엇인가?
- 막말로 for 문으로 포인터를 1~10000까지 옮기는게 순차 디스크 I/O
- 이야 지린다. 인덱스는 거의 대부분 랜덤 디스크 I/O

버퍼 머지 스레드
- 버퍼에 존재하는 내용을 머지(병합)하는 백그라운드 스레드
- 8.0에서  insert,delete,update로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선됨
  
리두 로그 
- 소프트웨어나 하드웨어적인 문제로 인해 서버가 비정상종료되었을 때 데이터파일에 기록되지 못한 데이터를 지키기 위한 안전장치
- 거의 대부분의 DB서버는 서버 데이터 변경 내용을 로그로 먼저 기록한다. 
- 거의 모든 DBMS에서 데이터 파일은 쓰기보다 읽기성능을 고려한 자료구조를 갖고있어 데이터 파일쓰기는 디스크의 랜덤 액세스가 필요
- 비정상 종료시 리두로그의 내용을 이용해 데이터파일을 다시 서버가 종료되기 직전의 상태로 복구
- 리두로그는 트랜잭션이 커밋될때마다 리두로그를 디스크에 기록하는 작업은 많은 부하를 유발해 리두로그를 어느주기로 디스크에 동기화할지 결정하는 시스템변수 존재
- mysql 8 부터 리두로그 비활성 가능

리두 로그 아카이빙
- MySQL 8부터 리두로그를 아카이핑 가능
- 아카이빙을 시작하는 UDF는 mysql서버를 실행하는 유저만이 접근 가능해야하며
- ON/OFF 가 가능한데 아카이빙을 실행한 세션이 연결이 끊어지면 X
- 리두로그 아카이빙을 시작한 세션이 UDF를 실행하기 전에 세션끊기면 아카이빙된 리두로그 무쓸모되어 삭제해버림
- 작업이 완료되면 아카이빙을 종료해야함.

👀 아카이빙?
- 오래된 데이터를 분리해서 별도 보관하는 작업

어댑티브 해시 인덱스
- 세상에 얘는 mysql이 사용자가 자주 요청하는 데이터에 대해 자동으로 인덱스를 생성하는 기능
- B-Tree 검색시간을 줄여주기위해 도입된 기능
- 사용자가 직접 보는게아니라 DB 즈그가 쓸려고 만든 테이블처럼 생긴 인덱스
- InnoDB 의 세마포어 내부잠금도 획기적으로 줄일 수 있다.(B+Tree를 타는 시간을 없애버릴수 있으니 시간절약)

어댑티브 해시 인덱스가 도움되는지 불필요한지 판단하는 법
- MySQL 서버의 상태값 살펴보기
- CPU 사용량이 높은데 해시 인덱스 히트율이 28% 정도라면 효율적
- but CPU 사용량이 낮은데 히트율이 28% 정도면 비활성화 하는게 더 나음

👀 세마포어?
- 공유자원에 접근하기때문에 Select 라도 '안전하게 보기위해' DB 내부적으로 락이 걸림 

MyISAM VS InnoDB
- 지금까진 MyISAM이 기본 스토리지 엔진으로 사용되는 경우가 많았음
- 8.0 부터 MySQL 서버의 모든 시스템 테이블이 InnoDB 스토리지 엔진으로 교체됨
- 공간 좌표 검색, 전문검색 기능 모두 InnoDB 스토리지 엔진 지원하도록 바뀜
- MyISAM 스토리지 엔진은 사리질 전망







